"""File generated by TLObjects' generator. All changes will be ERASED"""
from ...tl.tlobject import TLObject
from typing import Optional, List, Union, TYPE_CHECKING
from . import help, storage, auth, contacts, messages, updates, photos, upload, account, channels, payments, phone
import os
import struct
if TYPE_CHECKING:
    from ...tl.types import TypeBool, Typefuture_salt, Typedouble
    from ...tl.types.contacts import TypeLink



class AccessPointRule(TLObject):
    CONSTRUCTOR_ID = 0x4679b65f
    SUBCLASS_OF_ID = 0xb1aca0fd

    def __init__(self, phone_prefix_rules, dc_id, ips):
        """
        :param str phone_prefix_rules:
        :param int dc_id:
        :param List[TypeIpPort] ips:

        Constructor for AccessPointRule: Instance of AccessPointRule.
        """
        self.phone_prefix_rules = phone_prefix_rules  # type: str
        self.dc_id = dc_id  # type: int
        self.ips = ips  # type: List[TypeIpPort]

    def to_dict(self):
        return {
            '_': 'AccessPointRule',
            'phone_prefix_rules': self.phone_prefix_rules,
            'dc_id': self.dc_id,
            'ips': [] if self.ips is None else [None if x is None else x.to_dict() for x in self.ips]
        }

    def __bytes__(self):
        return b''.join((
            b'_\xb6yF',
            self.serialize_bytes(self.phone_prefix_rules),
            struct.pack('<i', self.dc_id),
            struct.pack('<i', len(self.ips)),b''.join(bytes(x) for x in self.ips),
        ))

    @classmethod
    def from_reader(cls, reader):
        _phone_prefix_rules = reader.tgread_string()
        _dc_id = reader.read_int()
        _ips = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _ips.append(_x)

        return cls(phone_prefix_rules=_phone_prefix_rules, dc_id=_dc_id, ips=_ips)


class AccountDaysTTL(TLObject):
    CONSTRUCTOR_ID = 0xb8d0afdf
    SUBCLASS_OF_ID = 0xbaa39d88

    def __init__(self, days):
        """
        :param int days:

        Constructor for AccountDaysTTL: Instance of AccountDaysTTL.
        """
        self.days = days  # type: int

    def to_dict(self):
        return {
            '_': 'AccountDaysTTL',
            'days': self.days
        }

    def __bytes__(self):
        return b''.join((
            b'\xdf\xaf\xd0\xb8',
            struct.pack('<i', self.days),
        ))

    @classmethod
    def from_reader(cls, reader):
        _days = reader.read_int()
        return cls(days=_days)


class Authorization(TLObject):
    CONSTRUCTOR_ID = 0x7bf2e6f6
    SUBCLASS_OF_ID = 0xc913c01a

    def __init__(self, hash, flags, device_model, platform, system_version, api_id, app_name, app_version, date_created, date_active, ip, country, region):
        """
        :param int hash:
        :param int flags:
        :param str device_model:
        :param str platform:
        :param str system_version:
        :param int api_id:
        :param str app_name:
        :param str app_version:
        :param int date_created:
        :param int date_active:
        :param str ip:
        :param str country:
        :param str region:

        Constructor for Authorization: Instance of Authorization.
        """
        self.hash = hash  # type: int
        self.flags = flags  # type: int
        self.device_model = device_model  # type: str
        self.platform = platform  # type: str
        self.system_version = system_version  # type: str
        self.api_id = api_id  # type: int
        self.app_name = app_name  # type: str
        self.app_version = app_version  # type: str
        self.date_created = date_created  # type: int
        self.date_active = date_active  # type: int
        self.ip = ip  # type: str
        self.country = country  # type: str
        self.region = region  # type: str

    def to_dict(self):
        return {
            '_': 'Authorization',
            'hash': self.hash,
            'flags': self.flags,
            'device_model': self.device_model,
            'platform': self.platform,
            'system_version': self.system_version,
            'api_id': self.api_id,
            'app_name': self.app_name,
            'app_version': self.app_version,
            'date_created': self.date_created,
            'date_active': self.date_active,
            'ip': self.ip,
            'country': self.country,
            'region': self.region
        }

    def __bytes__(self):
        return b''.join((
            b'\xf6\xe6\xf2{',
            struct.pack('<q', self.hash),
            struct.pack('<i', self.flags),
            self.serialize_bytes(self.device_model),
            self.serialize_bytes(self.platform),
            self.serialize_bytes(self.system_version),
            struct.pack('<i', self.api_id),
            self.serialize_bytes(self.app_name),
            self.serialize_bytes(self.app_version),
            struct.pack('<i', self.date_created),
            struct.pack('<i', self.date_active),
            self.serialize_bytes(self.ip),
            self.serialize_bytes(self.country),
            self.serialize_bytes(self.region),
        ))

    @classmethod
    def from_reader(cls, reader):
        _hash = reader.read_long()
        _flags = reader.read_int()
        _device_model = reader.tgread_string()
        _platform = reader.tgread_string()
        _system_version = reader.tgread_string()
        _api_id = reader.read_int()
        _app_name = reader.tgread_string()
        _app_version = reader.tgread_string()
        _date_created = reader.read_int()
        _date_active = reader.read_int()
        _ip = reader.tgread_string()
        _country = reader.tgread_string()
        _region = reader.tgread_string()
        return cls(hash=_hash, flags=_flags, device_model=_device_model, platform=_platform, system_version=_system_version, api_id=_api_id, app_name=_app_name, app_version=_app_version, date_created=_date_created, date_active=_date_active, ip=_ip, country=_country, region=_region)


class BadMsgNotification(TLObject):
    CONSTRUCTOR_ID = 0xa7eff811
    SUBCLASS_OF_ID = 0xcebaa157

    def __init__(self, bad_msg_id, bad_msg_seqno, error_code):
        """
        :param int bad_msg_id:
        :param int bad_msg_seqno:
        :param int error_code:

        Constructor for BadMsgNotification: Instance of either BadMsgNotification, BadServerSalt.
        """
        self.bad_msg_id = bad_msg_id  # type: int
        self.bad_msg_seqno = bad_msg_seqno  # type: int
        self.error_code = error_code  # type: int

    def to_dict(self):
        return {
            '_': 'BadMsgNotification',
            'bad_msg_id': self.bad_msg_id,
            'bad_msg_seqno': self.bad_msg_seqno,
            'error_code': self.error_code
        }

    def __bytes__(self):
        return b''.join((
            b'\x11\xf8\xef\xa7',
            struct.pack('<q', self.bad_msg_id),
            struct.pack('<i', self.bad_msg_seqno),
            struct.pack('<i', self.error_code),
        ))

    @classmethod
    def from_reader(cls, reader):
        _bad_msg_id = reader.read_long()
        _bad_msg_seqno = reader.read_int()
        _error_code = reader.read_int()
        return cls(bad_msg_id=_bad_msg_id, bad_msg_seqno=_bad_msg_seqno, error_code=_error_code)


class BadServerSalt(TLObject):
    CONSTRUCTOR_ID = 0xedab447b
    SUBCLASS_OF_ID = 0xcebaa157

    def __init__(self, bad_msg_id, bad_msg_seqno, error_code, new_server_salt):
        """
        :param int bad_msg_id:
        :param int bad_msg_seqno:
        :param int error_code:
        :param int new_server_salt:

        Constructor for BadMsgNotification: Instance of either BadMsgNotification, BadServerSalt.
        """
        self.bad_msg_id = bad_msg_id  # type: int
        self.bad_msg_seqno = bad_msg_seqno  # type: int
        self.error_code = error_code  # type: int
        self.new_server_salt = new_server_salt  # type: int

    def to_dict(self):
        return {
            '_': 'BadServerSalt',
            'bad_msg_id': self.bad_msg_id,
            'bad_msg_seqno': self.bad_msg_seqno,
            'error_code': self.error_code,
            'new_server_salt': self.new_server_salt
        }

    def __bytes__(self):
        return b''.join((
            b'{D\xab\xed',
            struct.pack('<q', self.bad_msg_id),
            struct.pack('<i', self.bad_msg_seqno),
            struct.pack('<i', self.error_code),
            struct.pack('<q', self.new_server_salt),
        ))

    @classmethod
    def from_reader(cls, reader):
        _bad_msg_id = reader.read_long()
        _bad_msg_seqno = reader.read_int()
        _error_code = reader.read_int()
        _new_server_salt = reader.read_long()
        return cls(bad_msg_id=_bad_msg_id, bad_msg_seqno=_bad_msg_seqno, error_code=_error_code, new_server_salt=_new_server_salt)


class BindAuthKeyInner(TLObject):
    CONSTRUCTOR_ID = 0x75a3f765
    SUBCLASS_OF_ID = 0x2f099171

    def __init__(self, nonce, temp_auth_key_id, perm_auth_key_id, temp_session_id, expires_at):
        """
        :param int nonce:
        :param int temp_auth_key_id:
        :param int perm_auth_key_id:
        :param int temp_session_id:
        :param Optional[datetime] expires_at:

        Constructor for BindAuthKeyInner: Instance of BindAuthKeyInner.
        """
        self.nonce = nonce  # type: int
        self.temp_auth_key_id = temp_auth_key_id  # type: int
        self.perm_auth_key_id = perm_auth_key_id  # type: int
        self.temp_session_id = temp_session_id  # type: int
        self.expires_at = expires_at  # type: Optional[datetime]

    def to_dict(self):
        return {
            '_': 'BindAuthKeyInner',
            'nonce': self.nonce,
            'temp_auth_key_id': self.temp_auth_key_id,
            'perm_auth_key_id': self.perm_auth_key_id,
            'temp_session_id': self.temp_session_id,
            'expires_at': self.expires_at
        }

    def __bytes__(self):
        return b''.join((
            b'e\xf7\xa3u',
            struct.pack('<q', self.nonce),
            struct.pack('<q', self.temp_auth_key_id),
            struct.pack('<q', self.perm_auth_key_id),
            struct.pack('<q', self.temp_session_id),
            self.serialize_datetime(self.expires_at),
        ))

    @classmethod
    def from_reader(cls, reader):
        _nonce = reader.read_long()
        _temp_auth_key_id = reader.read_long()
        _perm_auth_key_id = reader.read_long()
        _temp_session_id = reader.read_long()
        _expires_at = reader.tgread_date()
        return cls(nonce=_nonce, temp_auth_key_id=_temp_auth_key_id, perm_auth_key_id=_perm_auth_key_id, temp_session_id=_temp_session_id, expires_at=_expires_at)


class BotCommand(TLObject):
    CONSTRUCTOR_ID = 0xc27ac8c7
    SUBCLASS_OF_ID = 0xe1e62c2

    def __init__(self, command, description):
        """
        :param str command:
        :param str description:

        Constructor for BotCommand: Instance of BotCommand.
        """
        self.command = command  # type: str
        self.description = description  # type: str

    def to_dict(self):
        return {
            '_': 'BotCommand',
            'command': self.command,
            'description': self.description
        }

    def __bytes__(self):
        return b''.join((
            b'\xc7\xc8z\xc2',
            self.serialize_bytes(self.command),
            self.serialize_bytes(self.description),
        ))

    @classmethod
    def from_reader(cls, reader):
        _command = reader.tgread_string()
        _description = reader.tgread_string()
        return cls(command=_command, description=_description)


class BotInfo(TLObject):
    CONSTRUCTOR_ID = 0x98e81d3a
    SUBCLASS_OF_ID = 0xf1f701db

    def __init__(self, user_id, description, commands):
        """
        :param int user_id:
        :param str description:
        :param List[TypeBotCommand] commands:

        Constructor for BotInfo: Instance of BotInfo.
        """
        self.user_id = user_id  # type: int
        self.description = description  # type: str
        self.commands = commands  # type: List[TypeBotCommand]

    def to_dict(self):
        return {
            '_': 'BotInfo',
            'user_id': self.user_id,
            'description': self.description,
            'commands': [] if self.commands is None else [None if x is None else x.to_dict() for x in self.commands]
        }

    def __bytes__(self):
        return b''.join((
            b':\x1d\xe8\x98',
            struct.pack('<i', self.user_id),
            self.serialize_bytes(self.description),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.commands)),b''.join(bytes(x) for x in self.commands),
        ))

    @classmethod
    def from_reader(cls, reader):
        _user_id = reader.read_int()
        _description = reader.tgread_string()
        reader.read_int()
        _commands = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _commands.append(_x)

        return cls(user_id=_user_id, description=_description, commands=_commands)


class BotInlineMediaResult(TLObject):
    CONSTRUCTOR_ID = 0x17db940b
    SUBCLASS_OF_ID = 0x3832b3d5

    def __init__(self, id, type, send_message, photo=None, document=None, title=None, description=None):
        """
        :param str id:
        :param str type:
        :param TypeBotInlineMessage send_message:
        :param Optional[TypePhoto] photo:
        :param Optional[TypeDocument] document:
        :param Optional[str] title:
        :param Optional[str] description:

        Constructor for BotInlineResult: Instance of either BotInlineResult, BotInlineMediaResult.
        """
        self.id = id  # type: str
        self.type = type  # type: str
        self.send_message = send_message  # type: TypeBotInlineMessage
        self.photo = photo  # type: Optional[TypePhoto]
        self.document = document  # type: Optional[TypeDocument]
        self.title = title  # type: Optional[str]
        self.description = description  # type: Optional[str]

    def to_dict(self):
        return {
            '_': 'BotInlineMediaResult',
            'id': self.id,
            'type': self.type,
            'send_message': None if self.send_message is None else self.send_message.to_dict(),
            'photo': None if self.photo is None else self.photo.to_dict(),
            'document': None if self.document is None else self.document.to_dict(),
            'title': self.title,
            'description': self.description
        }

    def __bytes__(self):
        return b''.join((
            b'\x0b\x94\xdb\x17',
            struct.pack('<I', (0 if self.photo is None or self.photo is False else 1) | (0 if self.document is None or self.document is False else 2) | (0 if self.title is None or self.title is False else 4) | (0 if self.description is None or self.description is False else 8)),
            self.serialize_bytes(self.id),
            self.serialize_bytes(self.type),
            b'' if self.photo is None or self.photo is False else (bytes(self.photo)),
            b'' if self.document is None or self.document is False else (bytes(self.document)),
            b'' if self.title is None or self.title is False else (self.serialize_bytes(self.title)),
            b'' if self.description is None or self.description is False else (self.serialize_bytes(self.description)),
            bytes(self.send_message),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _id = reader.tgread_string()
        _type = reader.tgread_string()
        if flags & 1:
            _photo = reader.tgread_object()
        else:
            _photo = None
        if flags & 2:
            _document = reader.tgread_object()
        else:
            _document = None
        if flags & 4:
            _title = reader.tgread_string()
        else:
            _title = None
        if flags & 8:
            _description = reader.tgread_string()
        else:
            _description = None
        _send_message = reader.tgread_object()
        return cls(id=_id, type=_type, send_message=_send_message, photo=_photo, document=_document, title=_title, description=_description)


class BotInlineMessageMediaAuto(TLObject):
    CONSTRUCTOR_ID = 0x764cf810
    SUBCLASS_OF_ID = 0xc4910f88

    def __init__(self, message, entities=None, reply_markup=None):
        """
        :param str message:
        :param Optional[List[TypeMessageEntity]] entities:
        :param Optional[TypeReplyMarkup] reply_markup:

        Constructor for BotInlineMessage: Instance of either BotInlineMessageMediaAuto, BotInlineMessageText, BotInlineMessageMediaGeo, BotInlineMessageMediaVenue, BotInlineMessageMediaContact.
        """
        self.message = message  # type: str
        self.entities = entities  # type: Optional[List[TypeMessageEntity]]
        self.reply_markup = reply_markup  # type: Optional[TypeReplyMarkup]

    def to_dict(self):
        return {
            '_': 'BotInlineMessageMediaAuto',
            'message': self.message,
            'entities': [] if self.entities is None else [None if x is None else x.to_dict() for x in self.entities],
            'reply_markup': None if self.reply_markup is None else self.reply_markup.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\x10\xf8Lv',
            struct.pack('<I', (0 if self.entities is None or self.entities is False else 2) | (0 if self.reply_markup is None or self.reply_markup is False else 4)),
            self.serialize_bytes(self.message),
            b'' if self.entities is None or self.entities is False else b''.join((b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.entities)),b''.join(bytes(x) for x in self.entities))),
            b'' if self.reply_markup is None or self.reply_markup is False else (bytes(self.reply_markup)),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _message = reader.tgread_string()
        if flags & 2:
            reader.read_int()
            _entities = []
            for _ in range(reader.read_int()):
                _x = reader.tgread_object()
                _entities.append(_x)

        else:
            _entities = None
        if flags & 4:
            _reply_markup = reader.tgread_object()
        else:
            _reply_markup = None
        return cls(message=_message, entities=_entities, reply_markup=_reply_markup)


class BotInlineMessageMediaContact(TLObject):
    CONSTRUCTOR_ID = 0x18d1cdc2
    SUBCLASS_OF_ID = 0xc4910f88

    def __init__(self, phone_number, first_name, last_name, vcard, reply_markup=None):
        """
        :param str phone_number:
        :param str first_name:
        :param str last_name:
        :param str vcard:
        :param Optional[TypeReplyMarkup] reply_markup:

        Constructor for BotInlineMessage: Instance of either BotInlineMessageMediaAuto, BotInlineMessageText, BotInlineMessageMediaGeo, BotInlineMessageMediaVenue, BotInlineMessageMediaContact.
        """
        self.phone_number = phone_number  # type: str
        self.first_name = first_name  # type: str
        self.last_name = last_name  # type: str
        self.vcard = vcard  # type: str
        self.reply_markup = reply_markup  # type: Optional[TypeReplyMarkup]

    def to_dict(self):
        return {
            '_': 'BotInlineMessageMediaContact',
            'phone_number': self.phone_number,
            'first_name': self.first_name,
            'last_name': self.last_name,
            'vcard': self.vcard,
            'reply_markup': None if self.reply_markup is None else self.reply_markup.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\xc2\xcd\xd1\x18',
            struct.pack('<I', (0 if self.reply_markup is None or self.reply_markup is False else 4)),
            self.serialize_bytes(self.phone_number),
            self.serialize_bytes(self.first_name),
            self.serialize_bytes(self.last_name),
            self.serialize_bytes(self.vcard),
            b'' if self.reply_markup is None or self.reply_markup is False else (bytes(self.reply_markup)),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _phone_number = reader.tgread_string()
        _first_name = reader.tgread_string()
        _last_name = reader.tgread_string()
        _vcard = reader.tgread_string()
        if flags & 4:
            _reply_markup = reader.tgread_object()
        else:
            _reply_markup = None
        return cls(phone_number=_phone_number, first_name=_first_name, last_name=_last_name, vcard=_vcard, reply_markup=_reply_markup)


class BotInlineMessageMediaGeo(TLObject):
    CONSTRUCTOR_ID = 0xb722de65
    SUBCLASS_OF_ID = 0xc4910f88

    def __init__(self, geo, period, reply_markup=None):
        """
        :param TypeGeoPoint geo:
        :param int period:
        :param Optional[TypeReplyMarkup] reply_markup:

        Constructor for BotInlineMessage: Instance of either BotInlineMessageMediaAuto, BotInlineMessageText, BotInlineMessageMediaGeo, BotInlineMessageMediaVenue, BotInlineMessageMediaContact.
        """
        self.geo = geo  # type: TypeGeoPoint
        self.period = period  # type: int
        self.reply_markup = reply_markup  # type: Optional[TypeReplyMarkup]

    def to_dict(self):
        return {
            '_': 'BotInlineMessageMediaGeo',
            'geo': None if self.geo is None else self.geo.to_dict(),
            'period': self.period,
            'reply_markup': None if self.reply_markup is None else self.reply_markup.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'e\xde"\xb7',
            struct.pack('<I', (0 if self.reply_markup is None or self.reply_markup is False else 4)),
            bytes(self.geo),
            struct.pack('<i', self.period),
            b'' if self.reply_markup is None or self.reply_markup is False else (bytes(self.reply_markup)),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _geo = reader.tgread_object()
        _period = reader.read_int()
        if flags & 4:
            _reply_markup = reader.tgread_object()
        else:
            _reply_markup = None
        return cls(geo=_geo, period=_period, reply_markup=_reply_markup)


class BotInlineMessageMediaVenue(TLObject):
    CONSTRUCTOR_ID = 0x8a86659c
    SUBCLASS_OF_ID = 0xc4910f88

    def __init__(self, geo, title, address, provider, venue_id, venue_type, reply_markup=None):
        """
        :param TypeGeoPoint geo:
        :param str title:
        :param str address:
        :param str provider:
        :param str venue_id:
        :param str venue_type:
        :param Optional[TypeReplyMarkup] reply_markup:

        Constructor for BotInlineMessage: Instance of either BotInlineMessageMediaAuto, BotInlineMessageText, BotInlineMessageMediaGeo, BotInlineMessageMediaVenue, BotInlineMessageMediaContact.
        """
        self.geo = geo  # type: TypeGeoPoint
        self.title = title  # type: str
        self.address = address  # type: str
        self.provider = provider  # type: str
        self.venue_id = venue_id  # type: str
        self.venue_type = venue_type  # type: str
        self.reply_markup = reply_markup  # type: Optional[TypeReplyMarkup]

    def to_dict(self):
        return {
            '_': 'BotInlineMessageMediaVenue',
            'geo': None if self.geo is None else self.geo.to_dict(),
            'title': self.title,
            'address': self.address,
            'provider': self.provider,
            'venue_id': self.venue_id,
            'venue_type': self.venue_type,
            'reply_markup': None if self.reply_markup is None else self.reply_markup.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\x9ce\x86\x8a',
            struct.pack('<I', (0 if self.reply_markup is None or self.reply_markup is False else 4)),
            bytes(self.geo),
            self.serialize_bytes(self.title),
            self.serialize_bytes(self.address),
            self.serialize_bytes(self.provider),
            self.serialize_bytes(self.venue_id),
            self.serialize_bytes(self.venue_type),
            b'' if self.reply_markup is None or self.reply_markup is False else (bytes(self.reply_markup)),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _geo = reader.tgread_object()
        _title = reader.tgread_string()
        _address = reader.tgread_string()
        _provider = reader.tgread_string()
        _venue_id = reader.tgread_string()
        _venue_type = reader.tgread_string()
        if flags & 4:
            _reply_markup = reader.tgread_object()
        else:
            _reply_markup = None
        return cls(geo=_geo, title=_title, address=_address, provider=_provider, venue_id=_venue_id, venue_type=_venue_type, reply_markup=_reply_markup)


class BotInlineMessageText(TLObject):
    CONSTRUCTOR_ID = 0x8c7f65e2
    SUBCLASS_OF_ID = 0xc4910f88

    def __init__(self, message, no_webpage=None, entities=None, reply_markup=None):
        """
        :param str message:
        :param Optional[bool] no_webpage:
        :param Optional[List[TypeMessageEntity]] entities:
        :param Optional[TypeReplyMarkup] reply_markup:

        Constructor for BotInlineMessage: Instance of either BotInlineMessageMediaAuto, BotInlineMessageText, BotInlineMessageMediaGeo, BotInlineMessageMediaVenue, BotInlineMessageMediaContact.
        """
        self.message = message  # type: str
        self.no_webpage = no_webpage  # type: Optional[bool]
        self.entities = entities  # type: Optional[List[TypeMessageEntity]]
        self.reply_markup = reply_markup  # type: Optional[TypeReplyMarkup]

    def to_dict(self):
        return {
            '_': 'BotInlineMessageText',
            'message': self.message,
            'no_webpage': self.no_webpage,
            'entities': [] if self.entities is None else [None if x is None else x.to_dict() for x in self.entities],
            'reply_markup': None if self.reply_markup is None else self.reply_markup.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\xe2e\x7f\x8c',
            struct.pack('<I', (0 if self.no_webpage is None or self.no_webpage is False else 1) | (0 if self.entities is None or self.entities is False else 2) | (0 if self.reply_markup is None or self.reply_markup is False else 4)),
            self.serialize_bytes(self.message),
            b'' if self.entities is None or self.entities is False else b''.join((b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.entities)),b''.join(bytes(x) for x in self.entities))),
            b'' if self.reply_markup is None or self.reply_markup is False else (bytes(self.reply_markup)),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _no_webpage = bool(flags & 1)
        _message = reader.tgread_string()
        if flags & 2:
            reader.read_int()
            _entities = []
            for _ in range(reader.read_int()):
                _x = reader.tgread_object()
                _entities.append(_x)

        else:
            _entities = None
        if flags & 4:
            _reply_markup = reader.tgread_object()
        else:
            _reply_markup = None
        return cls(message=_message, no_webpage=_no_webpage, entities=_entities, reply_markup=_reply_markup)


class BotInlineResult(TLObject):
    CONSTRUCTOR_ID = 0x11965f3a
    SUBCLASS_OF_ID = 0x3832b3d5

    def __init__(self, id, type, send_message, title=None, description=None, url=None, thumb=None, content=None):
        """
        :param str id:
        :param str type:
        :param TypeBotInlineMessage send_message:
        :param Optional[str] title:
        :param Optional[str] description:
        :param Optional[str] url:
        :param Optional[TypeWebDocument] thumb:
        :param Optional[TypeWebDocument] content:

        Constructor for BotInlineResult: Instance of either BotInlineResult, BotInlineMediaResult.
        """
        self.id = id  # type: str
        self.type = type  # type: str
        self.send_message = send_message  # type: TypeBotInlineMessage
        self.title = title  # type: Optional[str]
        self.description = description  # type: Optional[str]
        self.url = url  # type: Optional[str]
        self.thumb = thumb  # type: Optional[TypeWebDocument]
        self.content = content  # type: Optional[TypeWebDocument]

    def to_dict(self):
        return {
            '_': 'BotInlineResult',
            'id': self.id,
            'type': self.type,
            'send_message': None if self.send_message is None else self.send_message.to_dict(),
            'title': self.title,
            'description': self.description,
            'url': self.url,
            'thumb': None if self.thumb is None else self.thumb.to_dict(),
            'content': None if self.content is None else self.content.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b':_\x96\x11',
            struct.pack('<I', (0 if self.title is None or self.title is False else 2) | (0 if self.description is None or self.description is False else 4) | (0 if self.url is None or self.url is False else 8) | (0 if self.thumb is None or self.thumb is False else 16) | (0 if self.content is None or self.content is False else 32)),
            self.serialize_bytes(self.id),
            self.serialize_bytes(self.type),
            b'' if self.title is None or self.title is False else (self.serialize_bytes(self.title)),
            b'' if self.description is None or self.description is False else (self.serialize_bytes(self.description)),
            b'' if self.url is None or self.url is False else (self.serialize_bytes(self.url)),
            b'' if self.thumb is None or self.thumb is False else (bytes(self.thumb)),
            b'' if self.content is None or self.content is False else (bytes(self.content)),
            bytes(self.send_message),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _id = reader.tgread_string()
        _type = reader.tgread_string()
        if flags & 2:
            _title = reader.tgread_string()
        else:
            _title = None
        if flags & 4:
            _description = reader.tgread_string()
        else:
            _description = None
        if flags & 8:
            _url = reader.tgread_string()
        else:
            _url = None
        if flags & 16:
            _thumb = reader.tgread_object()
        else:
            _thumb = None
        if flags & 32:
            _content = reader.tgread_object()
        else:
            _content = None
        _send_message = reader.tgread_object()
        return cls(id=_id, type=_type, send_message=_send_message, title=_title, description=_description, url=_url, thumb=_thumb, content=_content)


class CdnConfig(TLObject):
    CONSTRUCTOR_ID = 0x5725e40a
    SUBCLASS_OF_ID = 0xecda397c

    def __init__(self, public_keys):
        """
        :param List[TypeCdnPublicKey] public_keys:

        Constructor for CdnConfig: Instance of CdnConfig.
        """
        self.public_keys = public_keys  # type: List[TypeCdnPublicKey]

    def to_dict(self):
        return {
            '_': 'CdnConfig',
            'public_keys': [] if self.public_keys is None else [None if x is None else x.to_dict() for x in self.public_keys]
        }

    def __bytes__(self):
        return b''.join((
            b'\n\xe4%W',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.public_keys)),b''.join(bytes(x) for x in self.public_keys),
        ))

    @classmethod
    def from_reader(cls, reader):
        reader.read_int()
        _public_keys = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _public_keys.append(_x)

        return cls(public_keys=_public_keys)


class CdnPublicKey(TLObject):
    CONSTRUCTOR_ID = 0xc982eaba
    SUBCLASS_OF_ID = 0x16db47f3

    def __init__(self, dc_id, public_key):
        """
        :param int dc_id:
        :param str public_key:

        Constructor for CdnPublicKey: Instance of CdnPublicKey.
        """
        self.dc_id = dc_id  # type: int
        self.public_key = public_key  # type: str

    def to_dict(self):
        return {
            '_': 'CdnPublicKey',
            'dc_id': self.dc_id,
            'public_key': self.public_key
        }

    def __bytes__(self):
        return b''.join((
            b'\xba\xea\x82\xc9',
            struct.pack('<i', self.dc_id),
            self.serialize_bytes(self.public_key),
        ))

    @classmethod
    def from_reader(cls, reader):
        _dc_id = reader.read_int()
        _public_key = reader.tgread_string()
        return cls(dc_id=_dc_id, public_key=_public_key)


class Channel(TLObject):
    CONSTRUCTOR_ID = 0xc88974ac
    SUBCLASS_OF_ID = 0xc5af5d94

    def __init__(self, id, title, photo, date, version, creator=None, left=None, editor=None, broadcast=None, verified=None, megagroup=None, restricted=None, democracy=None, signatures=None, min=None, access_hash=None, username=None, restriction_reason=None, admin_rights=None, banned_rights=None, participants_count=None):
        """
        :param int id:
        :param str title:
        :param TypeChatPhoto photo:
        :param Optional[datetime] date:
        :param int version:
        :param Optional[bool] creator:
        :param Optional[bool] left:
        :param Optional[bool] editor:
        :param Optional[bool] broadcast:
        :param Optional[bool] verified:
        :param Optional[bool] megagroup:
        :param Optional[bool] restricted:
        :param Optional[bool] democracy:
        :param Optional[bool] signatures:
        :param Optional[bool] min:
        :param Optional[int] access_hash:
        :param Optional[str] username:
        :param Optional[str] restriction_reason:
        :param Optional[TypeChannelAdminRights] admin_rights:
        :param Optional[TypeChannelBannedRights] banned_rights:
        :param Optional[int] participants_count:

        Constructor for Chat: Instance of either ChatEmpty, Chat, ChatForbidden, Channel, ChannelForbidden.
        """
        self.id = id  # type: int
        self.title = title  # type: str
        self.photo = photo  # type: TypeChatPhoto
        self.date = date  # type: Optional[datetime]
        self.version = version  # type: int
        self.creator = creator  # type: Optional[bool]
        self.left = left  # type: Optional[bool]
        self.editor = editor  # type: Optional[bool]
        self.broadcast = broadcast  # type: Optional[bool]
        self.verified = verified  # type: Optional[bool]
        self.megagroup = megagroup  # type: Optional[bool]
        self.restricted = restricted  # type: Optional[bool]
        self.democracy = democracy  # type: Optional[bool]
        self.signatures = signatures  # type: Optional[bool]
        self.min = min  # type: Optional[bool]
        self.access_hash = access_hash  # type: Optional[int]
        self.username = username  # type: Optional[str]
        self.restriction_reason = restriction_reason  # type: Optional[str]
        self.admin_rights = admin_rights  # type: Optional[TypeChannelAdminRights]
        self.banned_rights = banned_rights  # type: Optional[TypeChannelBannedRights]
        self.participants_count = participants_count  # type: Optional[int]

    def to_dict(self):
        return {
            '_': 'Channel',
            'id': self.id,
            'title': self.title,
            'photo': None if self.photo is None else self.photo.to_dict(),
            'date': self.date,
            'version': self.version,
            'creator': self.creator,
            'left': self.left,
            'editor': self.editor,
            'broadcast': self.broadcast,
            'verified': self.verified,
            'megagroup': self.megagroup,
            'restricted': self.restricted,
            'democracy': self.democracy,
            'signatures': self.signatures,
            'min': self.min,
            'access_hash': self.access_hash,
            'username': self.username,
            'restriction_reason': self.restriction_reason,
            'admin_rights': None if self.admin_rights is None else self.admin_rights.to_dict(),
            'banned_rights': None if self.banned_rights is None else self.banned_rights.to_dict(),
            'participants_count': self.participants_count
        }

    def __bytes__(self):
        assert ((self.restricted or self.restricted is not None) and (self.restriction_reason or self.restriction_reason is not None)) or ((self.restricted is None or self.restricted is False) and (self.restriction_reason is None or self.restriction_reason is False)), 'restricted, restriction_reason parameters must all be False-y (like None) or all me True-y'
        return b''.join((
            b'\xact\x89\xc8',
            struct.pack('<I', (0 if self.creator is None or self.creator is False else 1) | (0 if self.left is None or self.left is False else 4) | (0 if self.editor is None or self.editor is False else 8) | (0 if self.broadcast is None or self.broadcast is False else 32) | (0 if self.verified is None or self.verified is False else 128) | (0 if self.megagroup is None or self.megagroup is False else 256) | (0 if self.restricted is None or self.restricted is False else 512) | (0 if self.democracy is None or self.democracy is False else 1024) | (0 if self.signatures is None or self.signatures is False else 2048) | (0 if self.min is None or self.min is False else 4096) | (0 if self.access_hash is None or self.access_hash is False else 8192) | (0 if self.username is None or self.username is False else 64) | (0 if self.restriction_reason is None or self.restriction_reason is False else 512) | (0 if self.admin_rights is None or self.admin_rights is False else 16384) | (0 if self.banned_rights is None or self.banned_rights is False else 32768) | (0 if self.participants_count is None or self.participants_count is False else 131072)),
            struct.pack('<i', self.id),
            b'' if self.access_hash is None or self.access_hash is False else (struct.pack('<q', self.access_hash)),
            self.serialize_bytes(self.title),
            b'' if self.username is None or self.username is False else (self.serialize_bytes(self.username)),
            bytes(self.photo),
            self.serialize_datetime(self.date),
            struct.pack('<i', self.version),
            b'' if self.restriction_reason is None or self.restriction_reason is False else (self.serialize_bytes(self.restriction_reason)),
            b'' if self.admin_rights is None or self.admin_rights is False else (bytes(self.admin_rights)),
            b'' if self.banned_rights is None or self.banned_rights is False else (bytes(self.banned_rights)),
            b'' if self.participants_count is None or self.participants_count is False else (struct.pack('<i', self.participants_count)),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _creator = bool(flags & 1)
        _left = bool(flags & 4)
        _editor = bool(flags & 8)
        _broadcast = bool(flags & 32)
        _verified = bool(flags & 128)
        _megagroup = bool(flags & 256)
        _restricted = bool(flags & 512)
        _democracy = bool(flags & 1024)
        _signatures = bool(flags & 2048)
        _min = bool(flags & 4096)
        _id = reader.read_int()
        if flags & 8192:
            _access_hash = reader.read_long()
        else:
            _access_hash = None
        _title = reader.tgread_string()
        if flags & 64:
            _username = reader.tgread_string()
        else:
            _username = None
        _photo = reader.tgread_object()
        _date = reader.tgread_date()
        _version = reader.read_int()
        if flags & 512:
            _restriction_reason = reader.tgread_string()
        else:
            _restriction_reason = None
        if flags & 16384:
            _admin_rights = reader.tgread_object()
        else:
            _admin_rights = None
        if flags & 32768:
            _banned_rights = reader.tgread_object()
        else:
            _banned_rights = None
        if flags & 131072:
            _participants_count = reader.read_int()
        else:
            _participants_count = None
        return cls(id=_id, title=_title, photo=_photo, date=_date, version=_version, creator=_creator, left=_left, editor=_editor, broadcast=_broadcast, verified=_verified, megagroup=_megagroup, restricted=_restricted, democracy=_democracy, signatures=_signatures, min=_min, access_hash=_access_hash, username=_username, restriction_reason=_restriction_reason, admin_rights=_admin_rights, banned_rights=_banned_rights, participants_count=_participants_count)


class ChannelAdminLogEvent(TLObject):
    CONSTRUCTOR_ID = 0x3b5a3e40
    SUBCLASS_OF_ID = 0x408f0999

    def __init__(self, id, date, user_id, action):
        """
        :param int id:
        :param Optional[datetime] date:
        :param int user_id:
        :param TypeChannelAdminLogEventAction action:

        Constructor for ChannelAdminLogEvent: Instance of ChannelAdminLogEvent.
        """
        self.id = id  # type: int
        self.date = date  # type: Optional[datetime]
        self.user_id = user_id  # type: int
        self.action = action  # type: TypeChannelAdminLogEventAction

    def to_dict(self):
        return {
            '_': 'ChannelAdminLogEvent',
            'id': self.id,
            'date': self.date,
            'user_id': self.user_id,
            'action': None if self.action is None else self.action.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'@>Z;',
            struct.pack('<q', self.id),
            self.serialize_datetime(self.date),
            struct.pack('<i', self.user_id),
            bytes(self.action),
        ))

    @classmethod
    def from_reader(cls, reader):
        _id = reader.read_long()
        _date = reader.tgread_date()
        _user_id = reader.read_int()
        _action = reader.tgread_object()
        return cls(id=_id, date=_date, user_id=_user_id, action=_action)


class ChannelAdminLogEventActionChangeAbout(TLObject):
    CONSTRUCTOR_ID = 0x55188a2e
    SUBCLASS_OF_ID = 0xb2b987f3

    def __init__(self, prev_value, new_value):
        """
        :param str prev_value:
        :param str new_value:

        Constructor for ChannelAdminLogEventAction: Instance of either ChannelAdminLogEventActionChangeTitle, ChannelAdminLogEventActionChangeAbout, ChannelAdminLogEventActionChangeUsername, ChannelAdminLogEventActionChangePhoto, ChannelAdminLogEventActionToggleInvites, ChannelAdminLogEventActionToggleSignatures, ChannelAdminLogEventActionUpdatePinned, ChannelAdminLogEventActionEditMessage, ChannelAdminLogEventActionDeleteMessage, ChannelAdminLogEventActionParticipantJoin, ChannelAdminLogEventActionParticipantLeave, ChannelAdminLogEventActionParticipantInvite, ChannelAdminLogEventActionParticipantToggleBan, ChannelAdminLogEventActionParticipantToggleAdmin, ChannelAdminLogEventActionChangeStickerSet, ChannelAdminLogEventActionTogglePreHistoryHidden.
        """
        self.prev_value = prev_value  # type: str
        self.new_value = new_value  # type: str

    def to_dict(self):
        return {
            '_': 'ChannelAdminLogEventActionChangeAbout',
            'prev_value': self.prev_value,
            'new_value': self.new_value
        }

    def __bytes__(self):
        return b''.join((
            b'.\x8a\x18U',
            self.serialize_bytes(self.prev_value),
            self.serialize_bytes(self.new_value),
        ))

    @classmethod
    def from_reader(cls, reader):
        _prev_value = reader.tgread_string()
        _new_value = reader.tgread_string()
        return cls(prev_value=_prev_value, new_value=_new_value)


class ChannelAdminLogEventActionChangePhoto(TLObject):
    CONSTRUCTOR_ID = 0xb82f55c3
    SUBCLASS_OF_ID = 0xb2b987f3

    def __init__(self, prev_photo, new_photo):
        """
        :param TypeChatPhoto prev_photo:
        :param TypeChatPhoto new_photo:

        Constructor for ChannelAdminLogEventAction: Instance of either ChannelAdminLogEventActionChangeTitle, ChannelAdminLogEventActionChangeAbout, ChannelAdminLogEventActionChangeUsername, ChannelAdminLogEventActionChangePhoto, ChannelAdminLogEventActionToggleInvites, ChannelAdminLogEventActionToggleSignatures, ChannelAdminLogEventActionUpdatePinned, ChannelAdminLogEventActionEditMessage, ChannelAdminLogEventActionDeleteMessage, ChannelAdminLogEventActionParticipantJoin, ChannelAdminLogEventActionParticipantLeave, ChannelAdminLogEventActionParticipantInvite, ChannelAdminLogEventActionParticipantToggleBan, ChannelAdminLogEventActionParticipantToggleAdmin, ChannelAdminLogEventActionChangeStickerSet, ChannelAdminLogEventActionTogglePreHistoryHidden.
        """
        self.prev_photo = prev_photo  # type: TypeChatPhoto
        self.new_photo = new_photo  # type: TypeChatPhoto

    def to_dict(self):
        return {
            '_': 'ChannelAdminLogEventActionChangePhoto',
            'prev_photo': None if self.prev_photo is None else self.prev_photo.to_dict(),
            'new_photo': None if self.new_photo is None else self.new_photo.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\xc3U/\xb8',
            bytes(self.prev_photo),
            bytes(self.new_photo),
        ))

    @classmethod
    def from_reader(cls, reader):
        _prev_photo = reader.tgread_object()
        _new_photo = reader.tgread_object()
        return cls(prev_photo=_prev_photo, new_photo=_new_photo)


class ChannelAdminLogEventActionChangeStickerSet(TLObject):
    CONSTRUCTOR_ID = 0xb1c3caa7
    SUBCLASS_OF_ID = 0xb2b987f3

    def __init__(self, prev_stickerset, new_stickerset):
        """
        :param TypeInputStickerSet prev_stickerset:
        :param TypeInputStickerSet new_stickerset:

        Constructor for ChannelAdminLogEventAction: Instance of either ChannelAdminLogEventActionChangeTitle, ChannelAdminLogEventActionChangeAbout, ChannelAdminLogEventActionChangeUsername, ChannelAdminLogEventActionChangePhoto, ChannelAdminLogEventActionToggleInvites, ChannelAdminLogEventActionToggleSignatures, ChannelAdminLogEventActionUpdatePinned, ChannelAdminLogEventActionEditMessage, ChannelAdminLogEventActionDeleteMessage, ChannelAdminLogEventActionParticipantJoin, ChannelAdminLogEventActionParticipantLeave, ChannelAdminLogEventActionParticipantInvite, ChannelAdminLogEventActionParticipantToggleBan, ChannelAdminLogEventActionParticipantToggleAdmin, ChannelAdminLogEventActionChangeStickerSet, ChannelAdminLogEventActionTogglePreHistoryHidden.
        """
        self.prev_stickerset = prev_stickerset  # type: TypeInputStickerSet
        self.new_stickerset = new_stickerset  # type: TypeInputStickerSet

    def to_dict(self):
        return {
            '_': 'ChannelAdminLogEventActionChangeStickerSet',
            'prev_stickerset': None if self.prev_stickerset is None else self.prev_stickerset.to_dict(),
            'new_stickerset': None if self.new_stickerset is None else self.new_stickerset.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\xa7\xca\xc3\xb1',
            bytes(self.prev_stickerset),
            bytes(self.new_stickerset),
        ))

    @classmethod
    def from_reader(cls, reader):
        _prev_stickerset = reader.tgread_object()
        _new_stickerset = reader.tgread_object()
        return cls(prev_stickerset=_prev_stickerset, new_stickerset=_new_stickerset)


class ChannelAdminLogEventActionChangeTitle(TLObject):
    CONSTRUCTOR_ID = 0xe6dfb825
    SUBCLASS_OF_ID = 0xb2b987f3

    def __init__(self, prev_value, new_value):
        """
        :param str prev_value:
        :param str new_value:

        Constructor for ChannelAdminLogEventAction: Instance of either ChannelAdminLogEventActionChangeTitle, ChannelAdminLogEventActionChangeAbout, ChannelAdminLogEventActionChangeUsername, ChannelAdminLogEventActionChangePhoto, ChannelAdminLogEventActionToggleInvites, ChannelAdminLogEventActionToggleSignatures, ChannelAdminLogEventActionUpdatePinned, ChannelAdminLogEventActionEditMessage, ChannelAdminLogEventActionDeleteMessage, ChannelAdminLogEventActionParticipantJoin, ChannelAdminLogEventActionParticipantLeave, ChannelAdminLogEventActionParticipantInvite, ChannelAdminLogEventActionParticipantToggleBan, ChannelAdminLogEventActionParticipantToggleAdmin, ChannelAdminLogEventActionChangeStickerSet, ChannelAdminLogEventActionTogglePreHistoryHidden.
        """
        self.prev_value = prev_value  # type: str
        self.new_value = new_value  # type: str

    def to_dict(self):
        return {
            '_': 'ChannelAdminLogEventActionChangeTitle',
            'prev_value': self.prev_value,
            'new_value': self.new_value
        }

    def __bytes__(self):
        return b''.join((
            b'%\xb8\xdf\xe6',
            self.serialize_bytes(self.prev_value),
            self.serialize_bytes(self.new_value),
        ))

    @classmethod
    def from_reader(cls, reader):
        _prev_value = reader.tgread_string()
        _new_value = reader.tgread_string()
        return cls(prev_value=_prev_value, new_value=_new_value)


class ChannelAdminLogEventActionChangeUsername(TLObject):
    CONSTRUCTOR_ID = 0x6a4afc38
    SUBCLASS_OF_ID = 0xb2b987f3

    def __init__(self, prev_value, new_value):
        """
        :param str prev_value:
        :param str new_value:

        Constructor for ChannelAdminLogEventAction: Instance of either ChannelAdminLogEventActionChangeTitle, ChannelAdminLogEventActionChangeAbout, ChannelAdminLogEventActionChangeUsername, ChannelAdminLogEventActionChangePhoto, ChannelAdminLogEventActionToggleInvites, ChannelAdminLogEventActionToggleSignatures, ChannelAdminLogEventActionUpdatePinned, ChannelAdminLogEventActionEditMessage, ChannelAdminLogEventActionDeleteMessage, ChannelAdminLogEventActionParticipantJoin, ChannelAdminLogEventActionParticipantLeave, ChannelAdminLogEventActionParticipantInvite, ChannelAdminLogEventActionParticipantToggleBan, ChannelAdminLogEventActionParticipantToggleAdmin, ChannelAdminLogEventActionChangeStickerSet, ChannelAdminLogEventActionTogglePreHistoryHidden.
        """
        self.prev_value = prev_value  # type: str
        self.new_value = new_value  # type: str

    def to_dict(self):
        return {
            '_': 'ChannelAdminLogEventActionChangeUsername',
            'prev_value': self.prev_value,
            'new_value': self.new_value
        }

    def __bytes__(self):
        return b''.join((
            b'8\xfcJj',
            self.serialize_bytes(self.prev_value),
            self.serialize_bytes(self.new_value),
        ))

    @classmethod
    def from_reader(cls, reader):
        _prev_value = reader.tgread_string()
        _new_value = reader.tgread_string()
        return cls(prev_value=_prev_value, new_value=_new_value)


class ChannelAdminLogEventActionDeleteMessage(TLObject):
    CONSTRUCTOR_ID = 0x42e047bb
    SUBCLASS_OF_ID = 0xb2b987f3

    def __init__(self, message):
        """
        :param TypeMessage message:

        Constructor for ChannelAdminLogEventAction: Instance of either ChannelAdminLogEventActionChangeTitle, ChannelAdminLogEventActionChangeAbout, ChannelAdminLogEventActionChangeUsername, ChannelAdminLogEventActionChangePhoto, ChannelAdminLogEventActionToggleInvites, ChannelAdminLogEventActionToggleSignatures, ChannelAdminLogEventActionUpdatePinned, ChannelAdminLogEventActionEditMessage, ChannelAdminLogEventActionDeleteMessage, ChannelAdminLogEventActionParticipantJoin, ChannelAdminLogEventActionParticipantLeave, ChannelAdminLogEventActionParticipantInvite, ChannelAdminLogEventActionParticipantToggleBan, ChannelAdminLogEventActionParticipantToggleAdmin, ChannelAdminLogEventActionChangeStickerSet, ChannelAdminLogEventActionTogglePreHistoryHidden.
        """
        self.message = message  # type: TypeMessage

    def to_dict(self):
        return {
            '_': 'ChannelAdminLogEventActionDeleteMessage',
            'message': None if self.message is None else self.message.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\xbbG\xe0B',
            bytes(self.message),
        ))

    @classmethod
    def from_reader(cls, reader):
        _message = reader.tgread_object()
        return cls(message=_message)


class ChannelAdminLogEventActionEditMessage(TLObject):
    CONSTRUCTOR_ID = 0x709b2405
    SUBCLASS_OF_ID = 0xb2b987f3

    def __init__(self, prev_message, new_message):
        """
        :param TypeMessage prev_message:
        :param TypeMessage new_message:

        Constructor for ChannelAdminLogEventAction: Instance of either ChannelAdminLogEventActionChangeTitle, ChannelAdminLogEventActionChangeAbout, ChannelAdminLogEventActionChangeUsername, ChannelAdminLogEventActionChangePhoto, ChannelAdminLogEventActionToggleInvites, ChannelAdminLogEventActionToggleSignatures, ChannelAdminLogEventActionUpdatePinned, ChannelAdminLogEventActionEditMessage, ChannelAdminLogEventActionDeleteMessage, ChannelAdminLogEventActionParticipantJoin, ChannelAdminLogEventActionParticipantLeave, ChannelAdminLogEventActionParticipantInvite, ChannelAdminLogEventActionParticipantToggleBan, ChannelAdminLogEventActionParticipantToggleAdmin, ChannelAdminLogEventActionChangeStickerSet, ChannelAdminLogEventActionTogglePreHistoryHidden.
        """
        self.prev_message = prev_message  # type: TypeMessage
        self.new_message = new_message  # type: TypeMessage

    def to_dict(self):
        return {
            '_': 'ChannelAdminLogEventActionEditMessage',
            'prev_message': None if self.prev_message is None else self.prev_message.to_dict(),
            'new_message': None if self.new_message is None else self.new_message.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\x05$\x9bp',
            bytes(self.prev_message),
            bytes(self.new_message),
        ))

    @classmethod
    def from_reader(cls, reader):
        _prev_message = reader.tgread_object()
        _new_message = reader.tgread_object()
        return cls(prev_message=_prev_message, new_message=_new_message)


class ChannelAdminLogEventActionParticipantInvite(TLObject):
    CONSTRUCTOR_ID = 0xe31c34d8
    SUBCLASS_OF_ID = 0xb2b987f3

    def __init__(self, participant):
        """
        :param TypeChannelParticipant participant:

        Constructor for ChannelAdminLogEventAction: Instance of either ChannelAdminLogEventActionChangeTitle, ChannelAdminLogEventActionChangeAbout, ChannelAdminLogEventActionChangeUsername, ChannelAdminLogEventActionChangePhoto, ChannelAdminLogEventActionToggleInvites, ChannelAdminLogEventActionToggleSignatures, ChannelAdminLogEventActionUpdatePinned, ChannelAdminLogEventActionEditMessage, ChannelAdminLogEventActionDeleteMessage, ChannelAdminLogEventActionParticipantJoin, ChannelAdminLogEventActionParticipantLeave, ChannelAdminLogEventActionParticipantInvite, ChannelAdminLogEventActionParticipantToggleBan, ChannelAdminLogEventActionParticipantToggleAdmin, ChannelAdminLogEventActionChangeStickerSet, ChannelAdminLogEventActionTogglePreHistoryHidden.
        """
        self.participant = participant  # type: TypeChannelParticipant

    def to_dict(self):
        return {
            '_': 'ChannelAdminLogEventActionParticipantInvite',
            'participant': None if self.participant is None else self.participant.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\xd84\x1c\xe3',
            bytes(self.participant),
        ))

    @classmethod
    def from_reader(cls, reader):
        _participant = reader.tgread_object()
        return cls(participant=_participant)


class ChannelAdminLogEventActionParticipantJoin(TLObject):
    CONSTRUCTOR_ID = 0x183040d3
    SUBCLASS_OF_ID = 0xb2b987f3

    def to_dict(self):
        return {
            '_': 'ChannelAdminLogEventActionParticipantJoin'
        }

    def __bytes__(self):
        return b''.join((
            b'\xd3@0\x18',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class ChannelAdminLogEventActionParticipantLeave(TLObject):
    CONSTRUCTOR_ID = 0xf89777f2
    SUBCLASS_OF_ID = 0xb2b987f3

    def to_dict(self):
        return {
            '_': 'ChannelAdminLogEventActionParticipantLeave'
        }

    def __bytes__(self):
        return b''.join((
            b'\xf2w\x97\xf8',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class ChannelAdminLogEventActionParticipantToggleAdmin(TLObject):
    CONSTRUCTOR_ID = 0xd5676710
    SUBCLASS_OF_ID = 0xb2b987f3

    def __init__(self, prev_participant, new_participant):
        """
        :param TypeChannelParticipant prev_participant:
        :param TypeChannelParticipant new_participant:

        Constructor for ChannelAdminLogEventAction: Instance of either ChannelAdminLogEventActionChangeTitle, ChannelAdminLogEventActionChangeAbout, ChannelAdminLogEventActionChangeUsername, ChannelAdminLogEventActionChangePhoto, ChannelAdminLogEventActionToggleInvites, ChannelAdminLogEventActionToggleSignatures, ChannelAdminLogEventActionUpdatePinned, ChannelAdminLogEventActionEditMessage, ChannelAdminLogEventActionDeleteMessage, ChannelAdminLogEventActionParticipantJoin, ChannelAdminLogEventActionParticipantLeave, ChannelAdminLogEventActionParticipantInvite, ChannelAdminLogEventActionParticipantToggleBan, ChannelAdminLogEventActionParticipantToggleAdmin, ChannelAdminLogEventActionChangeStickerSet, ChannelAdminLogEventActionTogglePreHistoryHidden.
        """
        self.prev_participant = prev_participant  # type: TypeChannelParticipant
        self.new_participant = new_participant  # type: TypeChannelParticipant

    def to_dict(self):
        return {
            '_': 'ChannelAdminLogEventActionParticipantToggleAdmin',
            'prev_participant': None if self.prev_participant is None else self.prev_participant.to_dict(),
            'new_participant': None if self.new_participant is None else self.new_participant.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\x10gg\xd5',
            bytes(self.prev_participant),
            bytes(self.new_participant),
        ))

    @classmethod
    def from_reader(cls, reader):
        _prev_participant = reader.tgread_object()
        _new_participant = reader.tgread_object()
        return cls(prev_participant=_prev_participant, new_participant=_new_participant)


class ChannelAdminLogEventActionParticipantToggleBan(TLObject):
    CONSTRUCTOR_ID = 0xe6d83d7e
    SUBCLASS_OF_ID = 0xb2b987f3

    def __init__(self, prev_participant, new_participant):
        """
        :param TypeChannelParticipant prev_participant:
        :param TypeChannelParticipant new_participant:

        Constructor for ChannelAdminLogEventAction: Instance of either ChannelAdminLogEventActionChangeTitle, ChannelAdminLogEventActionChangeAbout, ChannelAdminLogEventActionChangeUsername, ChannelAdminLogEventActionChangePhoto, ChannelAdminLogEventActionToggleInvites, ChannelAdminLogEventActionToggleSignatures, ChannelAdminLogEventActionUpdatePinned, ChannelAdminLogEventActionEditMessage, ChannelAdminLogEventActionDeleteMessage, ChannelAdminLogEventActionParticipantJoin, ChannelAdminLogEventActionParticipantLeave, ChannelAdminLogEventActionParticipantInvite, ChannelAdminLogEventActionParticipantToggleBan, ChannelAdminLogEventActionParticipantToggleAdmin, ChannelAdminLogEventActionChangeStickerSet, ChannelAdminLogEventActionTogglePreHistoryHidden.
        """
        self.prev_participant = prev_participant  # type: TypeChannelParticipant
        self.new_participant = new_participant  # type: TypeChannelParticipant

    def to_dict(self):
        return {
            '_': 'ChannelAdminLogEventActionParticipantToggleBan',
            'prev_participant': None if self.prev_participant is None else self.prev_participant.to_dict(),
            'new_participant': None if self.new_participant is None else self.new_participant.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'~=\xd8\xe6',
            bytes(self.prev_participant),
            bytes(self.new_participant),
        ))

    @classmethod
    def from_reader(cls, reader):
        _prev_participant = reader.tgread_object()
        _new_participant = reader.tgread_object()
        return cls(prev_participant=_prev_participant, new_participant=_new_participant)


class ChannelAdminLogEventActionToggleInvites(TLObject):
    CONSTRUCTOR_ID = 0x1b7907ae
    SUBCLASS_OF_ID = 0xb2b987f3

    def __init__(self, new_value):
        """
        :param TypeBool new_value:

        Constructor for ChannelAdminLogEventAction: Instance of either ChannelAdminLogEventActionChangeTitle, ChannelAdminLogEventActionChangeAbout, ChannelAdminLogEventActionChangeUsername, ChannelAdminLogEventActionChangePhoto, ChannelAdminLogEventActionToggleInvites, ChannelAdminLogEventActionToggleSignatures, ChannelAdminLogEventActionUpdatePinned, ChannelAdminLogEventActionEditMessage, ChannelAdminLogEventActionDeleteMessage, ChannelAdminLogEventActionParticipantJoin, ChannelAdminLogEventActionParticipantLeave, ChannelAdminLogEventActionParticipantInvite, ChannelAdminLogEventActionParticipantToggleBan, ChannelAdminLogEventActionParticipantToggleAdmin, ChannelAdminLogEventActionChangeStickerSet, ChannelAdminLogEventActionTogglePreHistoryHidden.
        """
        self.new_value = new_value  # type: TypeBool

    def to_dict(self):
        return {
            '_': 'ChannelAdminLogEventActionToggleInvites',
            'new_value': self.new_value
        }

    def __bytes__(self):
        return b''.join((
            b'\xae\x07y\x1b',
            b'\xb5ur\x99' if self.new_value else b'7\x97y\xbc',
        ))

    @classmethod
    def from_reader(cls, reader):
        _new_value = reader.tgread_bool()
        return cls(new_value=_new_value)


class ChannelAdminLogEventActionTogglePreHistoryHidden(TLObject):
    CONSTRUCTOR_ID = 0x5f5c95f1
    SUBCLASS_OF_ID = 0xb2b987f3

    def __init__(self, new_value):
        """
        :param TypeBool new_value:

        Constructor for ChannelAdminLogEventAction: Instance of either ChannelAdminLogEventActionChangeTitle, ChannelAdminLogEventActionChangeAbout, ChannelAdminLogEventActionChangeUsername, ChannelAdminLogEventActionChangePhoto, ChannelAdminLogEventActionToggleInvites, ChannelAdminLogEventActionToggleSignatures, ChannelAdminLogEventActionUpdatePinned, ChannelAdminLogEventActionEditMessage, ChannelAdminLogEventActionDeleteMessage, ChannelAdminLogEventActionParticipantJoin, ChannelAdminLogEventActionParticipantLeave, ChannelAdminLogEventActionParticipantInvite, ChannelAdminLogEventActionParticipantToggleBan, ChannelAdminLogEventActionParticipantToggleAdmin, ChannelAdminLogEventActionChangeStickerSet, ChannelAdminLogEventActionTogglePreHistoryHidden.
        """
        self.new_value = new_value  # type: TypeBool

    def to_dict(self):
        return {
            '_': 'ChannelAdminLogEventActionTogglePreHistoryHidden',
            'new_value': self.new_value
        }

    def __bytes__(self):
        return b''.join((
            b'\xf1\x95\\_',
            b'\xb5ur\x99' if self.new_value else b'7\x97y\xbc',
        ))

    @classmethod
    def from_reader(cls, reader):
        _new_value = reader.tgread_bool()
        return cls(new_value=_new_value)


class ChannelAdminLogEventActionToggleSignatures(TLObject):
    CONSTRUCTOR_ID = 0x26ae0971
    SUBCLASS_OF_ID = 0xb2b987f3

    def __init__(self, new_value):
        """
        :param TypeBool new_value:

        Constructor for ChannelAdminLogEventAction: Instance of either ChannelAdminLogEventActionChangeTitle, ChannelAdminLogEventActionChangeAbout, ChannelAdminLogEventActionChangeUsername, ChannelAdminLogEventActionChangePhoto, ChannelAdminLogEventActionToggleInvites, ChannelAdminLogEventActionToggleSignatures, ChannelAdminLogEventActionUpdatePinned, ChannelAdminLogEventActionEditMessage, ChannelAdminLogEventActionDeleteMessage, ChannelAdminLogEventActionParticipantJoin, ChannelAdminLogEventActionParticipantLeave, ChannelAdminLogEventActionParticipantInvite, ChannelAdminLogEventActionParticipantToggleBan, ChannelAdminLogEventActionParticipantToggleAdmin, ChannelAdminLogEventActionChangeStickerSet, ChannelAdminLogEventActionTogglePreHistoryHidden.
        """
        self.new_value = new_value  # type: TypeBool

    def to_dict(self):
        return {
            '_': 'ChannelAdminLogEventActionToggleSignatures',
            'new_value': self.new_value
        }

    def __bytes__(self):
        return b''.join((
            b'q\t\xae&',
            b'\xb5ur\x99' if self.new_value else b'7\x97y\xbc',
        ))

    @classmethod
    def from_reader(cls, reader):
        _new_value = reader.tgread_bool()
        return cls(new_value=_new_value)


class ChannelAdminLogEventActionUpdatePinned(TLObject):
    CONSTRUCTOR_ID = 0xe9e82c18
    SUBCLASS_OF_ID = 0xb2b987f3

    def __init__(self, message):
        """
        :param TypeMessage message:

        Constructor for ChannelAdminLogEventAction: Instance of either ChannelAdminLogEventActionChangeTitle, ChannelAdminLogEventActionChangeAbout, ChannelAdminLogEventActionChangeUsername, ChannelAdminLogEventActionChangePhoto, ChannelAdminLogEventActionToggleInvites, ChannelAdminLogEventActionToggleSignatures, ChannelAdminLogEventActionUpdatePinned, ChannelAdminLogEventActionEditMessage, ChannelAdminLogEventActionDeleteMessage, ChannelAdminLogEventActionParticipantJoin, ChannelAdminLogEventActionParticipantLeave, ChannelAdminLogEventActionParticipantInvite, ChannelAdminLogEventActionParticipantToggleBan, ChannelAdminLogEventActionParticipantToggleAdmin, ChannelAdminLogEventActionChangeStickerSet, ChannelAdminLogEventActionTogglePreHistoryHidden.
        """
        self.message = message  # type: TypeMessage

    def to_dict(self):
        return {
            '_': 'ChannelAdminLogEventActionUpdatePinned',
            'message': None if self.message is None else self.message.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\x18,\xe8\xe9',
            bytes(self.message),
        ))

    @classmethod
    def from_reader(cls, reader):
        _message = reader.tgread_object()
        return cls(message=_message)


class ChannelAdminLogEventsFilter(TLObject):
    CONSTRUCTOR_ID = 0xea107ae4
    SUBCLASS_OF_ID = 0x7cbbf319

    def __init__(self, join=None, leave=None, invite=None, ban=None, unban=None, kick=None, unkick=None, promote=None, demote=None, info=None, settings=None, pinned=None, edit=None, delete=None):
        """
        :param Optional[bool] join:
        :param Optional[bool] leave:
        :param Optional[bool] invite:
        :param Optional[bool] ban:
        :param Optional[bool] unban:
        :param Optional[bool] kick:
        :param Optional[bool] unkick:
        :param Optional[bool] promote:
        :param Optional[bool] demote:
        :param Optional[bool] info:
        :param Optional[bool] settings:
        :param Optional[bool] pinned:
        :param Optional[bool] edit:
        :param Optional[bool] delete:

        Constructor for ChannelAdminLogEventsFilter: Instance of ChannelAdminLogEventsFilter.
        """
        self.join = join  # type: Optional[bool]
        self.leave = leave  # type: Optional[bool]
        self.invite = invite  # type: Optional[bool]
        self.ban = ban  # type: Optional[bool]
        self.unban = unban  # type: Optional[bool]
        self.kick = kick  # type: Optional[bool]
        self.unkick = unkick  # type: Optional[bool]
        self.promote = promote  # type: Optional[bool]
        self.demote = demote  # type: Optional[bool]
        self.info = info  # type: Optional[bool]
        self.settings = settings  # type: Optional[bool]
        self.pinned = pinned  # type: Optional[bool]
        self.edit = edit  # type: Optional[bool]
        self.delete = delete  # type: Optional[bool]

    def to_dict(self):
        return {
            '_': 'ChannelAdminLogEventsFilter',
            'join': self.join,
            'leave': self.leave,
            'invite': self.invite,
            'ban': self.ban,
            'unban': self.unban,
            'kick': self.kick,
            'unkick': self.unkick,
            'promote': self.promote,
            'demote': self.demote,
            'info': self.info,
            'settings': self.settings,
            'pinned': self.pinned,
            'edit': self.edit,
            'delete': self.delete
        }

    def __bytes__(self):
        return b''.join((
            b'\xe4z\x10\xea',
            struct.pack('<I', (0 if self.join is None or self.join is False else 1) | (0 if self.leave is None or self.leave is False else 2) | (0 if self.invite is None or self.invite is False else 4) | (0 if self.ban is None or self.ban is False else 8) | (0 if self.unban is None or self.unban is False else 16) | (0 if self.kick is None or self.kick is False else 32) | (0 if self.unkick is None or self.unkick is False else 64) | (0 if self.promote is None or self.promote is False else 128) | (0 if self.demote is None or self.demote is False else 256) | (0 if self.info is None or self.info is False else 512) | (0 if self.settings is None or self.settings is False else 1024) | (0 if self.pinned is None or self.pinned is False else 2048) | (0 if self.edit is None or self.edit is False else 4096) | (0 if self.delete is None or self.delete is False else 8192)),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _join = bool(flags & 1)
        _leave = bool(flags & 2)
        _invite = bool(flags & 4)
        _ban = bool(flags & 8)
        _unban = bool(flags & 16)
        _kick = bool(flags & 32)
        _unkick = bool(flags & 64)
        _promote = bool(flags & 128)
        _demote = bool(flags & 256)
        _info = bool(flags & 512)
        _settings = bool(flags & 1024)
        _pinned = bool(flags & 2048)
        _edit = bool(flags & 4096)
        _delete = bool(flags & 8192)
        return cls(join=_join, leave=_leave, invite=_invite, ban=_ban, unban=_unban, kick=_kick, unkick=_unkick, promote=_promote, demote=_demote, info=_info, settings=_settings, pinned=_pinned, edit=_edit, delete=_delete)


class ChannelAdminRights(TLObject):
    CONSTRUCTOR_ID = 0x5d7ceba5
    SUBCLASS_OF_ID = 0x2286545a

    def __init__(self, change_info=None, post_messages=None, edit_messages=None, delete_messages=None, ban_users=None, invite_users=None, invite_link=None, pin_messages=None, add_admins=None, manage_call=None):
        """
        :param Optional[bool] change_info:
        :param Optional[bool] post_messages:
        :param Optional[bool] edit_messages:
        :param Optional[bool] delete_messages:
        :param Optional[bool] ban_users:
        :param Optional[bool] invite_users:
        :param Optional[bool] invite_link:
        :param Optional[bool] pin_messages:
        :param Optional[bool] add_admins:
        :param Optional[bool] manage_call:

        Constructor for ChannelAdminRights: Instance of ChannelAdminRights.
        """
        self.change_info = change_info  # type: Optional[bool]
        self.post_messages = post_messages  # type: Optional[bool]
        self.edit_messages = edit_messages  # type: Optional[bool]
        self.delete_messages = delete_messages  # type: Optional[bool]
        self.ban_users = ban_users  # type: Optional[bool]
        self.invite_users = invite_users  # type: Optional[bool]
        self.invite_link = invite_link  # type: Optional[bool]
        self.pin_messages = pin_messages  # type: Optional[bool]
        self.add_admins = add_admins  # type: Optional[bool]
        self.manage_call = manage_call  # type: Optional[bool]

    def to_dict(self):
        return {
            '_': 'ChannelAdminRights',
            'change_info': self.change_info,
            'post_messages': self.post_messages,
            'edit_messages': self.edit_messages,
            'delete_messages': self.delete_messages,
            'ban_users': self.ban_users,
            'invite_users': self.invite_users,
            'invite_link': self.invite_link,
            'pin_messages': self.pin_messages,
            'add_admins': self.add_admins,
            'manage_call': self.manage_call
        }

    def __bytes__(self):
        return b''.join((
            b'\xa5\xeb|]',
            struct.pack('<I', (0 if self.change_info is None or self.change_info is False else 1) | (0 if self.post_messages is None or self.post_messages is False else 2) | (0 if self.edit_messages is None or self.edit_messages is False else 4) | (0 if self.delete_messages is None or self.delete_messages is False else 8) | (0 if self.ban_users is None or self.ban_users is False else 16) | (0 if self.invite_users is None or self.invite_users is False else 32) | (0 if self.invite_link is None or self.invite_link is False else 64) | (0 if self.pin_messages is None or self.pin_messages is False else 128) | (0 if self.add_admins is None or self.add_admins is False else 512) | (0 if self.manage_call is None or self.manage_call is False else 1024)),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _change_info = bool(flags & 1)
        _post_messages = bool(flags & 2)
        _edit_messages = bool(flags & 4)
        _delete_messages = bool(flags & 8)
        _ban_users = bool(flags & 16)
        _invite_users = bool(flags & 32)
        _invite_link = bool(flags & 64)
        _pin_messages = bool(flags & 128)
        _add_admins = bool(flags & 512)
        _manage_call = bool(flags & 1024)
        return cls(change_info=_change_info, post_messages=_post_messages, edit_messages=_edit_messages, delete_messages=_delete_messages, ban_users=_ban_users, invite_users=_invite_users, invite_link=_invite_link, pin_messages=_pin_messages, add_admins=_add_admins, manage_call=_manage_call)


class ChannelBannedRights(TLObject):
    CONSTRUCTOR_ID = 0x58cf4249
    SUBCLASS_OF_ID = 0x5c474079

    def __init__(self, until_date, view_messages=None, send_messages=None, send_media=None, send_stickers=None, send_gifs=None, send_games=None, send_inline=None, embed_links=None):
        """
        :param Optional[datetime] until_date:
        :param Optional[bool] view_messages:
        :param Optional[bool] send_messages:
        :param Optional[bool] send_media:
        :param Optional[bool] send_stickers:
        :param Optional[bool] send_gifs:
        :param Optional[bool] send_games:
        :param Optional[bool] send_inline:
        :param Optional[bool] embed_links:

        Constructor for ChannelBannedRights: Instance of ChannelBannedRights.
        """
        self.until_date = until_date  # type: Optional[datetime]
        self.view_messages = view_messages  # type: Optional[bool]
        self.send_messages = send_messages  # type: Optional[bool]
        self.send_media = send_media  # type: Optional[bool]
        self.send_stickers = send_stickers  # type: Optional[bool]
        self.send_gifs = send_gifs  # type: Optional[bool]
        self.send_games = send_games  # type: Optional[bool]
        self.send_inline = send_inline  # type: Optional[bool]
        self.embed_links = embed_links  # type: Optional[bool]

    def to_dict(self):
        return {
            '_': 'ChannelBannedRights',
            'until_date': self.until_date,
            'view_messages': self.view_messages,
            'send_messages': self.send_messages,
            'send_media': self.send_media,
            'send_stickers': self.send_stickers,
            'send_gifs': self.send_gifs,
            'send_games': self.send_games,
            'send_inline': self.send_inline,
            'embed_links': self.embed_links
        }

    def __bytes__(self):
        return b''.join((
            b'IB\xcfX',
            struct.pack('<I', (0 if self.view_messages is None or self.view_messages is False else 1) | (0 if self.send_messages is None or self.send_messages is False else 2) | (0 if self.send_media is None or self.send_media is False else 4) | (0 if self.send_stickers is None or self.send_stickers is False else 8) | (0 if self.send_gifs is None or self.send_gifs is False else 16) | (0 if self.send_games is None or self.send_games is False else 32) | (0 if self.send_inline is None or self.send_inline is False else 64) | (0 if self.embed_links is None or self.embed_links is False else 128)),
            self.serialize_datetime(self.until_date),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _view_messages = bool(flags & 1)
        _send_messages = bool(flags & 2)
        _send_media = bool(flags & 4)
        _send_stickers = bool(flags & 8)
        _send_gifs = bool(flags & 16)
        _send_games = bool(flags & 32)
        _send_inline = bool(flags & 64)
        _embed_links = bool(flags & 128)
        _until_date = reader.tgread_date()
        return cls(until_date=_until_date, view_messages=_view_messages, send_messages=_send_messages, send_media=_send_media, send_stickers=_send_stickers, send_gifs=_send_gifs, send_games=_send_games, send_inline=_send_inline, embed_links=_embed_links)


class ChannelForbidden(TLObject):
    CONSTRUCTOR_ID = 0x289da732
    SUBCLASS_OF_ID = 0xc5af5d94

    def __init__(self, id, access_hash, title, broadcast=None, megagroup=None, until_date=None):
        """
        :param int id:
        :param int access_hash:
        :param str title:
        :param Optional[bool] broadcast:
        :param Optional[bool] megagroup:
        :param Optional[datetime] until_date:

        Constructor for Chat: Instance of either ChatEmpty, Chat, ChatForbidden, Channel, ChannelForbidden.
        """
        self.id = id  # type: int
        self.access_hash = access_hash  # type: int
        self.title = title  # type: str
        self.broadcast = broadcast  # type: Optional[bool]
        self.megagroup = megagroup  # type: Optional[bool]
        self.until_date = until_date  # type: Optional[datetime]

    def to_dict(self):
        return {
            '_': 'ChannelForbidden',
            'id': self.id,
            'access_hash': self.access_hash,
            'title': self.title,
            'broadcast': self.broadcast,
            'megagroup': self.megagroup,
            'until_date': self.until_date
        }

    def __bytes__(self):
        return b''.join((
            b'2\xa7\x9d(',
            struct.pack('<I', (0 if self.broadcast is None or self.broadcast is False else 32) | (0 if self.megagroup is None or self.megagroup is False else 256) | (0 if self.until_date is None or self.until_date is False else 65536)),
            struct.pack('<i', self.id),
            struct.pack('<q', self.access_hash),
            self.serialize_bytes(self.title),
            b'' if self.until_date is None or self.until_date is False else (self.serialize_datetime(self.until_date)),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _broadcast = bool(flags & 32)
        _megagroup = bool(flags & 256)
        _id = reader.read_int()
        _access_hash = reader.read_long()
        _title = reader.tgread_string()
        if flags & 65536:
            _until_date = reader.tgread_date()
        else:
            _until_date = None
        return cls(id=_id, access_hash=_access_hash, title=_title, broadcast=_broadcast, megagroup=_megagroup, until_date=_until_date)


class ChannelFull(TLObject):
    CONSTRUCTOR_ID = 0x76af5481
    SUBCLASS_OF_ID = 0xd49a2697

    def __init__(self, id, about, read_inbox_max_id, read_outbox_max_id, unread_count, chat_photo, notify_settings, exported_invite, bot_info, can_view_participants=None, can_set_username=None, can_set_stickers=None, hidden_prehistory=None, participants_count=None, admins_count=None, kicked_count=None, banned_count=None, migrated_from_chat_id=None, migrated_from_max_id=None, pinned_msg_id=None, stickerset=None, available_min_id=None):
        """
        :param int id:
        :param str about:
        :param int read_inbox_max_id:
        :param int read_outbox_max_id:
        :param int unread_count:
        :param TypePhoto chat_photo:
        :param TypePeerNotifySettings notify_settings:
        :param TypeExportedChatInvite exported_invite:
        :param List[TypeBotInfo] bot_info:
        :param Optional[bool] can_view_participants:
        :param Optional[bool] can_set_username:
        :param Optional[bool] can_set_stickers:
        :param Optional[bool] hidden_prehistory:
        :param Optional[int] participants_count:
        :param Optional[int] admins_count:
        :param Optional[int] kicked_count:
        :param Optional[int] banned_count:
        :param Optional[int] migrated_from_chat_id:
        :param Optional[int] migrated_from_max_id:
        :param Optional[int] pinned_msg_id:
        :param Optional[TypeStickerSet] stickerset:
        :param Optional[int] available_min_id:

        Constructor for ChatFull: Instance of either ChatFull, ChannelFull.
        """
        self.id = id  # type: int
        self.about = about  # type: str
        self.read_inbox_max_id = read_inbox_max_id  # type: int
        self.read_outbox_max_id = read_outbox_max_id  # type: int
        self.unread_count = unread_count  # type: int
        self.chat_photo = chat_photo  # type: TypePhoto
        self.notify_settings = notify_settings  # type: TypePeerNotifySettings
        self.exported_invite = exported_invite  # type: TypeExportedChatInvite
        self.bot_info = bot_info  # type: List[TypeBotInfo]
        self.can_view_participants = can_view_participants  # type: Optional[bool]
        self.can_set_username = can_set_username  # type: Optional[bool]
        self.can_set_stickers = can_set_stickers  # type: Optional[bool]
        self.hidden_prehistory = hidden_prehistory  # type: Optional[bool]
        self.participants_count = participants_count  # type: Optional[int]
        self.admins_count = admins_count  # type: Optional[int]
        self.kicked_count = kicked_count  # type: Optional[int]
        self.banned_count = banned_count  # type: Optional[int]
        self.migrated_from_chat_id = migrated_from_chat_id  # type: Optional[int]
        self.migrated_from_max_id = migrated_from_max_id  # type: Optional[int]
        self.pinned_msg_id = pinned_msg_id  # type: Optional[int]
        self.stickerset = stickerset  # type: Optional[TypeStickerSet]
        self.available_min_id = available_min_id  # type: Optional[int]

    def to_dict(self):
        return {
            '_': 'ChannelFull',
            'id': self.id,
            'about': self.about,
            'read_inbox_max_id': self.read_inbox_max_id,
            'read_outbox_max_id': self.read_outbox_max_id,
            'unread_count': self.unread_count,
            'chat_photo': None if self.chat_photo is None else self.chat_photo.to_dict(),
            'notify_settings': None if self.notify_settings is None else self.notify_settings.to_dict(),
            'exported_invite': None if self.exported_invite is None else self.exported_invite.to_dict(),
            'bot_info': [] if self.bot_info is None else [None if x is None else x.to_dict() for x in self.bot_info],
            'can_view_participants': self.can_view_participants,
            'can_set_username': self.can_set_username,
            'can_set_stickers': self.can_set_stickers,
            'hidden_prehistory': self.hidden_prehistory,
            'participants_count': self.participants_count,
            'admins_count': self.admins_count,
            'kicked_count': self.kicked_count,
            'banned_count': self.banned_count,
            'migrated_from_chat_id': self.migrated_from_chat_id,
            'migrated_from_max_id': self.migrated_from_max_id,
            'pinned_msg_id': self.pinned_msg_id,
            'stickerset': None if self.stickerset is None else self.stickerset.to_dict(),
            'available_min_id': self.available_min_id
        }

    def __bytes__(self):
        assert ((self.kicked_count or self.kicked_count is not None) and (self.banned_count or self.banned_count is not None)) or ((self.kicked_count is None or self.kicked_count is False) and (self.banned_count is None or self.banned_count is False)), 'kicked_count, banned_count parameters must all be False-y (like None) or all me True-y'
        assert ((self.migrated_from_chat_id or self.migrated_from_chat_id is not None) and (self.migrated_from_max_id or self.migrated_from_max_id is not None)) or ((self.migrated_from_chat_id is None or self.migrated_from_chat_id is False) and (self.migrated_from_max_id is None or self.migrated_from_max_id is False)), 'migrated_from_chat_id, migrated_from_max_id parameters must all be False-y (like None) or all me True-y'
        return b''.join((
            b'\x81T\xafv',
            struct.pack('<I', (0 if self.can_view_participants is None or self.can_view_participants is False else 8) | (0 if self.can_set_username is None or self.can_set_username is False else 64) | (0 if self.can_set_stickers is None or self.can_set_stickers is False else 128) | (0 if self.hidden_prehistory is None or self.hidden_prehistory is False else 1024) | (0 if self.participants_count is None or self.participants_count is False else 1) | (0 if self.admins_count is None or self.admins_count is False else 2) | (0 if self.kicked_count is None or self.kicked_count is False else 4) | (0 if self.banned_count is None or self.banned_count is False else 4) | (0 if self.migrated_from_chat_id is None or self.migrated_from_chat_id is False else 16) | (0 if self.migrated_from_max_id is None or self.migrated_from_max_id is False else 16) | (0 if self.pinned_msg_id is None or self.pinned_msg_id is False else 32) | (0 if self.stickerset is None or self.stickerset is False else 256) | (0 if self.available_min_id is None or self.available_min_id is False else 512)),
            struct.pack('<i', self.id),
            self.serialize_bytes(self.about),
            b'' if self.participants_count is None or self.participants_count is False else (struct.pack('<i', self.participants_count)),
            b'' if self.admins_count is None or self.admins_count is False else (struct.pack('<i', self.admins_count)),
            b'' if self.kicked_count is None or self.kicked_count is False else (struct.pack('<i', self.kicked_count)),
            b'' if self.banned_count is None or self.banned_count is False else (struct.pack('<i', self.banned_count)),
            struct.pack('<i', self.read_inbox_max_id),
            struct.pack('<i', self.read_outbox_max_id),
            struct.pack('<i', self.unread_count),
            bytes(self.chat_photo),
            bytes(self.notify_settings),
            bytes(self.exported_invite),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.bot_info)),b''.join(bytes(x) for x in self.bot_info),
            b'' if self.migrated_from_chat_id is None or self.migrated_from_chat_id is False else (struct.pack('<i', self.migrated_from_chat_id)),
            b'' if self.migrated_from_max_id is None or self.migrated_from_max_id is False else (struct.pack('<i', self.migrated_from_max_id)),
            b'' if self.pinned_msg_id is None or self.pinned_msg_id is False else (struct.pack('<i', self.pinned_msg_id)),
            b'' if self.stickerset is None or self.stickerset is False else (bytes(self.stickerset)),
            b'' if self.available_min_id is None or self.available_min_id is False else (struct.pack('<i', self.available_min_id)),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _can_view_participants = bool(flags & 8)
        _can_set_username = bool(flags & 64)
        _can_set_stickers = bool(flags & 128)
        _hidden_prehistory = bool(flags & 1024)
        _id = reader.read_int()
        _about = reader.tgread_string()
        if flags & 1:
            _participants_count = reader.read_int()
        else:
            _participants_count = None
        if flags & 2:
            _admins_count = reader.read_int()
        else:
            _admins_count = None
        if flags & 4:
            _kicked_count = reader.read_int()
        else:
            _kicked_count = None
        if flags & 4:
            _banned_count = reader.read_int()
        else:
            _banned_count = None
        _read_inbox_max_id = reader.read_int()
        _read_outbox_max_id = reader.read_int()
        _unread_count = reader.read_int()
        _chat_photo = reader.tgread_object()
        _notify_settings = reader.tgread_object()
        _exported_invite = reader.tgread_object()
        reader.read_int()
        _bot_info = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _bot_info.append(_x)

        if flags & 16:
            _migrated_from_chat_id = reader.read_int()
        else:
            _migrated_from_chat_id = None
        if flags & 16:
            _migrated_from_max_id = reader.read_int()
        else:
            _migrated_from_max_id = None
        if flags & 32:
            _pinned_msg_id = reader.read_int()
        else:
            _pinned_msg_id = None
        if flags & 256:
            _stickerset = reader.tgread_object()
        else:
            _stickerset = None
        if flags & 512:
            _available_min_id = reader.read_int()
        else:
            _available_min_id = None
        return cls(id=_id, about=_about, read_inbox_max_id=_read_inbox_max_id, read_outbox_max_id=_read_outbox_max_id, unread_count=_unread_count, chat_photo=_chat_photo, notify_settings=_notify_settings, exported_invite=_exported_invite, bot_info=_bot_info, can_view_participants=_can_view_participants, can_set_username=_can_set_username, can_set_stickers=_can_set_stickers, hidden_prehistory=_hidden_prehistory, participants_count=_participants_count, admins_count=_admins_count, kicked_count=_kicked_count, banned_count=_banned_count, migrated_from_chat_id=_migrated_from_chat_id, migrated_from_max_id=_migrated_from_max_id, pinned_msg_id=_pinned_msg_id, stickerset=_stickerset, available_min_id=_available_min_id)


class ChannelMessagesFilter(TLObject):
    CONSTRUCTOR_ID = 0xcd77d957
    SUBCLASS_OF_ID = 0x13336a56

    def __init__(self, ranges, exclude_new_messages=None):
        """
        :param List[TypeMessageRange] ranges:
        :param Optional[bool] exclude_new_messages:

        Constructor for ChannelMessagesFilter: Instance of either ChannelMessagesFilterEmpty, ChannelMessagesFilter.
        """
        self.ranges = ranges  # type: List[TypeMessageRange]
        self.exclude_new_messages = exclude_new_messages  # type: Optional[bool]

    def to_dict(self):
        return {
            '_': 'ChannelMessagesFilter',
            'ranges': [] if self.ranges is None else [None if x is None else x.to_dict() for x in self.ranges],
            'exclude_new_messages': self.exclude_new_messages
        }

    def __bytes__(self):
        return b''.join((
            b'W\xd9w\xcd',
            struct.pack('<I', (0 if self.exclude_new_messages is None or self.exclude_new_messages is False else 2)),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.ranges)),b''.join(bytes(x) for x in self.ranges),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _exclude_new_messages = bool(flags & 2)
        reader.read_int()
        _ranges = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _ranges.append(_x)

        return cls(ranges=_ranges, exclude_new_messages=_exclude_new_messages)


class ChannelMessagesFilterEmpty(TLObject):
    CONSTRUCTOR_ID = 0x94d42ee7
    SUBCLASS_OF_ID = 0x13336a56

    def to_dict(self):
        return {
            '_': 'ChannelMessagesFilterEmpty'
        }

    def __bytes__(self):
        return b''.join((
            b'\xe7.\xd4\x94',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class ChannelParticipant(TLObject):
    CONSTRUCTOR_ID = 0x15ebac1d
    SUBCLASS_OF_ID = 0xd9c7fc18

    def __init__(self, user_id, date):
        """
        :param int user_id:
        :param Optional[datetime] date:

        Constructor for ChannelParticipant: Instance of either ChannelParticipant, ChannelParticipantSelf, ChannelParticipantCreator, ChannelParticipantAdmin, ChannelParticipantBanned.
        """
        self.user_id = user_id  # type: int
        self.date = date  # type: Optional[datetime]

    def to_dict(self):
        return {
            '_': 'ChannelParticipant',
            'user_id': self.user_id,
            'date': self.date
        }

    def __bytes__(self):
        return b''.join((
            b'\x1d\xac\xeb\x15',
            struct.pack('<i', self.user_id),
            self.serialize_datetime(self.date),
        ))

    @classmethod
    def from_reader(cls, reader):
        _user_id = reader.read_int()
        _date = reader.tgread_date()
        return cls(user_id=_user_id, date=_date)


class ChannelParticipantAdmin(TLObject):
    CONSTRUCTOR_ID = 0xa82fa898
    SUBCLASS_OF_ID = 0xd9c7fc18

    def __init__(self, user_id, inviter_id, promoted_by, date, admin_rights, can_edit=None):
        """
        :param int user_id:
        :param int inviter_id:
        :param int promoted_by:
        :param Optional[datetime] date:
        :param TypeChannelAdminRights admin_rights:
        :param Optional[bool] can_edit:

        Constructor for ChannelParticipant: Instance of either ChannelParticipant, ChannelParticipantSelf, ChannelParticipantCreator, ChannelParticipantAdmin, ChannelParticipantBanned.
        """
        self.user_id = user_id  # type: int
        self.inviter_id = inviter_id  # type: int
        self.promoted_by = promoted_by  # type: int
        self.date = date  # type: Optional[datetime]
        self.admin_rights = admin_rights  # type: TypeChannelAdminRights
        self.can_edit = can_edit  # type: Optional[bool]

    def to_dict(self):
        return {
            '_': 'ChannelParticipantAdmin',
            'user_id': self.user_id,
            'inviter_id': self.inviter_id,
            'promoted_by': self.promoted_by,
            'date': self.date,
            'admin_rights': None if self.admin_rights is None else self.admin_rights.to_dict(),
            'can_edit': self.can_edit
        }

    def __bytes__(self):
        return b''.join((
            b'\x98\xa8/\xa8',
            struct.pack('<I', (0 if self.can_edit is None or self.can_edit is False else 1)),
            struct.pack('<i', self.user_id),
            struct.pack('<i', self.inviter_id),
            struct.pack('<i', self.promoted_by),
            self.serialize_datetime(self.date),
            bytes(self.admin_rights),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _can_edit = bool(flags & 1)
        _user_id = reader.read_int()
        _inviter_id = reader.read_int()
        _promoted_by = reader.read_int()
        _date = reader.tgread_date()
        _admin_rights = reader.tgread_object()
        return cls(user_id=_user_id, inviter_id=_inviter_id, promoted_by=_promoted_by, date=_date, admin_rights=_admin_rights, can_edit=_can_edit)


class ChannelParticipantBanned(TLObject):
    CONSTRUCTOR_ID = 0x222c1886
    SUBCLASS_OF_ID = 0xd9c7fc18

    def __init__(self, user_id, kicked_by, date, banned_rights, left=None):
        """
        :param int user_id:
        :param int kicked_by:
        :param Optional[datetime] date:
        :param TypeChannelBannedRights banned_rights:
        :param Optional[bool] left:

        Constructor for ChannelParticipant: Instance of either ChannelParticipant, ChannelParticipantSelf, ChannelParticipantCreator, ChannelParticipantAdmin, ChannelParticipantBanned.
        """
        self.user_id = user_id  # type: int
        self.kicked_by = kicked_by  # type: int
        self.date = date  # type: Optional[datetime]
        self.banned_rights = banned_rights  # type: TypeChannelBannedRights
        self.left = left  # type: Optional[bool]

    def to_dict(self):
        return {
            '_': 'ChannelParticipantBanned',
            'user_id': self.user_id,
            'kicked_by': self.kicked_by,
            'date': self.date,
            'banned_rights': None if self.banned_rights is None else self.banned_rights.to_dict(),
            'left': self.left
        }

    def __bytes__(self):
        return b''.join((
            b'\x86\x18,"',
            struct.pack('<I', (0 if self.left is None or self.left is False else 1)),
            struct.pack('<i', self.user_id),
            struct.pack('<i', self.kicked_by),
            self.serialize_datetime(self.date),
            bytes(self.banned_rights),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _left = bool(flags & 1)
        _user_id = reader.read_int()
        _kicked_by = reader.read_int()
        _date = reader.tgread_date()
        _banned_rights = reader.tgread_object()
        return cls(user_id=_user_id, kicked_by=_kicked_by, date=_date, banned_rights=_banned_rights, left=_left)


class ChannelParticipantCreator(TLObject):
    CONSTRUCTOR_ID = 0xe3e2e1f9
    SUBCLASS_OF_ID = 0xd9c7fc18

    def __init__(self, user_id):
        """
        :param int user_id:

        Constructor for ChannelParticipant: Instance of either ChannelParticipant, ChannelParticipantSelf, ChannelParticipantCreator, ChannelParticipantAdmin, ChannelParticipantBanned.
        """
        self.user_id = user_id  # type: int

    def to_dict(self):
        return {
            '_': 'ChannelParticipantCreator',
            'user_id': self.user_id
        }

    def __bytes__(self):
        return b''.join((
            b'\xf9\xe1\xe2\xe3',
            struct.pack('<i', self.user_id),
        ))

    @classmethod
    def from_reader(cls, reader):
        _user_id = reader.read_int()
        return cls(user_id=_user_id)


class ChannelParticipantSelf(TLObject):
    CONSTRUCTOR_ID = 0xa3289a6d
    SUBCLASS_OF_ID = 0xd9c7fc18

    def __init__(self, user_id, inviter_id, date):
        """
        :param int user_id:
        :param int inviter_id:
        :param Optional[datetime] date:

        Constructor for ChannelParticipant: Instance of either ChannelParticipant, ChannelParticipantSelf, ChannelParticipantCreator, ChannelParticipantAdmin, ChannelParticipantBanned.
        """
        self.user_id = user_id  # type: int
        self.inviter_id = inviter_id  # type: int
        self.date = date  # type: Optional[datetime]

    def to_dict(self):
        return {
            '_': 'ChannelParticipantSelf',
            'user_id': self.user_id,
            'inviter_id': self.inviter_id,
            'date': self.date
        }

    def __bytes__(self):
        return b''.join((
            b'm\x9a(\xa3',
            struct.pack('<i', self.user_id),
            struct.pack('<i', self.inviter_id),
            self.serialize_datetime(self.date),
        ))

    @classmethod
    def from_reader(cls, reader):
        _user_id = reader.read_int()
        _inviter_id = reader.read_int()
        _date = reader.tgread_date()
        return cls(user_id=_user_id, inviter_id=_inviter_id, date=_date)


class ChannelParticipantsAdmins(TLObject):
    CONSTRUCTOR_ID = 0xb4608969
    SUBCLASS_OF_ID = 0xbf4e2753

    def to_dict(self):
        return {
            '_': 'ChannelParticipantsAdmins'
        }

    def __bytes__(self):
        return b''.join((
            b'i\x89`\xb4',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class ChannelParticipantsBanned(TLObject):
    CONSTRUCTOR_ID = 0x1427a5e1
    SUBCLASS_OF_ID = 0xbf4e2753

    def __init__(self, q):
        """
        :param str q:

        Constructor for ChannelParticipantsFilter: Instance of either ChannelParticipantsRecent, ChannelParticipantsAdmins, ChannelParticipantsKicked, ChannelParticipantsBots, ChannelParticipantsBanned, ChannelParticipantsSearch.
        """
        self.q = q  # type: str

    def to_dict(self):
        return {
            '_': 'ChannelParticipantsBanned',
            'q': self.q
        }

    def __bytes__(self):
        return b''.join((
            b"\xe1\xa5'\x14",
            self.serialize_bytes(self.q),
        ))

    @classmethod
    def from_reader(cls, reader):
        _q = reader.tgread_string()
        return cls(q=_q)


class ChannelParticipantsBots(TLObject):
    CONSTRUCTOR_ID = 0xb0d1865b
    SUBCLASS_OF_ID = 0xbf4e2753

    def to_dict(self):
        return {
            '_': 'ChannelParticipantsBots'
        }

    def __bytes__(self):
        return b''.join((
            b'[\x86\xd1\xb0',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class ChannelParticipantsKicked(TLObject):
    CONSTRUCTOR_ID = 0xa3b54985
    SUBCLASS_OF_ID = 0xbf4e2753

    def __init__(self, q):
        """
        :param str q:

        Constructor for ChannelParticipantsFilter: Instance of either ChannelParticipantsRecent, ChannelParticipantsAdmins, ChannelParticipantsKicked, ChannelParticipantsBots, ChannelParticipantsBanned, ChannelParticipantsSearch.
        """
        self.q = q  # type: str

    def to_dict(self):
        return {
            '_': 'ChannelParticipantsKicked',
            'q': self.q
        }

    def __bytes__(self):
        return b''.join((
            b'\x85I\xb5\xa3',
            self.serialize_bytes(self.q),
        ))

    @classmethod
    def from_reader(cls, reader):
        _q = reader.tgread_string()
        return cls(q=_q)


class ChannelParticipantsRecent(TLObject):
    CONSTRUCTOR_ID = 0xde3f3c79
    SUBCLASS_OF_ID = 0xbf4e2753

    def to_dict(self):
        return {
            '_': 'ChannelParticipantsRecent'
        }

    def __bytes__(self):
        return b''.join((
            b'y<?\xde',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class ChannelParticipantsSearch(TLObject):
    CONSTRUCTOR_ID = 0x656ac4b
    SUBCLASS_OF_ID = 0xbf4e2753

    def __init__(self, q):
        """
        :param str q:

        Constructor for ChannelParticipantsFilter: Instance of either ChannelParticipantsRecent, ChannelParticipantsAdmins, ChannelParticipantsKicked, ChannelParticipantsBots, ChannelParticipantsBanned, ChannelParticipantsSearch.
        """
        self.q = q  # type: str

    def to_dict(self):
        return {
            '_': 'ChannelParticipantsSearch',
            'q': self.q
        }

    def __bytes__(self):
        return b''.join((
            b'K\xacV\x06',
            self.serialize_bytes(self.q),
        ))

    @classmethod
    def from_reader(cls, reader):
        _q = reader.tgread_string()
        return cls(q=_q)


class Chat(TLObject):
    CONSTRUCTOR_ID = 0xd91cdd54
    SUBCLASS_OF_ID = 0xc5af5d94

    def __init__(self, id, title, photo, participants_count, date, version, creator=None, kicked=None, left=None, admins_enabled=None, admin=None, deactivated=None, migrated_to=None):
        """
        :param int id:
        :param str title:
        :param TypeChatPhoto photo:
        :param int participants_count:
        :param Optional[datetime] date:
        :param int version:
        :param Optional[bool] creator:
        :param Optional[bool] kicked:
        :param Optional[bool] left:
        :param Optional[bool] admins_enabled:
        :param Optional[bool] admin:
        :param Optional[bool] deactivated:
        :param Optional[TypeInputChannel] migrated_to:

        Constructor for Chat: Instance of either ChatEmpty, Chat, ChatForbidden, Channel, ChannelForbidden.
        """
        self.id = id  # type: int
        self.title = title  # type: str
        self.photo = photo  # type: TypeChatPhoto
        self.participants_count = participants_count  # type: int
        self.date = date  # type: Optional[datetime]
        self.version = version  # type: int
        self.creator = creator  # type: Optional[bool]
        self.kicked = kicked  # type: Optional[bool]
        self.left = left  # type: Optional[bool]
        self.admins_enabled = admins_enabled  # type: Optional[bool]
        self.admin = admin  # type: Optional[bool]
        self.deactivated = deactivated  # type: Optional[bool]
        self.migrated_to = migrated_to  # type: Optional[TypeInputChannel]

    def to_dict(self):
        return {
            '_': 'Chat',
            'id': self.id,
            'title': self.title,
            'photo': None if self.photo is None else self.photo.to_dict(),
            'participants_count': self.participants_count,
            'date': self.date,
            'version': self.version,
            'creator': self.creator,
            'kicked': self.kicked,
            'left': self.left,
            'admins_enabled': self.admins_enabled,
            'admin': self.admin,
            'deactivated': self.deactivated,
            'migrated_to': None if self.migrated_to is None else self.migrated_to.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'T\xdd\x1c\xd9',
            struct.pack('<I', (0 if self.creator is None or self.creator is False else 1) | (0 if self.kicked is None or self.kicked is False else 2) | (0 if self.left is None or self.left is False else 4) | (0 if self.admins_enabled is None or self.admins_enabled is False else 8) | (0 if self.admin is None or self.admin is False else 16) | (0 if self.deactivated is None or self.deactivated is False else 32) | (0 if self.migrated_to is None or self.migrated_to is False else 64)),
            struct.pack('<i', self.id),
            self.serialize_bytes(self.title),
            bytes(self.photo),
            struct.pack('<i', self.participants_count),
            self.serialize_datetime(self.date),
            struct.pack('<i', self.version),
            b'' if self.migrated_to is None or self.migrated_to is False else (bytes(self.migrated_to)),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _creator = bool(flags & 1)
        _kicked = bool(flags & 2)
        _left = bool(flags & 4)
        _admins_enabled = bool(flags & 8)
        _admin = bool(flags & 16)
        _deactivated = bool(flags & 32)
        _id = reader.read_int()
        _title = reader.tgread_string()
        _photo = reader.tgread_object()
        _participants_count = reader.read_int()
        _date = reader.tgread_date()
        _version = reader.read_int()
        if flags & 64:
            _migrated_to = reader.tgread_object()
        else:
            _migrated_to = None
        return cls(id=_id, title=_title, photo=_photo, participants_count=_participants_count, date=_date, version=_version, creator=_creator, kicked=_kicked, left=_left, admins_enabled=_admins_enabled, admin=_admin, deactivated=_deactivated, migrated_to=_migrated_to)


class ChatEmpty(TLObject):
    CONSTRUCTOR_ID = 0x9ba2d800
    SUBCLASS_OF_ID = 0xc5af5d94

    def __init__(self, id):
        """
        :param int id:

        Constructor for Chat: Instance of either ChatEmpty, Chat, ChatForbidden, Channel, ChannelForbidden.
        """
        self.id = id  # type: int

    def to_dict(self):
        return {
            '_': 'ChatEmpty',
            'id': self.id
        }

    def __bytes__(self):
        return b''.join((
            b'\x00\xd8\xa2\x9b',
            struct.pack('<i', self.id),
        ))

    @classmethod
    def from_reader(cls, reader):
        _id = reader.read_int()
        return cls(id=_id)


class ChatForbidden(TLObject):
    CONSTRUCTOR_ID = 0x7328bdb
    SUBCLASS_OF_ID = 0xc5af5d94

    def __init__(self, id, title):
        """
        :param int id:
        :param str title:

        Constructor for Chat: Instance of either ChatEmpty, Chat, ChatForbidden, Channel, ChannelForbidden.
        """
        self.id = id  # type: int
        self.title = title  # type: str

    def to_dict(self):
        return {
            '_': 'ChatForbidden',
            'id': self.id,
            'title': self.title
        }

    def __bytes__(self):
        return b''.join((
            b'\xdb\x8b2\x07',
            struct.pack('<i', self.id),
            self.serialize_bytes(self.title),
        ))

    @classmethod
    def from_reader(cls, reader):
        _id = reader.read_int()
        _title = reader.tgread_string()
        return cls(id=_id, title=_title)


class ChatFull(TLObject):
    CONSTRUCTOR_ID = 0x2e02a614
    SUBCLASS_OF_ID = 0xd49a2697

    def __init__(self, id, participants, chat_photo, notify_settings, exported_invite, bot_info):
        """
        :param int id:
        :param TypeChatParticipants participants:
        :param TypePhoto chat_photo:
        :param TypePeerNotifySettings notify_settings:
        :param TypeExportedChatInvite exported_invite:
        :param List[TypeBotInfo] bot_info:

        Constructor for ChatFull: Instance of either ChatFull, ChannelFull.
        """
        self.id = id  # type: int
        self.participants = participants  # type: TypeChatParticipants
        self.chat_photo = chat_photo  # type: TypePhoto
        self.notify_settings = notify_settings  # type: TypePeerNotifySettings
        self.exported_invite = exported_invite  # type: TypeExportedChatInvite
        self.bot_info = bot_info  # type: List[TypeBotInfo]

    def to_dict(self):
        return {
            '_': 'ChatFull',
            'id': self.id,
            'participants': None if self.participants is None else self.participants.to_dict(),
            'chat_photo': None if self.chat_photo is None else self.chat_photo.to_dict(),
            'notify_settings': None if self.notify_settings is None else self.notify_settings.to_dict(),
            'exported_invite': None if self.exported_invite is None else self.exported_invite.to_dict(),
            'bot_info': [] if self.bot_info is None else [None if x is None else x.to_dict() for x in self.bot_info]
        }

    def __bytes__(self):
        return b''.join((
            b'\x14\xa6\x02.',
            struct.pack('<i', self.id),
            bytes(self.participants),
            bytes(self.chat_photo),
            bytes(self.notify_settings),
            bytes(self.exported_invite),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.bot_info)),b''.join(bytes(x) for x in self.bot_info),
        ))

    @classmethod
    def from_reader(cls, reader):
        _id = reader.read_int()
        _participants = reader.tgread_object()
        _chat_photo = reader.tgread_object()
        _notify_settings = reader.tgread_object()
        _exported_invite = reader.tgread_object()
        reader.read_int()
        _bot_info = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _bot_info.append(_x)

        return cls(id=_id, participants=_participants, chat_photo=_chat_photo, notify_settings=_notify_settings, exported_invite=_exported_invite, bot_info=_bot_info)


class ChatInvite(TLObject):
    CONSTRUCTOR_ID = 0xdb74f558
    SUBCLASS_OF_ID = 0x4561736

    def __init__(self, title, photo, participants_count, channel=None, broadcast=None, public=None, megagroup=None, participants=None):
        """
        :param str title:
        :param TypeChatPhoto photo:
        :param int participants_count:
        :param Optional[bool] channel:
        :param Optional[bool] broadcast:
        :param Optional[bool] public:
        :param Optional[bool] megagroup:
        :param Optional[List[TypeUser]] participants:

        Constructor for ChatInvite: Instance of either ChatInviteAlready, ChatInvite.
        """
        self.title = title  # type: str
        self.photo = photo  # type: TypeChatPhoto
        self.participants_count = participants_count  # type: int
        self.channel = channel  # type: Optional[bool]
        self.broadcast = broadcast  # type: Optional[bool]
        self.public = public  # type: Optional[bool]
        self.megagroup = megagroup  # type: Optional[bool]
        self.participants = participants  # type: Optional[List[TypeUser]]

    def to_dict(self):
        return {
            '_': 'ChatInvite',
            'title': self.title,
            'photo': None if self.photo is None else self.photo.to_dict(),
            'participants_count': self.participants_count,
            'channel': self.channel,
            'broadcast': self.broadcast,
            'public': self.public,
            'megagroup': self.megagroup,
            'participants': [] if self.participants is None else [None if x is None else x.to_dict() for x in self.participants]
        }

    def __bytes__(self):
        return b''.join((
            b'X\xf5t\xdb',
            struct.pack('<I', (0 if self.channel is None or self.channel is False else 1) | (0 if self.broadcast is None or self.broadcast is False else 2) | (0 if self.public is None or self.public is False else 4) | (0 if self.megagroup is None or self.megagroup is False else 8) | (0 if self.participants is None or self.participants is False else 16)),
            self.serialize_bytes(self.title),
            bytes(self.photo),
            struct.pack('<i', self.participants_count),
            b'' if self.participants is None or self.participants is False else b''.join((b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.participants)),b''.join(bytes(x) for x in self.participants))),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _channel = bool(flags & 1)
        _broadcast = bool(flags & 2)
        _public = bool(flags & 4)
        _megagroup = bool(flags & 8)
        _title = reader.tgread_string()
        _photo = reader.tgread_object()
        _participants_count = reader.read_int()
        if flags & 16:
            reader.read_int()
            _participants = []
            for _ in range(reader.read_int()):
                _x = reader.tgread_object()
                _participants.append(_x)

        else:
            _participants = None
        return cls(title=_title, photo=_photo, participants_count=_participants_count, channel=_channel, broadcast=_broadcast, public=_public, megagroup=_megagroup, participants=_participants)


class ChatInviteAlready(TLObject):
    CONSTRUCTOR_ID = 0x5a686d7c
    SUBCLASS_OF_ID = 0x4561736

    def __init__(self, chat):
        """
        :param TypeChat chat:

        Constructor for ChatInvite: Instance of either ChatInviteAlready, ChatInvite.
        """
        self.chat = chat  # type: TypeChat

    def to_dict(self):
        return {
            '_': 'ChatInviteAlready',
            'chat': None if self.chat is None else self.chat.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'|mhZ',
            bytes(self.chat),
        ))

    @classmethod
    def from_reader(cls, reader):
        _chat = reader.tgread_object()
        return cls(chat=_chat)


class ChatInviteEmpty(TLObject):
    CONSTRUCTOR_ID = 0x69df3769
    SUBCLASS_OF_ID = 0xb4748a58

    def to_dict(self):
        return {
            '_': 'ChatInviteEmpty'
        }

    def __bytes__(self):
        return b''.join((
            b'i7\xdfi',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class ChatInviteExported(TLObject):
    CONSTRUCTOR_ID = 0xfc2e05bc
    SUBCLASS_OF_ID = 0xb4748a58

    def __init__(self, link):
        """
        :param str link:

        Constructor for ExportedChatInvite: Instance of either ChatInviteEmpty, ChatInviteExported.
        """
        self.link = link  # type: str

    def to_dict(self):
        return {
            '_': 'ChatInviteExported',
            'link': self.link
        }

    def __bytes__(self):
        return b''.join((
            b'\xbc\x05.\xfc',
            self.serialize_bytes(self.link),
        ))

    @classmethod
    def from_reader(cls, reader):
        _link = reader.tgread_string()
        return cls(link=_link)


class ChatParticipant(TLObject):
    CONSTRUCTOR_ID = 0xc8d7493e
    SUBCLASS_OF_ID = 0x7d7c6f86

    def __init__(self, user_id, inviter_id, date):
        """
        :param int user_id:
        :param int inviter_id:
        :param Optional[datetime] date:

        Constructor for ChatParticipant: Instance of either ChatParticipant, ChatParticipantCreator, ChatParticipantAdmin.
        """
        self.user_id = user_id  # type: int
        self.inviter_id = inviter_id  # type: int
        self.date = date  # type: Optional[datetime]

    def to_dict(self):
        return {
            '_': 'ChatParticipant',
            'user_id': self.user_id,
            'inviter_id': self.inviter_id,
            'date': self.date
        }

    def __bytes__(self):
        return b''.join((
            b'>I\xd7\xc8',
            struct.pack('<i', self.user_id),
            struct.pack('<i', self.inviter_id),
            self.serialize_datetime(self.date),
        ))

    @classmethod
    def from_reader(cls, reader):
        _user_id = reader.read_int()
        _inviter_id = reader.read_int()
        _date = reader.tgread_date()
        return cls(user_id=_user_id, inviter_id=_inviter_id, date=_date)


class ChatParticipantAdmin(TLObject):
    CONSTRUCTOR_ID = 0xe2d6e436
    SUBCLASS_OF_ID = 0x7d7c6f86

    def __init__(self, user_id, inviter_id, date):
        """
        :param int user_id:
        :param int inviter_id:
        :param Optional[datetime] date:

        Constructor for ChatParticipant: Instance of either ChatParticipant, ChatParticipantCreator, ChatParticipantAdmin.
        """
        self.user_id = user_id  # type: int
        self.inviter_id = inviter_id  # type: int
        self.date = date  # type: Optional[datetime]

    def to_dict(self):
        return {
            '_': 'ChatParticipantAdmin',
            'user_id': self.user_id,
            'inviter_id': self.inviter_id,
            'date': self.date
        }

    def __bytes__(self):
        return b''.join((
            b'6\xe4\xd6\xe2',
            struct.pack('<i', self.user_id),
            struct.pack('<i', self.inviter_id),
            self.serialize_datetime(self.date),
        ))

    @classmethod
    def from_reader(cls, reader):
        _user_id = reader.read_int()
        _inviter_id = reader.read_int()
        _date = reader.tgread_date()
        return cls(user_id=_user_id, inviter_id=_inviter_id, date=_date)


class ChatParticipantCreator(TLObject):
    CONSTRUCTOR_ID = 0xda13538a
    SUBCLASS_OF_ID = 0x7d7c6f86

    def __init__(self, user_id):
        """
        :param int user_id:

        Constructor for ChatParticipant: Instance of either ChatParticipant, ChatParticipantCreator, ChatParticipantAdmin.
        """
        self.user_id = user_id  # type: int

    def to_dict(self):
        return {
            '_': 'ChatParticipantCreator',
            'user_id': self.user_id
        }

    def __bytes__(self):
        return b''.join((
            b'\x8aS\x13\xda',
            struct.pack('<i', self.user_id),
        ))

    @classmethod
    def from_reader(cls, reader):
        _user_id = reader.read_int()
        return cls(user_id=_user_id)


class ChatParticipants(TLObject):
    CONSTRUCTOR_ID = 0x3f460fed
    SUBCLASS_OF_ID = 0x1fa89571

    def __init__(self, chat_id, participants, version):
        """
        :param int chat_id:
        :param List[TypeChatParticipant] participants:
        :param int version:

        Constructor for ChatParticipants: Instance of either ChatParticipantsForbidden, ChatParticipants.
        """
        self.chat_id = chat_id  # type: int
        self.participants = participants  # type: List[TypeChatParticipant]
        self.version = version  # type: int

    def to_dict(self):
        return {
            '_': 'ChatParticipants',
            'chat_id': self.chat_id,
            'participants': [] if self.participants is None else [None if x is None else x.to_dict() for x in self.participants],
            'version': self.version
        }

    def __bytes__(self):
        return b''.join((
            b'\xed\x0fF?',
            struct.pack('<i', self.chat_id),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.participants)),b''.join(bytes(x) for x in self.participants),
            struct.pack('<i', self.version),
        ))

    @classmethod
    def from_reader(cls, reader):
        _chat_id = reader.read_int()
        reader.read_int()
        _participants = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _participants.append(_x)

        _version = reader.read_int()
        return cls(chat_id=_chat_id, participants=_participants, version=_version)


class ChatParticipantsForbidden(TLObject):
    CONSTRUCTOR_ID = 0xfc900c2b
    SUBCLASS_OF_ID = 0x1fa89571

    def __init__(self, chat_id, self_participant=None):
        """
        :param int chat_id:
        :param Optional[TypeChatParticipant] self_participant:

        Constructor for ChatParticipants: Instance of either ChatParticipantsForbidden, ChatParticipants.
        """
        self.chat_id = chat_id  # type: int
        self.self_participant = self_participant  # type: Optional[TypeChatParticipant]

    def to_dict(self):
        return {
            '_': 'ChatParticipantsForbidden',
            'chat_id': self.chat_id,
            'self_participant': None if self.self_participant is None else self.self_participant.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'+\x0c\x90\xfc',
            struct.pack('<I', (0 if self.self_participant is None or self.self_participant is False else 1)),
            struct.pack('<i', self.chat_id),
            b'' if self.self_participant is None or self.self_participant is False else (bytes(self.self_participant)),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _chat_id = reader.read_int()
        if flags & 1:
            _self_participant = reader.tgread_object()
        else:
            _self_participant = None
        return cls(chat_id=_chat_id, self_participant=_self_participant)


class ChatPhoto(TLObject):
    CONSTRUCTOR_ID = 0x6153276a
    SUBCLASS_OF_ID = 0xac3ec4e5

    def __init__(self, photo_small, photo_big):
        """
        :param TypeFileLocation photo_small:
        :param TypeFileLocation photo_big:

        Constructor for ChatPhoto: Instance of either ChatPhotoEmpty, ChatPhoto.
        """
        self.photo_small = photo_small  # type: TypeFileLocation
        self.photo_big = photo_big  # type: TypeFileLocation

    def to_dict(self):
        return {
            '_': 'ChatPhoto',
            'photo_small': None if self.photo_small is None else self.photo_small.to_dict(),
            'photo_big': None if self.photo_big is None else self.photo_big.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b"j'Sa",
            bytes(self.photo_small),
            bytes(self.photo_big),
        ))

    @classmethod
    def from_reader(cls, reader):
        _photo_small = reader.tgread_object()
        _photo_big = reader.tgread_object()
        return cls(photo_small=_photo_small, photo_big=_photo_big)


class ChatPhotoEmpty(TLObject):
    CONSTRUCTOR_ID = 0x37c1011c
    SUBCLASS_OF_ID = 0xac3ec4e5

    def to_dict(self):
        return {
            '_': 'ChatPhotoEmpty'
        }

    def __bytes__(self):
        return b''.join((
            b'\x1c\x01\xc17',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class ClientDHInnerData(TLObject):
    CONSTRUCTOR_ID = 0x6643b654
    SUBCLASS_OF_ID = 0xf8eeef6a

    def __init__(self, nonce, server_nonce, retry_id, g_b):
        """
        :param int nonce:
        :param int server_nonce:
        :param int retry_id:
        :param bytes g_b:

        Constructor for Client_DH_Inner_Data: Instance of ClientDHInnerData.
        """
        self.nonce = nonce  # type: int
        self.server_nonce = server_nonce  # type: int
        self.retry_id = retry_id  # type: int
        self.g_b = g_b  # type: bytes

    def to_dict(self):
        return {
            '_': 'ClientDHInnerData',
            'nonce': self.nonce,
            'server_nonce': self.server_nonce,
            'retry_id': self.retry_id,
            'g_b': self.g_b
        }

    def __bytes__(self):
        return b''.join((
            b'T\xb6Cf',
            self.nonce.to_bytes(16, 'little', signed=True),
            self.server_nonce.to_bytes(16, 'little', signed=True),
            struct.pack('<q', self.retry_id),
            self.serialize_bytes(self.g_b),
        ))

    @classmethod
    def from_reader(cls, reader):
        _nonce = reader.read_large_int(bits=128)
        _server_nonce = reader.read_large_int(bits=128)
        _retry_id = reader.read_long()
        _g_b = reader.tgread_bytes()
        return cls(nonce=_nonce, server_nonce=_server_nonce, retry_id=_retry_id, g_b=_g_b)


class Config(TLObject):
    CONSTRUCTOR_ID = 0x3213dbba
    SUBCLASS_OF_ID = 0xd3262a4a

    def __init__(self, date, expires, test_mode, this_dc, dc_options, dc_txt_domain_name, chat_size_max, megagroup_size_max, forwarded_count_max, online_update_period_ms, offline_blur_timeout_ms, offline_idle_timeout_ms, online_cloud_timeout_ms, notify_cloud_delay_ms, notify_default_delay_ms, push_chat_period_ms, push_chat_limit, saved_gifs_limit, edit_time_limit, revoke_time_limit, revoke_pm_time_limit, rating_e_decay, stickers_recent_limit, stickers_faved_limit, channels_read_media_period, pinned_dialogs_count_max, call_receive_timeout_ms, call_ring_timeout_ms, call_connect_timeout_ms, call_packet_timeout_ms, me_url_prefix, caption_length_max, message_length_max, webfile_dc_id, phonecalls_enabled=None, default_p2p_contacts=None, preload_featured_stickers=None, ignore_phone_entities=None, revoke_pm_inbox=None, blocked_mode=None, tmp_sessions=None, autoupdate_url_prefix=None, gif_search_username=None, venue_search_username=None, img_search_username=None, static_maps_provider=None, suggested_lang_code=None, lang_pack_version=None):
        """
        :param Optional[datetime] date:
        :param Optional[datetime] expires:
        :param TypeBool test_mode:
        :param int this_dc:
        :param List[TypeDcOption] dc_options:
        :param str dc_txt_domain_name:
        :param int chat_size_max:
        :param int megagroup_size_max:
        :param int forwarded_count_max:
        :param int online_update_period_ms:
        :param int offline_blur_timeout_ms:
        :param int offline_idle_timeout_ms:
        :param int online_cloud_timeout_ms:
        :param int notify_cloud_delay_ms:
        :param int notify_default_delay_ms:
        :param int push_chat_period_ms:
        :param int push_chat_limit:
        :param int saved_gifs_limit:
        :param int edit_time_limit:
        :param int revoke_time_limit:
        :param int revoke_pm_time_limit:
        :param int rating_e_decay:
        :param int stickers_recent_limit:
        :param int stickers_faved_limit:
        :param int channels_read_media_period:
        :param int pinned_dialogs_count_max:
        :param int call_receive_timeout_ms:
        :param int call_ring_timeout_ms:
        :param int call_connect_timeout_ms:
        :param int call_packet_timeout_ms:
        :param str me_url_prefix:
        :param int caption_length_max:
        :param int message_length_max:
        :param int webfile_dc_id:
        :param Optional[bool] phonecalls_enabled:
        :param Optional[bool] default_p2p_contacts:
        :param Optional[bool] preload_featured_stickers:
        :param Optional[bool] ignore_phone_entities:
        :param Optional[bool] revoke_pm_inbox:
        :param Optional[bool] blocked_mode:
        :param Optional[int] tmp_sessions:
        :param Optional[str] autoupdate_url_prefix:
        :param Optional[str] gif_search_username:
        :param Optional[str] venue_search_username:
        :param Optional[str] img_search_username:
        :param Optional[str] static_maps_provider:
        :param Optional[str] suggested_lang_code:
        :param Optional[int] lang_pack_version:

        Constructor for Config: Instance of Config.
        """
        self.date = date  # type: Optional[datetime]
        self.expires = expires  # type: Optional[datetime]
        self.test_mode = test_mode  # type: TypeBool
        self.this_dc = this_dc  # type: int
        self.dc_options = dc_options  # type: List[TypeDcOption]
        self.dc_txt_domain_name = dc_txt_domain_name  # type: str
        self.chat_size_max = chat_size_max  # type: int
        self.megagroup_size_max = megagroup_size_max  # type: int
        self.forwarded_count_max = forwarded_count_max  # type: int
        self.online_update_period_ms = online_update_period_ms  # type: int
        self.offline_blur_timeout_ms = offline_blur_timeout_ms  # type: int
        self.offline_idle_timeout_ms = offline_idle_timeout_ms  # type: int
        self.online_cloud_timeout_ms = online_cloud_timeout_ms  # type: int
        self.notify_cloud_delay_ms = notify_cloud_delay_ms  # type: int
        self.notify_default_delay_ms = notify_default_delay_ms  # type: int
        self.push_chat_period_ms = push_chat_period_ms  # type: int
        self.push_chat_limit = push_chat_limit  # type: int
        self.saved_gifs_limit = saved_gifs_limit  # type: int
        self.edit_time_limit = edit_time_limit  # type: int
        self.revoke_time_limit = revoke_time_limit  # type: int
        self.revoke_pm_time_limit = revoke_pm_time_limit  # type: int
        self.rating_e_decay = rating_e_decay  # type: int
        self.stickers_recent_limit = stickers_recent_limit  # type: int
        self.stickers_faved_limit = stickers_faved_limit  # type: int
        self.channels_read_media_period = channels_read_media_period  # type: int
        self.pinned_dialogs_count_max = pinned_dialogs_count_max  # type: int
        self.call_receive_timeout_ms = call_receive_timeout_ms  # type: int
        self.call_ring_timeout_ms = call_ring_timeout_ms  # type: int
        self.call_connect_timeout_ms = call_connect_timeout_ms  # type: int
        self.call_packet_timeout_ms = call_packet_timeout_ms  # type: int
        self.me_url_prefix = me_url_prefix  # type: str
        self.caption_length_max = caption_length_max  # type: int
        self.message_length_max = message_length_max  # type: int
        self.webfile_dc_id = webfile_dc_id  # type: int
        self.phonecalls_enabled = phonecalls_enabled  # type: Optional[bool]
        self.default_p2p_contacts = default_p2p_contacts  # type: Optional[bool]
        self.preload_featured_stickers = preload_featured_stickers  # type: Optional[bool]
        self.ignore_phone_entities = ignore_phone_entities  # type: Optional[bool]
        self.revoke_pm_inbox = revoke_pm_inbox  # type: Optional[bool]
        self.blocked_mode = blocked_mode  # type: Optional[bool]
        self.tmp_sessions = tmp_sessions  # type: Optional[int]
        self.autoupdate_url_prefix = autoupdate_url_prefix  # type: Optional[str]
        self.gif_search_username = gif_search_username  # type: Optional[str]
        self.venue_search_username = venue_search_username  # type: Optional[str]
        self.img_search_username = img_search_username  # type: Optional[str]
        self.static_maps_provider = static_maps_provider  # type: Optional[str]
        self.suggested_lang_code = suggested_lang_code  # type: Optional[str]
        self.lang_pack_version = lang_pack_version  # type: Optional[int]

    def to_dict(self):
        return {
            '_': 'Config',
            'date': self.date,
            'expires': self.expires,
            'test_mode': self.test_mode,
            'this_dc': self.this_dc,
            'dc_options': [] if self.dc_options is None else [None if x is None else x.to_dict() for x in self.dc_options],
            'dc_txt_domain_name': self.dc_txt_domain_name,
            'chat_size_max': self.chat_size_max,
            'megagroup_size_max': self.megagroup_size_max,
            'forwarded_count_max': self.forwarded_count_max,
            'online_update_period_ms': self.online_update_period_ms,
            'offline_blur_timeout_ms': self.offline_blur_timeout_ms,
            'offline_idle_timeout_ms': self.offline_idle_timeout_ms,
            'online_cloud_timeout_ms': self.online_cloud_timeout_ms,
            'notify_cloud_delay_ms': self.notify_cloud_delay_ms,
            'notify_default_delay_ms': self.notify_default_delay_ms,
            'push_chat_period_ms': self.push_chat_period_ms,
            'push_chat_limit': self.push_chat_limit,
            'saved_gifs_limit': self.saved_gifs_limit,
            'edit_time_limit': self.edit_time_limit,
            'revoke_time_limit': self.revoke_time_limit,
            'revoke_pm_time_limit': self.revoke_pm_time_limit,
            'rating_e_decay': self.rating_e_decay,
            'stickers_recent_limit': self.stickers_recent_limit,
            'stickers_faved_limit': self.stickers_faved_limit,
            'channels_read_media_period': self.channels_read_media_period,
            'pinned_dialogs_count_max': self.pinned_dialogs_count_max,
            'call_receive_timeout_ms': self.call_receive_timeout_ms,
            'call_ring_timeout_ms': self.call_ring_timeout_ms,
            'call_connect_timeout_ms': self.call_connect_timeout_ms,
            'call_packet_timeout_ms': self.call_packet_timeout_ms,
            'me_url_prefix': self.me_url_prefix,
            'caption_length_max': self.caption_length_max,
            'message_length_max': self.message_length_max,
            'webfile_dc_id': self.webfile_dc_id,
            'phonecalls_enabled': self.phonecalls_enabled,
            'default_p2p_contacts': self.default_p2p_contacts,
            'preload_featured_stickers': self.preload_featured_stickers,
            'ignore_phone_entities': self.ignore_phone_entities,
            'revoke_pm_inbox': self.revoke_pm_inbox,
            'blocked_mode': self.blocked_mode,
            'tmp_sessions': self.tmp_sessions,
            'autoupdate_url_prefix': self.autoupdate_url_prefix,
            'gif_search_username': self.gif_search_username,
            'venue_search_username': self.venue_search_username,
            'img_search_username': self.img_search_username,
            'static_maps_provider': self.static_maps_provider,
            'suggested_lang_code': self.suggested_lang_code,
            'lang_pack_version': self.lang_pack_version
        }

    def __bytes__(self):
        assert ((self.suggested_lang_code or self.suggested_lang_code is not None) and (self.lang_pack_version or self.lang_pack_version is not None)) or ((self.suggested_lang_code is None or self.suggested_lang_code is False) and (self.lang_pack_version is None or self.lang_pack_version is False)), 'suggested_lang_code, lang_pack_version parameters must all be False-y (like None) or all me True-y'
        return b''.join((
            b'\xba\xdb\x132',
            struct.pack('<I', (0 if self.phonecalls_enabled is None or self.phonecalls_enabled is False else 2) | (0 if self.default_p2p_contacts is None or self.default_p2p_contacts is False else 8) | (0 if self.preload_featured_stickers is None or self.preload_featured_stickers is False else 16) | (0 if self.ignore_phone_entities is None or self.ignore_phone_entities is False else 32) | (0 if self.revoke_pm_inbox is None or self.revoke_pm_inbox is False else 64) | (0 if self.blocked_mode is None or self.blocked_mode is False else 256) | (0 if self.tmp_sessions is None or self.tmp_sessions is False else 1) | (0 if self.autoupdate_url_prefix is None or self.autoupdate_url_prefix is False else 128) | (0 if self.gif_search_username is None or self.gif_search_username is False else 512) | (0 if self.venue_search_username is None or self.venue_search_username is False else 1024) | (0 if self.img_search_username is None or self.img_search_username is False else 2048) | (0 if self.static_maps_provider is None or self.static_maps_provider is False else 4096) | (0 if self.suggested_lang_code is None or self.suggested_lang_code is False else 4) | (0 if self.lang_pack_version is None or self.lang_pack_version is False else 4)),
            self.serialize_datetime(self.date),
            self.serialize_datetime(self.expires),
            b'\xb5ur\x99' if self.test_mode else b'7\x97y\xbc',
            struct.pack('<i', self.this_dc),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.dc_options)),b''.join(bytes(x) for x in self.dc_options),
            self.serialize_bytes(self.dc_txt_domain_name),
            struct.pack('<i', self.chat_size_max),
            struct.pack('<i', self.megagroup_size_max),
            struct.pack('<i', self.forwarded_count_max),
            struct.pack('<i', self.online_update_period_ms),
            struct.pack('<i', self.offline_blur_timeout_ms),
            struct.pack('<i', self.offline_idle_timeout_ms),
            struct.pack('<i', self.online_cloud_timeout_ms),
            struct.pack('<i', self.notify_cloud_delay_ms),
            struct.pack('<i', self.notify_default_delay_ms),
            struct.pack('<i', self.push_chat_period_ms),
            struct.pack('<i', self.push_chat_limit),
            struct.pack('<i', self.saved_gifs_limit),
            struct.pack('<i', self.edit_time_limit),
            struct.pack('<i', self.revoke_time_limit),
            struct.pack('<i', self.revoke_pm_time_limit),
            struct.pack('<i', self.rating_e_decay),
            struct.pack('<i', self.stickers_recent_limit),
            struct.pack('<i', self.stickers_faved_limit),
            struct.pack('<i', self.channels_read_media_period),
            b'' if self.tmp_sessions is None or self.tmp_sessions is False else (struct.pack('<i', self.tmp_sessions)),
            struct.pack('<i', self.pinned_dialogs_count_max),
            struct.pack('<i', self.call_receive_timeout_ms),
            struct.pack('<i', self.call_ring_timeout_ms),
            struct.pack('<i', self.call_connect_timeout_ms),
            struct.pack('<i', self.call_packet_timeout_ms),
            self.serialize_bytes(self.me_url_prefix),
            b'' if self.autoupdate_url_prefix is None or self.autoupdate_url_prefix is False else (self.serialize_bytes(self.autoupdate_url_prefix)),
            b'' if self.gif_search_username is None or self.gif_search_username is False else (self.serialize_bytes(self.gif_search_username)),
            b'' if self.venue_search_username is None or self.venue_search_username is False else (self.serialize_bytes(self.venue_search_username)),
            b'' if self.img_search_username is None or self.img_search_username is False else (self.serialize_bytes(self.img_search_username)),
            b'' if self.static_maps_provider is None or self.static_maps_provider is False else (self.serialize_bytes(self.static_maps_provider)),
            struct.pack('<i', self.caption_length_max),
            struct.pack('<i', self.message_length_max),
            struct.pack('<i', self.webfile_dc_id),
            b'' if self.suggested_lang_code is None or self.suggested_lang_code is False else (self.serialize_bytes(self.suggested_lang_code)),
            b'' if self.lang_pack_version is None or self.lang_pack_version is False else (struct.pack('<i', self.lang_pack_version)),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _phonecalls_enabled = bool(flags & 2)
        _default_p2p_contacts = bool(flags & 8)
        _preload_featured_stickers = bool(flags & 16)
        _ignore_phone_entities = bool(flags & 32)
        _revoke_pm_inbox = bool(flags & 64)
        _blocked_mode = bool(flags & 256)
        _date = reader.tgread_date()
        _expires = reader.tgread_date()
        _test_mode = reader.tgread_bool()
        _this_dc = reader.read_int()
        reader.read_int()
        _dc_options = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _dc_options.append(_x)

        _dc_txt_domain_name = reader.tgread_string()
        _chat_size_max = reader.read_int()
        _megagroup_size_max = reader.read_int()
        _forwarded_count_max = reader.read_int()
        _online_update_period_ms = reader.read_int()
        _offline_blur_timeout_ms = reader.read_int()
        _offline_idle_timeout_ms = reader.read_int()
        _online_cloud_timeout_ms = reader.read_int()
        _notify_cloud_delay_ms = reader.read_int()
        _notify_default_delay_ms = reader.read_int()
        _push_chat_period_ms = reader.read_int()
        _push_chat_limit = reader.read_int()
        _saved_gifs_limit = reader.read_int()
        _edit_time_limit = reader.read_int()
        _revoke_time_limit = reader.read_int()
        _revoke_pm_time_limit = reader.read_int()
        _rating_e_decay = reader.read_int()
        _stickers_recent_limit = reader.read_int()
        _stickers_faved_limit = reader.read_int()
        _channels_read_media_period = reader.read_int()
        if flags & 1:
            _tmp_sessions = reader.read_int()
        else:
            _tmp_sessions = None
        _pinned_dialogs_count_max = reader.read_int()
        _call_receive_timeout_ms = reader.read_int()
        _call_ring_timeout_ms = reader.read_int()
        _call_connect_timeout_ms = reader.read_int()
        _call_packet_timeout_ms = reader.read_int()
        _me_url_prefix = reader.tgread_string()
        if flags & 128:
            _autoupdate_url_prefix = reader.tgread_string()
        else:
            _autoupdate_url_prefix = None
        if flags & 512:
            _gif_search_username = reader.tgread_string()
        else:
            _gif_search_username = None
        if flags & 1024:
            _venue_search_username = reader.tgread_string()
        else:
            _venue_search_username = None
        if flags & 2048:
            _img_search_username = reader.tgread_string()
        else:
            _img_search_username = None
        if flags & 4096:
            _static_maps_provider = reader.tgread_string()
        else:
            _static_maps_provider = None
        _caption_length_max = reader.read_int()
        _message_length_max = reader.read_int()
        _webfile_dc_id = reader.read_int()
        if flags & 4:
            _suggested_lang_code = reader.tgread_string()
        else:
            _suggested_lang_code = None
        if flags & 4:
            _lang_pack_version = reader.read_int()
        else:
            _lang_pack_version = None
        return cls(date=_date, expires=_expires, test_mode=_test_mode, this_dc=_this_dc, dc_options=_dc_options, dc_txt_domain_name=_dc_txt_domain_name, chat_size_max=_chat_size_max, megagroup_size_max=_megagroup_size_max, forwarded_count_max=_forwarded_count_max, online_update_period_ms=_online_update_period_ms, offline_blur_timeout_ms=_offline_blur_timeout_ms, offline_idle_timeout_ms=_offline_idle_timeout_ms, online_cloud_timeout_ms=_online_cloud_timeout_ms, notify_cloud_delay_ms=_notify_cloud_delay_ms, notify_default_delay_ms=_notify_default_delay_ms, push_chat_period_ms=_push_chat_period_ms, push_chat_limit=_push_chat_limit, saved_gifs_limit=_saved_gifs_limit, edit_time_limit=_edit_time_limit, revoke_time_limit=_revoke_time_limit, revoke_pm_time_limit=_revoke_pm_time_limit, rating_e_decay=_rating_e_decay, stickers_recent_limit=_stickers_recent_limit, stickers_faved_limit=_stickers_faved_limit, channels_read_media_period=_channels_read_media_period, pinned_dialogs_count_max=_pinned_dialogs_count_max, call_receive_timeout_ms=_call_receive_timeout_ms, call_ring_timeout_ms=_call_ring_timeout_ms, call_connect_timeout_ms=_call_connect_timeout_ms, call_packet_timeout_ms=_call_packet_timeout_ms, me_url_prefix=_me_url_prefix, caption_length_max=_caption_length_max, message_length_max=_message_length_max, webfile_dc_id=_webfile_dc_id, phonecalls_enabled=_phonecalls_enabled, default_p2p_contacts=_default_p2p_contacts, preload_featured_stickers=_preload_featured_stickers, ignore_phone_entities=_ignore_phone_entities, revoke_pm_inbox=_revoke_pm_inbox, blocked_mode=_blocked_mode, tmp_sessions=_tmp_sessions, autoupdate_url_prefix=_autoupdate_url_prefix, gif_search_username=_gif_search_username, venue_search_username=_venue_search_username, img_search_username=_img_search_username, static_maps_provider=_static_maps_provider, suggested_lang_code=_suggested_lang_code, lang_pack_version=_lang_pack_version)


class Contact(TLObject):
    CONSTRUCTOR_ID = 0xf911c994
    SUBCLASS_OF_ID = 0x83dfdfa4

    def __init__(self, user_id, mutual):
        """
        :param int user_id:
        :param TypeBool mutual:

        Constructor for Contact: Instance of Contact.
        """
        self.user_id = user_id  # type: int
        self.mutual = mutual  # type: TypeBool

    def to_dict(self):
        return {
            '_': 'Contact',
            'user_id': self.user_id,
            'mutual': self.mutual
        }

    def __bytes__(self):
        return b''.join((
            b'\x94\xc9\x11\xf9',
            struct.pack('<i', self.user_id),
            b'\xb5ur\x99' if self.mutual else b'7\x97y\xbc',
        ))

    @classmethod
    def from_reader(cls, reader):
        _user_id = reader.read_int()
        _mutual = reader.tgread_bool()
        return cls(user_id=_user_id, mutual=_mutual)


class ContactBlocked(TLObject):
    CONSTRUCTOR_ID = 0x561bc879
    SUBCLASS_OF_ID = 0xb12d7ac6

    def __init__(self, user_id, date):
        """
        :param int user_id:
        :param Optional[datetime] date:

        Constructor for ContactBlocked: Instance of ContactBlocked.
        """
        self.user_id = user_id  # type: int
        self.date = date  # type: Optional[datetime]

    def to_dict(self):
        return {
            '_': 'ContactBlocked',
            'user_id': self.user_id,
            'date': self.date
        }

    def __bytes__(self):
        return b''.join((
            b'y\xc8\x1bV',
            struct.pack('<i', self.user_id),
            self.serialize_datetime(self.date),
        ))

    @classmethod
    def from_reader(cls, reader):
        _user_id = reader.read_int()
        _date = reader.tgread_date()
        return cls(user_id=_user_id, date=_date)


class ContactLinkContact(TLObject):
    CONSTRUCTOR_ID = 0xd502c2d0
    SUBCLASS_OF_ID = 0xa053c1da

    def to_dict(self):
        return {
            '_': 'ContactLinkContact'
        }

    def __bytes__(self):
        return b''.join((
            b'\xd0\xc2\x02\xd5',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class ContactLinkHasPhone(TLObject):
    CONSTRUCTOR_ID = 0x268f3f59
    SUBCLASS_OF_ID = 0xa053c1da

    def to_dict(self):
        return {
            '_': 'ContactLinkHasPhone'
        }

    def __bytes__(self):
        return b''.join((
            b'Y?\x8f&',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class ContactLinkNone(TLObject):
    CONSTRUCTOR_ID = 0xfeedd3ad
    SUBCLASS_OF_ID = 0xa053c1da

    def to_dict(self):
        return {
            '_': 'ContactLinkNone'
        }

    def __bytes__(self):
        return b''.join((
            b'\xad\xd3\xed\xfe',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class ContactLinkUnknown(TLObject):
    CONSTRUCTOR_ID = 0x5f4f9247
    SUBCLASS_OF_ID = 0xa053c1da

    def to_dict(self):
        return {
            '_': 'ContactLinkUnknown'
        }

    def __bytes__(self):
        return b''.join((
            b'G\x92O_',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class ContactStatus(TLObject):
    CONSTRUCTOR_ID = 0xd3680c61
    SUBCLASS_OF_ID = 0x68c0d74c

    def __init__(self, user_id, status):
        """
        :param int user_id:
        :param TypeUserStatus status:

        Constructor for ContactStatus: Instance of ContactStatus.
        """
        self.user_id = user_id  # type: int
        self.status = status  # type: TypeUserStatus

    def to_dict(self):
        return {
            '_': 'ContactStatus',
            'user_id': self.user_id,
            'status': None if self.status is None else self.status.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'a\x0ch\xd3',
            struct.pack('<i', self.user_id),
            bytes(self.status),
        ))

    @classmethod
    def from_reader(cls, reader):
        _user_id = reader.read_int()
        _status = reader.tgread_object()
        return cls(user_id=_user_id, status=_status)


class DataJSON(TLObject):
    CONSTRUCTOR_ID = 0x7d748d04
    SUBCLASS_OF_ID = 0xad0352e8

    def __init__(self, data):
        """
        :param str data:

        Constructor for DataJSON: Instance of DataJSON.
        """
        self.data = data  # type: str

    def to_dict(self):
        return {
            '_': 'DataJSON',
            'data': self.data
        }

    def __bytes__(self):
        return b''.join((
            b'\x04\x8dt}',
            self.serialize_bytes(self.data),
        ))

    @classmethod
    def from_reader(cls, reader):
        _data = reader.tgread_string()
        return cls(data=_data)


class DcOption(TLObject):
    CONSTRUCTOR_ID = 0x18b7a10d
    SUBCLASS_OF_ID = 0x9e43e123

    def __init__(self, id, ip_address, port, ipv6=None, media_only=None, tcpo_only=None, cdn=None, static=None, secret=None):
        """
        :param int id:
        :param str ip_address:
        :param int port:
        :param Optional[bool] ipv6:
        :param Optional[bool] media_only:
        :param Optional[bool] tcpo_only:
        :param Optional[bool] cdn:
        :param Optional[bool] static:
        :param Optional[bytes] secret:

        Constructor for DcOption: Instance of DcOption.
        """
        self.id = id  # type: int
        self.ip_address = ip_address  # type: str
        self.port = port  # type: int
        self.ipv6 = ipv6  # type: Optional[bool]
        self.media_only = media_only  # type: Optional[bool]
        self.tcpo_only = tcpo_only  # type: Optional[bool]
        self.cdn = cdn  # type: Optional[bool]
        self.static = static  # type: Optional[bool]
        self.secret = secret  # type: Optional[bytes]

    def to_dict(self):
        return {
            '_': 'DcOption',
            'id': self.id,
            'ip_address': self.ip_address,
            'port': self.port,
            'ipv6': self.ipv6,
            'media_only': self.media_only,
            'tcpo_only': self.tcpo_only,
            'cdn': self.cdn,
            'static': self.static,
            'secret': self.secret
        }

    def __bytes__(self):
        return b''.join((
            b'\r\xa1\xb7\x18',
            struct.pack('<I', (0 if self.ipv6 is None or self.ipv6 is False else 1) | (0 if self.media_only is None or self.media_only is False else 2) | (0 if self.tcpo_only is None or self.tcpo_only is False else 4) | (0 if self.cdn is None or self.cdn is False else 8) | (0 if self.static is None or self.static is False else 16) | (0 if self.secret is None or self.secret is False else 1024)),
            struct.pack('<i', self.id),
            self.serialize_bytes(self.ip_address),
            struct.pack('<i', self.port),
            b'' if self.secret is None or self.secret is False else (self.serialize_bytes(self.secret)),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _ipv6 = bool(flags & 1)
        _media_only = bool(flags & 2)
        _tcpo_only = bool(flags & 4)
        _cdn = bool(flags & 8)
        _static = bool(flags & 16)
        _id = reader.read_int()
        _ip_address = reader.tgread_string()
        _port = reader.read_int()
        if flags & 1024:
            _secret = reader.tgread_bytes()
        else:
            _secret = None
        return cls(id=_id, ip_address=_ip_address, port=_port, ipv6=_ipv6, media_only=_media_only, tcpo_only=_tcpo_only, cdn=_cdn, static=_static, secret=_secret)


class DestroySessionNone(TLObject):
    CONSTRUCTOR_ID = 0x62d350c9
    SUBCLASS_OF_ID = 0xaf0ce7bd

    def __init__(self, session_id):
        """
        :param int session_id:

        Constructor for DestroySessionRes: Instance of either DestroySessionOk, DestroySessionNone.
        """
        self.session_id = session_id  # type: int

    def to_dict(self):
        return {
            '_': 'DestroySessionNone',
            'session_id': self.session_id
        }

    def __bytes__(self):
        return b''.join((
            b'\xc9P\xd3b',
            struct.pack('<q', self.session_id),
        ))

    @classmethod
    def from_reader(cls, reader):
        _session_id = reader.read_long()
        return cls(session_id=_session_id)


class DestroySessionOk(TLObject):
    CONSTRUCTOR_ID = 0xe22045fc
    SUBCLASS_OF_ID = 0xaf0ce7bd

    def __init__(self, session_id):
        """
        :param int session_id:

        Constructor for DestroySessionRes: Instance of either DestroySessionOk, DestroySessionNone.
        """
        self.session_id = session_id  # type: int

    def to_dict(self):
        return {
            '_': 'DestroySessionOk',
            'session_id': self.session_id
        }

    def __bytes__(self):
        return b''.join((
            b'\xfcE \xe2',
            struct.pack('<q', self.session_id),
        ))

    @classmethod
    def from_reader(cls, reader):
        _session_id = reader.read_long()
        return cls(session_id=_session_id)


class DhGenFail(TLObject):
    CONSTRUCTOR_ID = 0xa69dae02
    SUBCLASS_OF_ID = 0x55dd6cdb

    def __init__(self, nonce, server_nonce, new_nonce_hash3):
        """
        :param int nonce:
        :param int server_nonce:
        :param int new_nonce_hash3:

        Constructor for Set_client_DH_params_answer: Instance of either DhGenOk, DhGenRetry, DhGenFail.
        """
        self.nonce = nonce  # type: int
        self.server_nonce = server_nonce  # type: int
        self.new_nonce_hash3 = new_nonce_hash3  # type: int

    def to_dict(self):
        return {
            '_': 'DhGenFail',
            'nonce': self.nonce,
            'server_nonce': self.server_nonce,
            'new_nonce_hash3': self.new_nonce_hash3
        }

    def __bytes__(self):
        return b''.join((
            b'\x02\xae\x9d\xa6',
            self.nonce.to_bytes(16, 'little', signed=True),
            self.server_nonce.to_bytes(16, 'little', signed=True),
            self.new_nonce_hash3.to_bytes(16, 'little', signed=True),
        ))

    @classmethod
    def from_reader(cls, reader):
        _nonce = reader.read_large_int(bits=128)
        _server_nonce = reader.read_large_int(bits=128)
        _new_nonce_hash3 = reader.read_large_int(bits=128)
        return cls(nonce=_nonce, server_nonce=_server_nonce, new_nonce_hash3=_new_nonce_hash3)


class DhGenOk(TLObject):
    CONSTRUCTOR_ID = 0x3bcbf734
    SUBCLASS_OF_ID = 0x55dd6cdb

    def __init__(self, nonce, server_nonce, new_nonce_hash1):
        """
        :param int nonce:
        :param int server_nonce:
        :param int new_nonce_hash1:

        Constructor for Set_client_DH_params_answer: Instance of either DhGenOk, DhGenRetry, DhGenFail.
        """
        self.nonce = nonce  # type: int
        self.server_nonce = server_nonce  # type: int
        self.new_nonce_hash1 = new_nonce_hash1  # type: int

    def to_dict(self):
        return {
            '_': 'DhGenOk',
            'nonce': self.nonce,
            'server_nonce': self.server_nonce,
            'new_nonce_hash1': self.new_nonce_hash1
        }

    def __bytes__(self):
        return b''.join((
            b'4\xf7\xcb;',
            self.nonce.to_bytes(16, 'little', signed=True),
            self.server_nonce.to_bytes(16, 'little', signed=True),
            self.new_nonce_hash1.to_bytes(16, 'little', signed=True),
        ))

    @classmethod
    def from_reader(cls, reader):
        _nonce = reader.read_large_int(bits=128)
        _server_nonce = reader.read_large_int(bits=128)
        _new_nonce_hash1 = reader.read_large_int(bits=128)
        return cls(nonce=_nonce, server_nonce=_server_nonce, new_nonce_hash1=_new_nonce_hash1)


class DhGenRetry(TLObject):
    CONSTRUCTOR_ID = 0x46dc1fb9
    SUBCLASS_OF_ID = 0x55dd6cdb

    def __init__(self, nonce, server_nonce, new_nonce_hash2):
        """
        :param int nonce:
        :param int server_nonce:
        :param int new_nonce_hash2:

        Constructor for Set_client_DH_params_answer: Instance of either DhGenOk, DhGenRetry, DhGenFail.
        """
        self.nonce = nonce  # type: int
        self.server_nonce = server_nonce  # type: int
        self.new_nonce_hash2 = new_nonce_hash2  # type: int

    def to_dict(self):
        return {
            '_': 'DhGenRetry',
            'nonce': self.nonce,
            'server_nonce': self.server_nonce,
            'new_nonce_hash2': self.new_nonce_hash2
        }

    def __bytes__(self):
        return b''.join((
            b'\xb9\x1f\xdcF',
            self.nonce.to_bytes(16, 'little', signed=True),
            self.server_nonce.to_bytes(16, 'little', signed=True),
            self.new_nonce_hash2.to_bytes(16, 'little', signed=True),
        ))

    @classmethod
    def from_reader(cls, reader):
        _nonce = reader.read_large_int(bits=128)
        _server_nonce = reader.read_large_int(bits=128)
        _new_nonce_hash2 = reader.read_large_int(bits=128)
        return cls(nonce=_nonce, server_nonce=_server_nonce, new_nonce_hash2=_new_nonce_hash2)


class Dialog(TLObject):
    CONSTRUCTOR_ID = 0xe4def5db
    SUBCLASS_OF_ID = 0x42cddd54

    def __init__(self, peer, top_message, read_inbox_max_id, read_outbox_max_id, unread_count, unread_mentions_count, notify_settings, pinned=None, unread_mark=None, pts=None, draft=None):
        """
        :param TypePeer peer:
        :param int top_message:
        :param int read_inbox_max_id:
        :param int read_outbox_max_id:
        :param int unread_count:
        :param int unread_mentions_count:
        :param TypePeerNotifySettings notify_settings:
        :param Optional[bool] pinned:
        :param Optional[bool] unread_mark:
        :param Optional[int] pts:
        :param Optional[TypeDraftMessage] draft:

        Constructor for Dialog: Instance of Dialog.
        """
        self.peer = peer  # type: TypePeer
        self.top_message = top_message  # type: int
        self.read_inbox_max_id = read_inbox_max_id  # type: int
        self.read_outbox_max_id = read_outbox_max_id  # type: int
        self.unread_count = unread_count  # type: int
        self.unread_mentions_count = unread_mentions_count  # type: int
        self.notify_settings = notify_settings  # type: TypePeerNotifySettings
        self.pinned = pinned  # type: Optional[bool]
        self.unread_mark = unread_mark  # type: Optional[bool]
        self.pts = pts  # type: Optional[int]
        self.draft = draft  # type: Optional[TypeDraftMessage]

    def to_dict(self):
        return {
            '_': 'Dialog',
            'peer': None if self.peer is None else self.peer.to_dict(),
            'top_message': self.top_message,
            'read_inbox_max_id': self.read_inbox_max_id,
            'read_outbox_max_id': self.read_outbox_max_id,
            'unread_count': self.unread_count,
            'unread_mentions_count': self.unread_mentions_count,
            'notify_settings': None if self.notify_settings is None else self.notify_settings.to_dict(),
            'pinned': self.pinned,
            'unread_mark': self.unread_mark,
            'pts': self.pts,
            'draft': None if self.draft is None else self.draft.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\xdb\xf5\xde\xe4',
            struct.pack('<I', (0 if self.pinned is None or self.pinned is False else 4) | (0 if self.unread_mark is None or self.unread_mark is False else 8) | (0 if self.pts is None or self.pts is False else 1) | (0 if self.draft is None or self.draft is False else 2)),
            bytes(self.peer),
            struct.pack('<i', self.top_message),
            struct.pack('<i', self.read_inbox_max_id),
            struct.pack('<i', self.read_outbox_max_id),
            struct.pack('<i', self.unread_count),
            struct.pack('<i', self.unread_mentions_count),
            bytes(self.notify_settings),
            b'' if self.pts is None or self.pts is False else (struct.pack('<i', self.pts)),
            b'' if self.draft is None or self.draft is False else (bytes(self.draft)),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _pinned = bool(flags & 4)
        _unread_mark = bool(flags & 8)
        _peer = reader.tgread_object()
        _top_message = reader.read_int()
        _read_inbox_max_id = reader.read_int()
        _read_outbox_max_id = reader.read_int()
        _unread_count = reader.read_int()
        _unread_mentions_count = reader.read_int()
        _notify_settings = reader.tgread_object()
        if flags & 1:
            _pts = reader.read_int()
        else:
            _pts = None
        if flags & 2:
            _draft = reader.tgread_object()
        else:
            _draft = None
        return cls(peer=_peer, top_message=_top_message, read_inbox_max_id=_read_inbox_max_id, read_outbox_max_id=_read_outbox_max_id, unread_count=_unread_count, unread_mentions_count=_unread_mentions_count, notify_settings=_notify_settings, pinned=_pinned, unread_mark=_unread_mark, pts=_pts, draft=_draft)


class DialogPeer(TLObject):
    CONSTRUCTOR_ID = 0xe56dbf05
    SUBCLASS_OF_ID = 0x256ce1ae

    def __init__(self, peer):
        """
        :param TypePeer peer:

        Constructor for DialogPeer: Instance of DialogPeer.
        """
        self.peer = peer  # type: TypePeer

    def to_dict(self):
        return {
            '_': 'DialogPeer',
            'peer': None if self.peer is None else self.peer.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\x05\xbfm\xe5',
            bytes(self.peer),
        ))

    @classmethod
    def from_reader(cls, reader):
        _peer = reader.tgread_object()
        return cls(peer=_peer)


class Document(TLObject):
    CONSTRUCTOR_ID = 0x87232bc7
    SUBCLASS_OF_ID = 0x211fe820

    def __init__(self, id, access_hash, date, mime_type, size, thumb, dc_id, version, attributes):
        """
        :param int id:
        :param int access_hash:
        :param Optional[datetime] date:
        :param str mime_type:
        :param int size:
        :param TypePhotoSize thumb:
        :param int dc_id:
        :param int version:
        :param List[TypeDocumentAttribute] attributes:

        Constructor for Document: Instance of either DocumentEmpty, Document.
        """
        self.id = id  # type: int
        self.access_hash = access_hash  # type: int
        self.date = date  # type: Optional[datetime]
        self.mime_type = mime_type  # type: str
        self.size = size  # type: int
        self.thumb = thumb  # type: TypePhotoSize
        self.dc_id = dc_id  # type: int
        self.version = version  # type: int
        self.attributes = attributes  # type: List[TypeDocumentAttribute]

    def to_dict(self):
        return {
            '_': 'Document',
            'id': self.id,
            'access_hash': self.access_hash,
            'date': self.date,
            'mime_type': self.mime_type,
            'size': self.size,
            'thumb': None if self.thumb is None else self.thumb.to_dict(),
            'dc_id': self.dc_id,
            'version': self.version,
            'attributes': [] if self.attributes is None else [None if x is None else x.to_dict() for x in self.attributes]
        }

    def __bytes__(self):
        return b''.join((
            b'\xc7+#\x87',
            struct.pack('<q', self.id),
            struct.pack('<q', self.access_hash),
            self.serialize_datetime(self.date),
            self.serialize_bytes(self.mime_type),
            struct.pack('<i', self.size),
            bytes(self.thumb),
            struct.pack('<i', self.dc_id),
            struct.pack('<i', self.version),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.attributes)),b''.join(bytes(x) for x in self.attributes),
        ))

    @classmethod
    def from_reader(cls, reader):
        _id = reader.read_long()
        _access_hash = reader.read_long()
        _date = reader.tgread_date()
        _mime_type = reader.tgread_string()
        _size = reader.read_int()
        _thumb = reader.tgread_object()
        _dc_id = reader.read_int()
        _version = reader.read_int()
        reader.read_int()
        _attributes = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _attributes.append(_x)

        return cls(id=_id, access_hash=_access_hash, date=_date, mime_type=_mime_type, size=_size, thumb=_thumb, dc_id=_dc_id, version=_version, attributes=_attributes)


class DocumentAttributeAnimated(TLObject):
    CONSTRUCTOR_ID = 0x11b58939
    SUBCLASS_OF_ID = 0xf729eb9b

    def to_dict(self):
        return {
            '_': 'DocumentAttributeAnimated'
        }

    def __bytes__(self):
        return b''.join((
            b'9\x89\xb5\x11',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class DocumentAttributeAudio(TLObject):
    CONSTRUCTOR_ID = 0x9852f9c6
    SUBCLASS_OF_ID = 0xf729eb9b

    def __init__(self, duration, voice=None, title=None, performer=None, waveform=None):
        """
        :param int duration:
        :param Optional[bool] voice:
        :param Optional[str] title:
        :param Optional[str] performer:
        :param Optional[bytes] waveform:

        Constructor for DocumentAttribute: Instance of either DocumentAttributeImageSize, DocumentAttributeAnimated, DocumentAttributeSticker, DocumentAttributeVideo, DocumentAttributeAudio, DocumentAttributeFilename, DocumentAttributeHasStickers.
        """
        self.duration = duration  # type: int
        self.voice = voice  # type: Optional[bool]
        self.title = title  # type: Optional[str]
        self.performer = performer  # type: Optional[str]
        self.waveform = waveform  # type: Optional[bytes]

    def to_dict(self):
        return {
            '_': 'DocumentAttributeAudio',
            'duration': self.duration,
            'voice': self.voice,
            'title': self.title,
            'performer': self.performer,
            'waveform': self.waveform
        }

    def __bytes__(self):
        return b''.join((
            b'\xc6\xf9R\x98',
            struct.pack('<I', (0 if self.voice is None or self.voice is False else 1024) | (0 if self.title is None or self.title is False else 1) | (0 if self.performer is None or self.performer is False else 2) | (0 if self.waveform is None or self.waveform is False else 4)),
            struct.pack('<i', self.duration),
            b'' if self.title is None or self.title is False else (self.serialize_bytes(self.title)),
            b'' if self.performer is None or self.performer is False else (self.serialize_bytes(self.performer)),
            b'' if self.waveform is None or self.waveform is False else (self.serialize_bytes(self.waveform)),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _voice = bool(flags & 1024)
        _duration = reader.read_int()
        if flags & 1:
            _title = reader.tgread_string()
        else:
            _title = None
        if flags & 2:
            _performer = reader.tgread_string()
        else:
            _performer = None
        if flags & 4:
            _waveform = reader.tgread_bytes()
        else:
            _waveform = None
        return cls(duration=_duration, voice=_voice, title=_title, performer=_performer, waveform=_waveform)


class DocumentAttributeFilename(TLObject):
    CONSTRUCTOR_ID = 0x15590068
    SUBCLASS_OF_ID = 0xf729eb9b

    def __init__(self, file_name):
        """
        :param str file_name:

        Constructor for DocumentAttribute: Instance of either DocumentAttributeImageSize, DocumentAttributeAnimated, DocumentAttributeSticker, DocumentAttributeVideo, DocumentAttributeAudio, DocumentAttributeFilename, DocumentAttributeHasStickers.
        """
        self.file_name = file_name  # type: str

    def to_dict(self):
        return {
            '_': 'DocumentAttributeFilename',
            'file_name': self.file_name
        }

    def __bytes__(self):
        return b''.join((
            b'h\x00Y\x15',
            self.serialize_bytes(self.file_name),
        ))

    @classmethod
    def from_reader(cls, reader):
        _file_name = reader.tgread_string()
        return cls(file_name=_file_name)


class DocumentAttributeHasStickers(TLObject):
    CONSTRUCTOR_ID = 0x9801d2f7
    SUBCLASS_OF_ID = 0xf729eb9b

    def to_dict(self):
        return {
            '_': 'DocumentAttributeHasStickers'
        }

    def __bytes__(self):
        return b''.join((
            b'\xf7\xd2\x01\x98',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class DocumentAttributeImageSize(TLObject):
    CONSTRUCTOR_ID = 0x6c37c15c
    SUBCLASS_OF_ID = 0xf729eb9b

    def __init__(self, w, h):
        """
        :param int w:
        :param int h:

        Constructor for DocumentAttribute: Instance of either DocumentAttributeImageSize, DocumentAttributeAnimated, DocumentAttributeSticker, DocumentAttributeVideo, DocumentAttributeAudio, DocumentAttributeFilename, DocumentAttributeHasStickers.
        """
        self.w = w  # type: int
        self.h = h  # type: int

    def to_dict(self):
        return {
            '_': 'DocumentAttributeImageSize',
            'w': self.w,
            'h': self.h
        }

    def __bytes__(self):
        return b''.join((
            b'\\\xc17l',
            struct.pack('<i', self.w),
            struct.pack('<i', self.h),
        ))

    @classmethod
    def from_reader(cls, reader):
        _w = reader.read_int()
        _h = reader.read_int()
        return cls(w=_w, h=_h)


class DocumentAttributeSticker(TLObject):
    CONSTRUCTOR_ID = 0x6319d612
    SUBCLASS_OF_ID = 0xf729eb9b

    def __init__(self, alt, stickerset, mask=None, mask_coords=None):
        """
        :param str alt:
        :param TypeInputStickerSet stickerset:
        :param Optional[bool] mask:
        :param Optional[TypeMaskCoords] mask_coords:

        Constructor for DocumentAttribute: Instance of either DocumentAttributeImageSize, DocumentAttributeAnimated, DocumentAttributeSticker, DocumentAttributeVideo, DocumentAttributeAudio, DocumentAttributeFilename, DocumentAttributeHasStickers.
        """
        self.alt = alt  # type: str
        self.stickerset = stickerset  # type: TypeInputStickerSet
        self.mask = mask  # type: Optional[bool]
        self.mask_coords = mask_coords  # type: Optional[TypeMaskCoords]

    def to_dict(self):
        return {
            '_': 'DocumentAttributeSticker',
            'alt': self.alt,
            'stickerset': None if self.stickerset is None else self.stickerset.to_dict(),
            'mask': self.mask,
            'mask_coords': None if self.mask_coords is None else self.mask_coords.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\x12\xd6\x19c',
            struct.pack('<I', (0 if self.mask is None or self.mask is False else 2) | (0 if self.mask_coords is None or self.mask_coords is False else 1)),
            self.serialize_bytes(self.alt),
            bytes(self.stickerset),
            b'' if self.mask_coords is None or self.mask_coords is False else (bytes(self.mask_coords)),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _mask = bool(flags & 2)
        _alt = reader.tgread_string()
        _stickerset = reader.tgread_object()
        if flags & 1:
            _mask_coords = reader.tgread_object()
        else:
            _mask_coords = None
        return cls(alt=_alt, stickerset=_stickerset, mask=_mask, mask_coords=_mask_coords)


class DocumentAttributeVideo(TLObject):
    CONSTRUCTOR_ID = 0xef02ce6
    SUBCLASS_OF_ID = 0xf729eb9b

    def __init__(self, duration, w, h, round_message=None, supports_streaming=None):
        """
        :param int duration:
        :param int w:
        :param int h:
        :param Optional[bool] round_message:
        :param Optional[bool] supports_streaming:

        Constructor for DocumentAttribute: Instance of either DocumentAttributeImageSize, DocumentAttributeAnimated, DocumentAttributeSticker, DocumentAttributeVideo, DocumentAttributeAudio, DocumentAttributeFilename, DocumentAttributeHasStickers.
        """
        self.duration = duration  # type: int
        self.w = w  # type: int
        self.h = h  # type: int
        self.round_message = round_message  # type: Optional[bool]
        self.supports_streaming = supports_streaming  # type: Optional[bool]

    def to_dict(self):
        return {
            '_': 'DocumentAttributeVideo',
            'duration': self.duration,
            'w': self.w,
            'h': self.h,
            'round_message': self.round_message,
            'supports_streaming': self.supports_streaming
        }

    def __bytes__(self):
        return b''.join((
            b'\xe6,\xf0\x0e',
            struct.pack('<I', (0 if self.round_message is None or self.round_message is False else 1) | (0 if self.supports_streaming is None or self.supports_streaming is False else 2)),
            struct.pack('<i', self.duration),
            struct.pack('<i', self.w),
            struct.pack('<i', self.h),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _round_message = bool(flags & 1)
        _supports_streaming = bool(flags & 2)
        _duration = reader.read_int()
        _w = reader.read_int()
        _h = reader.read_int()
        return cls(duration=_duration, w=_w, h=_h, round_message=_round_message, supports_streaming=_supports_streaming)


class DocumentEmpty(TLObject):
    CONSTRUCTOR_ID = 0x36f8c871
    SUBCLASS_OF_ID = 0x211fe820

    def __init__(self, id):
        """
        :param int id:

        Constructor for Document: Instance of either DocumentEmpty, Document.
        """
        self.id = id  # type: int

    def to_dict(self):
        return {
            '_': 'DocumentEmpty',
            'id': self.id
        }

    def __bytes__(self):
        return b''.join((
            b'q\xc8\xf86',
            struct.pack('<q', self.id),
        ))

    @classmethod
    def from_reader(cls, reader):
        _id = reader.read_long()
        return cls(id=_id)


class DraftMessage(TLObject):
    CONSTRUCTOR_ID = 0xfd8e711f
    SUBCLASS_OF_ID = 0x33d47f45

    def __init__(self, message, date, no_webpage=None, reply_to_msg_id=None, entities=None):
        """
        :param str message:
        :param Optional[datetime] date:
        :param Optional[bool] no_webpage:
        :param Optional[int] reply_to_msg_id:
        :param Optional[List[TypeMessageEntity]] entities:

        Constructor for DraftMessage: Instance of either DraftMessageEmpty, DraftMessage.
        """
        self.message = message  # type: str
        self.date = date  # type: Optional[datetime]
        self.no_webpage = no_webpage  # type: Optional[bool]
        self.reply_to_msg_id = reply_to_msg_id  # type: Optional[int]
        self.entities = entities  # type: Optional[List[TypeMessageEntity]]

    def to_dict(self):
        return {
            '_': 'DraftMessage',
            'message': self.message,
            'date': self.date,
            'no_webpage': self.no_webpage,
            'reply_to_msg_id': self.reply_to_msg_id,
            'entities': [] if self.entities is None else [None if x is None else x.to_dict() for x in self.entities]
        }

    def __bytes__(self):
        return b''.join((
            b'\x1fq\x8e\xfd',
            struct.pack('<I', (0 if self.no_webpage is None or self.no_webpage is False else 2) | (0 if self.reply_to_msg_id is None or self.reply_to_msg_id is False else 1) | (0 if self.entities is None or self.entities is False else 8)),
            b'' if self.reply_to_msg_id is None or self.reply_to_msg_id is False else (struct.pack('<i', self.reply_to_msg_id)),
            self.serialize_bytes(self.message),
            b'' if self.entities is None or self.entities is False else b''.join((b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.entities)),b''.join(bytes(x) for x in self.entities))),
            self.serialize_datetime(self.date),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _no_webpage = bool(flags & 2)
        if flags & 1:
            _reply_to_msg_id = reader.read_int()
        else:
            _reply_to_msg_id = None
        _message = reader.tgread_string()
        if flags & 8:
            reader.read_int()
            _entities = []
            for _ in range(reader.read_int()):
                _x = reader.tgread_object()
                _entities.append(_x)

        else:
            _entities = None
        _date = reader.tgread_date()
        return cls(message=_message, date=_date, no_webpage=_no_webpage, reply_to_msg_id=_reply_to_msg_id, entities=_entities)


class DraftMessageEmpty(TLObject):
    CONSTRUCTOR_ID = 0x1b0c841a
    SUBCLASS_OF_ID = 0x33d47f45

    def __init__(self, date=None):
        """
        :param Optional[datetime] date:

        Constructor for DraftMessage: Instance of either DraftMessageEmpty, DraftMessage.
        """
        self.date = date  # type: Optional[datetime]

    def to_dict(self):
        return {
            '_': 'DraftMessageEmpty',
            'date': self.date
        }

    def __bytes__(self):
        return b''.join((
            b'\x1a\x84\x0c\x1b',
            struct.pack('<I', (0 if self.date is None or self.date is False else 1)),
            b'' if self.date is None or self.date is False else (self.serialize_datetime(self.date)),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        if flags & 1:
            _date = reader.tgread_date()
        else:
            _date = None
        return cls(date=_date)


class DummyHttpWait(TLObject):
    CONSTRUCTOR_ID = 0xc937ca2e
    SUBCLASS_OF_ID = 0x1284aed6

    def to_dict(self):
        return {
            '_': 'DummyHttpWait'
        }

    def __bytes__(self):
        return b''.join((
            b'.\xca7\xc9',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class EncryptedChat(TLObject):
    CONSTRUCTOR_ID = 0xfa56ce36
    SUBCLASS_OF_ID = 0x6d28a37a

    def __init__(self, id, access_hash, date, admin_id, participant_id, g_a_or_b, key_fingerprint):
        """
        :param int id:
        :param int access_hash:
        :param Optional[datetime] date:
        :param int admin_id:
        :param int participant_id:
        :param bytes g_a_or_b:
        :param int key_fingerprint:

        Constructor for EncryptedChat: Instance of either EncryptedChatEmpty, EncryptedChatWaiting, EncryptedChatRequested, EncryptedChat, EncryptedChatDiscarded.
        """
        self.id = id  # type: int
        self.access_hash = access_hash  # type: int
        self.date = date  # type: Optional[datetime]
        self.admin_id = admin_id  # type: int
        self.participant_id = participant_id  # type: int
        self.g_a_or_b = g_a_or_b  # type: bytes
        self.key_fingerprint = key_fingerprint  # type: int

    def to_dict(self):
        return {
            '_': 'EncryptedChat',
            'id': self.id,
            'access_hash': self.access_hash,
            'date': self.date,
            'admin_id': self.admin_id,
            'participant_id': self.participant_id,
            'g_a_or_b': self.g_a_or_b,
            'key_fingerprint': self.key_fingerprint
        }

    def __bytes__(self):
        return b''.join((
            b'6\xceV\xfa',
            struct.pack('<i', self.id),
            struct.pack('<q', self.access_hash),
            self.serialize_datetime(self.date),
            struct.pack('<i', self.admin_id),
            struct.pack('<i', self.participant_id),
            self.serialize_bytes(self.g_a_or_b),
            struct.pack('<q', self.key_fingerprint),
        ))

    @classmethod
    def from_reader(cls, reader):
        _id = reader.read_int()
        _access_hash = reader.read_long()
        _date = reader.tgread_date()
        _admin_id = reader.read_int()
        _participant_id = reader.read_int()
        _g_a_or_b = reader.tgread_bytes()
        _key_fingerprint = reader.read_long()
        return cls(id=_id, access_hash=_access_hash, date=_date, admin_id=_admin_id, participant_id=_participant_id, g_a_or_b=_g_a_or_b, key_fingerprint=_key_fingerprint)


class EncryptedChatDiscarded(TLObject):
    CONSTRUCTOR_ID = 0x13d6dd27
    SUBCLASS_OF_ID = 0x6d28a37a

    def __init__(self, id):
        """
        :param int id:

        Constructor for EncryptedChat: Instance of either EncryptedChatEmpty, EncryptedChatWaiting, EncryptedChatRequested, EncryptedChat, EncryptedChatDiscarded.
        """
        self.id = id  # type: int

    def to_dict(self):
        return {
            '_': 'EncryptedChatDiscarded',
            'id': self.id
        }

    def __bytes__(self):
        return b''.join((
            b"'\xdd\xd6\x13",
            struct.pack('<i', self.id),
        ))

    @classmethod
    def from_reader(cls, reader):
        _id = reader.read_int()
        return cls(id=_id)


class EncryptedChatEmpty(TLObject):
    CONSTRUCTOR_ID = 0xab7ec0a0
    SUBCLASS_OF_ID = 0x6d28a37a

    def __init__(self, id):
        """
        :param int id:

        Constructor for EncryptedChat: Instance of either EncryptedChatEmpty, EncryptedChatWaiting, EncryptedChatRequested, EncryptedChat, EncryptedChatDiscarded.
        """
        self.id = id  # type: int

    def to_dict(self):
        return {
            '_': 'EncryptedChatEmpty',
            'id': self.id
        }

    def __bytes__(self):
        return b''.join((
            b'\xa0\xc0~\xab',
            struct.pack('<i', self.id),
        ))

    @classmethod
    def from_reader(cls, reader):
        _id = reader.read_int()
        return cls(id=_id)


class EncryptedChatRequested(TLObject):
    CONSTRUCTOR_ID = 0xc878527e
    SUBCLASS_OF_ID = 0x6d28a37a

    def __init__(self, id, access_hash, date, admin_id, participant_id, g_a):
        """
        :param int id:
        :param int access_hash:
        :param Optional[datetime] date:
        :param int admin_id:
        :param int participant_id:
        :param bytes g_a:

        Constructor for EncryptedChat: Instance of either EncryptedChatEmpty, EncryptedChatWaiting, EncryptedChatRequested, EncryptedChat, EncryptedChatDiscarded.
        """
        self.id = id  # type: int
        self.access_hash = access_hash  # type: int
        self.date = date  # type: Optional[datetime]
        self.admin_id = admin_id  # type: int
        self.participant_id = participant_id  # type: int
        self.g_a = g_a  # type: bytes

    def to_dict(self):
        return {
            '_': 'EncryptedChatRequested',
            'id': self.id,
            'access_hash': self.access_hash,
            'date': self.date,
            'admin_id': self.admin_id,
            'participant_id': self.participant_id,
            'g_a': self.g_a
        }

    def __bytes__(self):
        return b''.join((
            b'~Rx\xc8',
            struct.pack('<i', self.id),
            struct.pack('<q', self.access_hash),
            self.serialize_datetime(self.date),
            struct.pack('<i', self.admin_id),
            struct.pack('<i', self.participant_id),
            self.serialize_bytes(self.g_a),
        ))

    @classmethod
    def from_reader(cls, reader):
        _id = reader.read_int()
        _access_hash = reader.read_long()
        _date = reader.tgread_date()
        _admin_id = reader.read_int()
        _participant_id = reader.read_int()
        _g_a = reader.tgread_bytes()
        return cls(id=_id, access_hash=_access_hash, date=_date, admin_id=_admin_id, participant_id=_participant_id, g_a=_g_a)


class EncryptedChatWaiting(TLObject):
    CONSTRUCTOR_ID = 0x3bf703dc
    SUBCLASS_OF_ID = 0x6d28a37a

    def __init__(self, id, access_hash, date, admin_id, participant_id):
        """
        :param int id:
        :param int access_hash:
        :param Optional[datetime] date:
        :param int admin_id:
        :param int participant_id:

        Constructor for EncryptedChat: Instance of either EncryptedChatEmpty, EncryptedChatWaiting, EncryptedChatRequested, EncryptedChat, EncryptedChatDiscarded.
        """
        self.id = id  # type: int
        self.access_hash = access_hash  # type: int
        self.date = date  # type: Optional[datetime]
        self.admin_id = admin_id  # type: int
        self.participant_id = participant_id  # type: int

    def to_dict(self):
        return {
            '_': 'EncryptedChatWaiting',
            'id': self.id,
            'access_hash': self.access_hash,
            'date': self.date,
            'admin_id': self.admin_id,
            'participant_id': self.participant_id
        }

    def __bytes__(self):
        return b''.join((
            b'\xdc\x03\xf7;',
            struct.pack('<i', self.id),
            struct.pack('<q', self.access_hash),
            self.serialize_datetime(self.date),
            struct.pack('<i', self.admin_id),
            struct.pack('<i', self.participant_id),
        ))

    @classmethod
    def from_reader(cls, reader):
        _id = reader.read_int()
        _access_hash = reader.read_long()
        _date = reader.tgread_date()
        _admin_id = reader.read_int()
        _participant_id = reader.read_int()
        return cls(id=_id, access_hash=_access_hash, date=_date, admin_id=_admin_id, participant_id=_participant_id)


class EncryptedFile(TLObject):
    CONSTRUCTOR_ID = 0x4a70994c
    SUBCLASS_OF_ID = 0x842a67c0

    def __init__(self, id, access_hash, size, dc_id, key_fingerprint):
        """
        :param int id:
        :param int access_hash:
        :param int size:
        :param int dc_id:
        :param int key_fingerprint:

        Constructor for EncryptedFile: Instance of either EncryptedFileEmpty, EncryptedFile.
        """
        self.id = id  # type: int
        self.access_hash = access_hash  # type: int
        self.size = size  # type: int
        self.dc_id = dc_id  # type: int
        self.key_fingerprint = key_fingerprint  # type: int

    def to_dict(self):
        return {
            '_': 'EncryptedFile',
            'id': self.id,
            'access_hash': self.access_hash,
            'size': self.size,
            'dc_id': self.dc_id,
            'key_fingerprint': self.key_fingerprint
        }

    def __bytes__(self):
        return b''.join((
            b'L\x99pJ',
            struct.pack('<q', self.id),
            struct.pack('<q', self.access_hash),
            struct.pack('<i', self.size),
            struct.pack('<i', self.dc_id),
            struct.pack('<i', self.key_fingerprint),
        ))

    @classmethod
    def from_reader(cls, reader):
        _id = reader.read_long()
        _access_hash = reader.read_long()
        _size = reader.read_int()
        _dc_id = reader.read_int()
        _key_fingerprint = reader.read_int()
        return cls(id=_id, access_hash=_access_hash, size=_size, dc_id=_dc_id, key_fingerprint=_key_fingerprint)


class EncryptedFileEmpty(TLObject):
    CONSTRUCTOR_ID = 0xc21f497e
    SUBCLASS_OF_ID = 0x842a67c0

    def to_dict(self):
        return {
            '_': 'EncryptedFileEmpty'
        }

    def __bytes__(self):
        return b''.join((
            b'~I\x1f\xc2',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class EncryptedMessage(TLObject):
    CONSTRUCTOR_ID = 0xed18c118
    SUBCLASS_OF_ID = 0x239f2e51

    def __init__(self, chat_id, date, bytes, file, random_id=None):
        """
        :param int chat_id:
        :param Optional[datetime] date:
        :param bytes bytes:
        :param TypeEncryptedFile file:
        :param int random_id:

        Constructor for EncryptedMessage: Instance of either EncryptedMessage, EncryptedMessageService.
        """
        self.chat_id = chat_id  # type: int
        self.date = date  # type: Optional[datetime]
        self.bytes = bytes  # type: bytes
        self.file = file  # type: TypeEncryptedFile
        self.random_id = random_id if random_id is not None else int.from_bytes(os.urandom(8), 'big', signed=True)

    def to_dict(self):
        return {
            '_': 'EncryptedMessage',
            'chat_id': self.chat_id,
            'date': self.date,
            'bytes': self.bytes,
            'file': None if self.file is None else self.file.to_dict(),
            'random_id': self.random_id
        }

    def __bytes__(self):
        return b''.join((
            b'\x18\xc1\x18\xed',
            struct.pack('<q', self.random_id),
            struct.pack('<i', self.chat_id),
            self.serialize_datetime(self.date),
            self.serialize_bytes(self.bytes),
            bytes(self.file),
        ))

    @classmethod
    def from_reader(cls, reader):
        _random_id = reader.read_long()
        _chat_id = reader.read_int()
        _date = reader.tgread_date()
        _bytes = reader.tgread_bytes()
        _file = reader.tgread_object()
        return cls(chat_id=_chat_id, date=_date, bytes=_bytes, file=_file, random_id=_random_id)


class EncryptedMessageService(TLObject):
    CONSTRUCTOR_ID = 0x23734b06
    SUBCLASS_OF_ID = 0x239f2e51

    def __init__(self, chat_id, date, bytes, random_id=None):
        """
        :param int chat_id:
        :param Optional[datetime] date:
        :param bytes bytes:
        :param int random_id:

        Constructor for EncryptedMessage: Instance of either EncryptedMessage, EncryptedMessageService.
        """
        self.chat_id = chat_id  # type: int
        self.date = date  # type: Optional[datetime]
        self.bytes = bytes  # type: bytes
        self.random_id = random_id if random_id is not None else int.from_bytes(os.urandom(8), 'big', signed=True)

    def to_dict(self):
        return {
            '_': 'EncryptedMessageService',
            'chat_id': self.chat_id,
            'date': self.date,
            'bytes': self.bytes,
            'random_id': self.random_id
        }

    def __bytes__(self):
        return b''.join((
            b'\x06Ks#',
            struct.pack('<q', self.random_id),
            struct.pack('<i', self.chat_id),
            self.serialize_datetime(self.date),
            self.serialize_bytes(self.bytes),
        ))

    @classmethod
    def from_reader(cls, reader):
        _random_id = reader.read_long()
        _chat_id = reader.read_int()
        _date = reader.tgread_date()
        _bytes = reader.tgread_bytes()
        return cls(chat_id=_chat_id, date=_date, bytes=_bytes, random_id=_random_id)


class Error(TLObject):
    CONSTRUCTOR_ID = 0xc4b9f9bb
    SUBCLASS_OF_ID = 0x9c1c9375

    def __init__(self, code, text):
        """
        :param int code:
        :param str text:

        Constructor for Error: Instance of Error.
        """
        self.code = code  # type: int
        self.text = text  # type: str

    def to_dict(self):
        return {
            '_': 'Error',
            'code': self.code,
            'text': self.text
        }

    def __bytes__(self):
        return b''.join((
            b'\xbb\xf9\xb9\xc4',
            struct.pack('<i', self.code),
            self.serialize_bytes(self.text),
        ))

    @classmethod
    def from_reader(cls, reader):
        _code = reader.read_int()
        _text = reader.tgread_string()
        return cls(code=_code, text=_text)


class ExportedMessageLink(TLObject):
    CONSTRUCTOR_ID = 0x5dab1af4
    SUBCLASS_OF_ID = 0xdee644cc

    def __init__(self, link, html):
        """
        :param str link:
        :param str html:

        Constructor for ExportedMessageLink: Instance of ExportedMessageLink.
        """
        self.link = link  # type: str
        self.html = html  # type: str

    def to_dict(self):
        return {
            '_': 'ExportedMessageLink',
            'link': self.link,
            'html': self.html
        }

    def __bytes__(self):
        return b''.join((
            b'\xf4\x1a\xab]',
            self.serialize_bytes(self.link),
            self.serialize_bytes(self.html),
        ))

    @classmethod
    def from_reader(cls, reader):
        _link = reader.tgread_string()
        _html = reader.tgread_string()
        return cls(link=_link, html=_html)


class FileHash(TLObject):
    CONSTRUCTOR_ID = 0x6242c773
    SUBCLASS_OF_ID = 0xead438b3

    def __init__(self, offset, limit, hash):
        """
        :param int offset:
        :param int limit:
        :param bytes hash:

        Constructor for FileHash: Instance of FileHash.
        """
        self.offset = offset  # type: int
        self.limit = limit  # type: int
        self.hash = hash  # type: bytes

    def to_dict(self):
        return {
            '_': 'FileHash',
            'offset': self.offset,
            'limit': self.limit,
            'hash': self.hash
        }

    def __bytes__(self):
        return b''.join((
            b's\xc7Bb',
            struct.pack('<i', self.offset),
            struct.pack('<i', self.limit),
            self.serialize_bytes(self.hash),
        ))

    @classmethod
    def from_reader(cls, reader):
        _offset = reader.read_int()
        _limit = reader.read_int()
        _hash = reader.tgread_bytes()
        return cls(offset=_offset, limit=_limit, hash=_hash)


class FileLocation(TLObject):
    CONSTRUCTOR_ID = 0x53d69076
    SUBCLASS_OF_ID = 0x90f76823

    def __init__(self, dc_id, volume_id, local_id, secret):
        """
        :param int dc_id:
        :param int volume_id:
        :param int local_id:
        :param int secret:

        Constructor for FileLocation: Instance of either FileLocationUnavailable, FileLocation.
        """
        self.dc_id = dc_id  # type: int
        self.volume_id = volume_id  # type: int
        self.local_id = local_id  # type: int
        self.secret = secret  # type: int

    def to_dict(self):
        return {
            '_': 'FileLocation',
            'dc_id': self.dc_id,
            'volume_id': self.volume_id,
            'local_id': self.local_id,
            'secret': self.secret
        }

    def __bytes__(self):
        return b''.join((
            b'v\x90\xd6S',
            struct.pack('<i', self.dc_id),
            struct.pack('<q', self.volume_id),
            struct.pack('<i', self.local_id),
            struct.pack('<q', self.secret),
        ))

    @classmethod
    def from_reader(cls, reader):
        _dc_id = reader.read_int()
        _volume_id = reader.read_long()
        _local_id = reader.read_int()
        _secret = reader.read_long()
        return cls(dc_id=_dc_id, volume_id=_volume_id, local_id=_local_id, secret=_secret)


class FileLocationUnavailable(TLObject):
    CONSTRUCTOR_ID = 0x7c596b46
    SUBCLASS_OF_ID = 0x90f76823

    def __init__(self, volume_id, local_id, secret):
        """
        :param int volume_id:
        :param int local_id:
        :param int secret:

        Constructor for FileLocation: Instance of either FileLocationUnavailable, FileLocation.
        """
        self.volume_id = volume_id  # type: int
        self.local_id = local_id  # type: int
        self.secret = secret  # type: int

    def to_dict(self):
        return {
            '_': 'FileLocationUnavailable',
            'volume_id': self.volume_id,
            'local_id': self.local_id,
            'secret': self.secret
        }

    def __bytes__(self):
        return b''.join((
            b'FkY|',
            struct.pack('<q', self.volume_id),
            struct.pack('<i', self.local_id),
            struct.pack('<q', self.secret),
        ))

    @classmethod
    def from_reader(cls, reader):
        _volume_id = reader.read_long()
        _local_id = reader.read_int()
        _secret = reader.read_long()
        return cls(volume_id=_volume_id, local_id=_local_id, secret=_secret)


class FoundGif(TLObject):
    CONSTRUCTOR_ID = 0x162ecc1f
    SUBCLASS_OF_ID = 0x5bbc92c3

    def __init__(self, url, thumb_url, content_url, content_type, w, h):
        """
        :param str url:
        :param str thumb_url:
        :param str content_url:
        :param str content_type:
        :param int w:
        :param int h:

        Constructor for FoundGif: Instance of either FoundGif, FoundGifCached.
        """
        self.url = url  # type: str
        self.thumb_url = thumb_url  # type: str
        self.content_url = content_url  # type: str
        self.content_type = content_type  # type: str
        self.w = w  # type: int
        self.h = h  # type: int

    def to_dict(self):
        return {
            '_': 'FoundGif',
            'url': self.url,
            'thumb_url': self.thumb_url,
            'content_url': self.content_url,
            'content_type': self.content_type,
            'w': self.w,
            'h': self.h
        }

    def __bytes__(self):
        return b''.join((
            b'\x1f\xcc.\x16',
            self.serialize_bytes(self.url),
            self.serialize_bytes(self.thumb_url),
            self.serialize_bytes(self.content_url),
            self.serialize_bytes(self.content_type),
            struct.pack('<i', self.w),
            struct.pack('<i', self.h),
        ))

    @classmethod
    def from_reader(cls, reader):
        _url = reader.tgread_string()
        _thumb_url = reader.tgread_string()
        _content_url = reader.tgread_string()
        _content_type = reader.tgread_string()
        _w = reader.read_int()
        _h = reader.read_int()
        return cls(url=_url, thumb_url=_thumb_url, content_url=_content_url, content_type=_content_type, w=_w, h=_h)


class FoundGifCached(TLObject):
    CONSTRUCTOR_ID = 0x9c750409
    SUBCLASS_OF_ID = 0x5bbc92c3

    def __init__(self, url, photo, document):
        """
        :param str url:
        :param TypePhoto photo:
        :param TypeDocument document:

        Constructor for FoundGif: Instance of either FoundGif, FoundGifCached.
        """
        self.url = url  # type: str
        self.photo = photo  # type: TypePhoto
        self.document = document  # type: TypeDocument

    def to_dict(self):
        return {
            '_': 'FoundGifCached',
            'url': self.url,
            'photo': None if self.photo is None else self.photo.to_dict(),
            'document': None if self.document is None else self.document.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\t\x04u\x9c',
            self.serialize_bytes(self.url),
            bytes(self.photo),
            bytes(self.document),
        ))

    @classmethod
    def from_reader(cls, reader):
        _url = reader.tgread_string()
        _photo = reader.tgread_object()
        _document = reader.tgread_object()
        return cls(url=_url, photo=_photo, document=_document)


class FutureSalt(TLObject):
    CONSTRUCTOR_ID = 0x949d9dc
    SUBCLASS_OF_ID = 0x45e53dcf

    def __init__(self, valid_since, valid_until, salt):
        """
        :param int valid_since:
        :param int valid_until:
        :param int salt:

        Constructor for FutureSalt: Instance of FutureSalt.
        """
        self.valid_since = valid_since  # type: int
        self.valid_until = valid_until  # type: int
        self.salt = salt  # type: int

    def to_dict(self):
        return {
            '_': 'FutureSalt',
            'valid_since': self.valid_since,
            'valid_until': self.valid_until,
            'salt': self.salt
        }

    def __bytes__(self):
        return b''.join((
            b'\xdc\xd9I\t',
            struct.pack('<i', self.valid_since),
            struct.pack('<i', self.valid_until),
            struct.pack('<q', self.salt),
        ))

    @classmethod
    def from_reader(cls, reader):
        _valid_since = reader.read_int()
        _valid_until = reader.read_int()
        _salt = reader.read_long()
        return cls(valid_since=_valid_since, valid_until=_valid_until, salt=_salt)


class FutureSalts(TLObject):
    CONSTRUCTOR_ID = 0xae500895
    SUBCLASS_OF_ID = 0x1090f517

    def __init__(self, req_msg_id, now, salts):
        """
        :param int req_msg_id:
        :param int now:
        :param List[Typefuture_salt] salts:

        Constructor for FutureSalts: Instance of FutureSalts.
        """
        self.req_msg_id = req_msg_id  # type: int
        self.now = now  # type: int
        self.salts = salts  # type: List[Typefuture_salt]

    def to_dict(self):
        return {
            '_': 'FutureSalts',
            'req_msg_id': self.req_msg_id,
            'now': self.now,
            'salts': [] if self.salts is None else [None if x is None else x.to_dict() for x in self.salts]
        }

    def __bytes__(self):
        return b''.join((
            b'\x95\x08P\xae',
            struct.pack('<q', self.req_msg_id),
            struct.pack('<i', self.now),
            struct.pack('<i', len(self.salts)),b''.join(bytes(x)[4:] for x in self.salts),
        ))

    @classmethod
    def from_reader(cls, reader):
        _req_msg_id = reader.read_long()
        _now = reader.read_int()
        _salts = []
        for _ in range(reader.read_int()):
            from . import FutureSalt
            _x = FutureSalt.from_reader(reader)
            _salts.append(_x)

        return cls(req_msg_id=_req_msg_id, now=_now, salts=_salts)


class Game(TLObject):
    CONSTRUCTOR_ID = 0xbdf9653b
    SUBCLASS_OF_ID = 0x83199eb2

    def __init__(self, id, access_hash, short_name, title, description, photo, document=None):
        """
        :param int id:
        :param int access_hash:
        :param str short_name:
        :param str title:
        :param str description:
        :param TypePhoto photo:
        :param Optional[TypeDocument] document:

        Constructor for Game: Instance of Game.
        """
        self.id = id  # type: int
        self.access_hash = access_hash  # type: int
        self.short_name = short_name  # type: str
        self.title = title  # type: str
        self.description = description  # type: str
        self.photo = photo  # type: TypePhoto
        self.document = document  # type: Optional[TypeDocument]

    def to_dict(self):
        return {
            '_': 'Game',
            'id': self.id,
            'access_hash': self.access_hash,
            'short_name': self.short_name,
            'title': self.title,
            'description': self.description,
            'photo': None if self.photo is None else self.photo.to_dict(),
            'document': None if self.document is None else self.document.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b';e\xf9\xbd',
            struct.pack('<I', (0 if self.document is None or self.document is False else 1)),
            struct.pack('<q', self.id),
            struct.pack('<q', self.access_hash),
            self.serialize_bytes(self.short_name),
            self.serialize_bytes(self.title),
            self.serialize_bytes(self.description),
            bytes(self.photo),
            b'' if self.document is None or self.document is False else (bytes(self.document)),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _id = reader.read_long()
        _access_hash = reader.read_long()
        _short_name = reader.tgread_string()
        _title = reader.tgread_string()
        _description = reader.tgread_string()
        _photo = reader.tgread_object()
        if flags & 1:
            _document = reader.tgread_object()
        else:
            _document = None
        return cls(id=_id, access_hash=_access_hash, short_name=_short_name, title=_title, description=_description, photo=_photo, document=_document)


class GeoPoint(TLObject):
    CONSTRUCTOR_ID = 0x296f104
    SUBCLASS_OF_ID = 0xd610e16d

    def __init__(self, long, lat, access_hash):
        """
        :param Typedouble long:
        :param Typedouble lat:
        :param int access_hash:

        Constructor for GeoPoint: Instance of either GeoPointEmpty, GeoPoint.
        """
        self.long = long  # type: Typedouble
        self.lat = lat  # type: Typedouble
        self.access_hash = access_hash  # type: int

    def to_dict(self):
        return {
            '_': 'GeoPoint',
            'long': self.long,
            'lat': self.lat,
            'access_hash': self.access_hash
        }

    def __bytes__(self):
        return b''.join((
            b'\x04\xf1\x96\x02',
            struct.pack('<d', self.long),
            struct.pack('<d', self.lat),
            struct.pack('<q', self.access_hash),
        ))

    @classmethod
    def from_reader(cls, reader):
        _long = reader.read_double()
        _lat = reader.read_double()
        _access_hash = reader.read_long()
        return cls(long=_long, lat=_lat, access_hash=_access_hash)


class GeoPointEmpty(TLObject):
    CONSTRUCTOR_ID = 0x1117dd5f
    SUBCLASS_OF_ID = 0xd610e16d

    def to_dict(self):
        return {
            '_': 'GeoPointEmpty'
        }

    def __bytes__(self):
        return b''.join((
            b'_\xdd\x17\x11',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class HighScore(TLObject):
    CONSTRUCTOR_ID = 0x58fffcd0
    SUBCLASS_OF_ID = 0xd32b1e35

    def __init__(self, pos, user_id, score):
        """
        :param int pos:
        :param int user_id:
        :param int score:

        Constructor for HighScore: Instance of HighScore.
        """
        self.pos = pos  # type: int
        self.user_id = user_id  # type: int
        self.score = score  # type: int

    def to_dict(self):
        return {
            '_': 'HighScore',
            'pos': self.pos,
            'user_id': self.user_id,
            'score': self.score
        }

    def __bytes__(self):
        return b''.join((
            b'\xd0\xfc\xffX',
            struct.pack('<i', self.pos),
            struct.pack('<i', self.user_id),
            struct.pack('<i', self.score),
        ))

    @classmethod
    def from_reader(cls, reader):
        _pos = reader.read_int()
        _user_id = reader.read_int()
        _score = reader.read_int()
        return cls(pos=_pos, user_id=_user_id, score=_score)


class ImportedContact(TLObject):
    CONSTRUCTOR_ID = 0xd0028438
    SUBCLASS_OF_ID = 0xb545bbda

    def __init__(self, user_id, client_id):
        """
        :param int user_id:
        :param int client_id:

        Constructor for ImportedContact: Instance of ImportedContact.
        """
        self.user_id = user_id  # type: int
        self.client_id = client_id  # type: int

    def to_dict(self):
        return {
            '_': 'ImportedContact',
            'user_id': self.user_id,
            'client_id': self.client_id
        }

    def __bytes__(self):
        return b''.join((
            b'8\x84\x02\xd0',
            struct.pack('<i', self.user_id),
            struct.pack('<q', self.client_id),
        ))

    @classmethod
    def from_reader(cls, reader):
        _user_id = reader.read_int()
        _client_id = reader.read_long()
        return cls(user_id=_user_id, client_id=_client_id)


class InlineBotSwitchPM(TLObject):
    CONSTRUCTOR_ID = 0x3c20629f
    SUBCLASS_OF_ID = 0x82b1f73b

    def __init__(self, text, start_param):
        """
        :param str text:
        :param str start_param:

        Constructor for InlineBotSwitchPM: Instance of InlineBotSwitchPM.
        """
        self.text = text  # type: str
        self.start_param = start_param  # type: str

    def to_dict(self):
        return {
            '_': 'InlineBotSwitchPM',
            'text': self.text,
            'start_param': self.start_param
        }

    def __bytes__(self):
        return b''.join((
            b'\x9fb <',
            self.serialize_bytes(self.text),
            self.serialize_bytes(self.start_param),
        ))

    @classmethod
    def from_reader(cls, reader):
        _text = reader.tgread_string()
        _start_param = reader.tgread_string()
        return cls(text=_text, start_param=_start_param)


class InputAppEvent(TLObject):
    CONSTRUCTOR_ID = 0x770656a8
    SUBCLASS_OF_ID = 0x89322106

    def __init__(self, time, type, peer, data):
        """
        :param Typedouble time:
        :param str type:
        :param int peer:
        :param str data:

        Constructor for InputAppEvent: Instance of InputAppEvent.
        """
        self.time = time  # type: Typedouble
        self.type = type  # type: str
        self.peer = peer  # type: int
        self.data = data  # type: str

    def to_dict(self):
        return {
            '_': 'InputAppEvent',
            'time': self.time,
            'type': self.type,
            'peer': self.peer,
            'data': self.data
        }

    def __bytes__(self):
        return b''.join((
            b'\xa8V\x06w',
            struct.pack('<d', self.time),
            self.serialize_bytes(self.type),
            struct.pack('<q', self.peer),
            self.serialize_bytes(self.data),
        ))

    @classmethod
    def from_reader(cls, reader):
        _time = reader.read_double()
        _type = reader.tgread_string()
        _peer = reader.read_long()
        _data = reader.tgread_string()
        return cls(time=_time, type=_type, peer=_peer, data=_data)


class InputBotInlineMessageGame(TLObject):
    CONSTRUCTOR_ID = 0x4b425864
    SUBCLASS_OF_ID = 0x53fb4010

    def __init__(self, reply_markup=None):
        """
        :param Optional[TypeReplyMarkup] reply_markup:

        Constructor for InputBotInlineMessage: Instance of either InputBotInlineMessageMediaAuto, InputBotInlineMessageText, InputBotInlineMessageMediaGeo, InputBotInlineMessageMediaVenue, InputBotInlineMessageMediaContact, InputBotInlineMessageGame.
        """
        self.reply_markup = reply_markup  # type: Optional[TypeReplyMarkup]

    def to_dict(self):
        return {
            '_': 'InputBotInlineMessageGame',
            'reply_markup': None if self.reply_markup is None else self.reply_markup.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'dXBK',
            struct.pack('<I', (0 if self.reply_markup is None or self.reply_markup is False else 4)),
            b'' if self.reply_markup is None or self.reply_markup is False else (bytes(self.reply_markup)),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        if flags & 4:
            _reply_markup = reader.tgread_object()
        else:
            _reply_markup = None
        return cls(reply_markup=_reply_markup)


class InputBotInlineMessageID(TLObject):
    CONSTRUCTOR_ID = 0x890c3d89
    SUBCLASS_OF_ID = 0x2dcd6300

    def __init__(self, dc_id, id, access_hash):
        """
        :param int dc_id:
        :param int id:
        :param int access_hash:

        Constructor for InputBotInlineMessageID: Instance of InputBotInlineMessageID.
        """
        self.dc_id = dc_id  # type: int
        self.id = id  # type: int
        self.access_hash = access_hash  # type: int

    def to_dict(self):
        return {
            '_': 'InputBotInlineMessageID',
            'dc_id': self.dc_id,
            'id': self.id,
            'access_hash': self.access_hash
        }

    def __bytes__(self):
        return b''.join((
            b'\x89=\x0c\x89',
            struct.pack('<i', self.dc_id),
            struct.pack('<q', self.id),
            struct.pack('<q', self.access_hash),
        ))

    @classmethod
    def from_reader(cls, reader):
        _dc_id = reader.read_int()
        _id = reader.read_long()
        _access_hash = reader.read_long()
        return cls(dc_id=_dc_id, id=_id, access_hash=_access_hash)


class InputBotInlineMessageMediaAuto(TLObject):
    CONSTRUCTOR_ID = 0x3380c786
    SUBCLASS_OF_ID = 0x53fb4010

    def __init__(self, message, entities=None, reply_markup=None):
        """
        :param str message:
        :param Optional[List[TypeMessageEntity]] entities:
        :param Optional[TypeReplyMarkup] reply_markup:

        Constructor for InputBotInlineMessage: Instance of either InputBotInlineMessageMediaAuto, InputBotInlineMessageText, InputBotInlineMessageMediaGeo, InputBotInlineMessageMediaVenue, InputBotInlineMessageMediaContact, InputBotInlineMessageGame.
        """
        self.message = message  # type: str
        self.entities = entities  # type: Optional[List[TypeMessageEntity]]
        self.reply_markup = reply_markup  # type: Optional[TypeReplyMarkup]

    def to_dict(self):
        return {
            '_': 'InputBotInlineMessageMediaAuto',
            'message': self.message,
            'entities': [] if self.entities is None else [None if x is None else x.to_dict() for x in self.entities],
            'reply_markup': None if self.reply_markup is None else self.reply_markup.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\x86\xc7\x803',
            struct.pack('<I', (0 if self.entities is None or self.entities is False else 2) | (0 if self.reply_markup is None or self.reply_markup is False else 4)),
            self.serialize_bytes(self.message),
            b'' if self.entities is None or self.entities is False else b''.join((b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.entities)),b''.join(bytes(x) for x in self.entities))),
            b'' if self.reply_markup is None or self.reply_markup is False else (bytes(self.reply_markup)),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _message = reader.tgread_string()
        if flags & 2:
            reader.read_int()
            _entities = []
            for _ in range(reader.read_int()):
                _x = reader.tgread_object()
                _entities.append(_x)

        else:
            _entities = None
        if flags & 4:
            _reply_markup = reader.tgread_object()
        else:
            _reply_markup = None
        return cls(message=_message, entities=_entities, reply_markup=_reply_markup)


class InputBotInlineMessageMediaContact(TLObject):
    CONSTRUCTOR_ID = 0xa6edbffd
    SUBCLASS_OF_ID = 0x53fb4010

    def __init__(self, phone_number, first_name, last_name, vcard, reply_markup=None):
        """
        :param str phone_number:
        :param str first_name:
        :param str last_name:
        :param str vcard:
        :param Optional[TypeReplyMarkup] reply_markup:

        Constructor for InputBotInlineMessage: Instance of either InputBotInlineMessageMediaAuto, InputBotInlineMessageText, InputBotInlineMessageMediaGeo, InputBotInlineMessageMediaVenue, InputBotInlineMessageMediaContact, InputBotInlineMessageGame.
        """
        self.phone_number = phone_number  # type: str
        self.first_name = first_name  # type: str
        self.last_name = last_name  # type: str
        self.vcard = vcard  # type: str
        self.reply_markup = reply_markup  # type: Optional[TypeReplyMarkup]

    def to_dict(self):
        return {
            '_': 'InputBotInlineMessageMediaContact',
            'phone_number': self.phone_number,
            'first_name': self.first_name,
            'last_name': self.last_name,
            'vcard': self.vcard,
            'reply_markup': None if self.reply_markup is None else self.reply_markup.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\xfd\xbf\xed\xa6',
            struct.pack('<I', (0 if self.reply_markup is None or self.reply_markup is False else 4)),
            self.serialize_bytes(self.phone_number),
            self.serialize_bytes(self.first_name),
            self.serialize_bytes(self.last_name),
            self.serialize_bytes(self.vcard),
            b'' if self.reply_markup is None or self.reply_markup is False else (bytes(self.reply_markup)),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _phone_number = reader.tgread_string()
        _first_name = reader.tgread_string()
        _last_name = reader.tgread_string()
        _vcard = reader.tgread_string()
        if flags & 4:
            _reply_markup = reader.tgread_object()
        else:
            _reply_markup = None
        return cls(phone_number=_phone_number, first_name=_first_name, last_name=_last_name, vcard=_vcard, reply_markup=_reply_markup)


class InputBotInlineMessageMediaGeo(TLObject):
    CONSTRUCTOR_ID = 0xc1b15d65
    SUBCLASS_OF_ID = 0x53fb4010

    def __init__(self, geo_point, period, reply_markup=None):
        """
        :param TypeInputGeoPoint geo_point:
        :param int period:
        :param Optional[TypeReplyMarkup] reply_markup:

        Constructor for InputBotInlineMessage: Instance of either InputBotInlineMessageMediaAuto, InputBotInlineMessageText, InputBotInlineMessageMediaGeo, InputBotInlineMessageMediaVenue, InputBotInlineMessageMediaContact, InputBotInlineMessageGame.
        """
        self.geo_point = geo_point  # type: TypeInputGeoPoint
        self.period = period  # type: int
        self.reply_markup = reply_markup  # type: Optional[TypeReplyMarkup]

    def to_dict(self):
        return {
            '_': 'InputBotInlineMessageMediaGeo',
            'geo_point': None if self.geo_point is None else self.geo_point.to_dict(),
            'period': self.period,
            'reply_markup': None if self.reply_markup is None else self.reply_markup.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'e]\xb1\xc1',
            struct.pack('<I', (0 if self.reply_markup is None or self.reply_markup is False else 4)),
            bytes(self.geo_point),
            struct.pack('<i', self.period),
            b'' if self.reply_markup is None or self.reply_markup is False else (bytes(self.reply_markup)),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _geo_point = reader.tgread_object()
        _period = reader.read_int()
        if flags & 4:
            _reply_markup = reader.tgread_object()
        else:
            _reply_markup = None
        return cls(geo_point=_geo_point, period=_period, reply_markup=_reply_markup)


class InputBotInlineMessageMediaVenue(TLObject):
    CONSTRUCTOR_ID = 0x417bbf11
    SUBCLASS_OF_ID = 0x53fb4010

    def __init__(self, geo_point, title, address, provider, venue_id, venue_type, reply_markup=None):
        """
        :param TypeInputGeoPoint geo_point:
        :param str title:
        :param str address:
        :param str provider:
        :param str venue_id:
        :param str venue_type:
        :param Optional[TypeReplyMarkup] reply_markup:

        Constructor for InputBotInlineMessage: Instance of either InputBotInlineMessageMediaAuto, InputBotInlineMessageText, InputBotInlineMessageMediaGeo, InputBotInlineMessageMediaVenue, InputBotInlineMessageMediaContact, InputBotInlineMessageGame.
        """
        self.geo_point = geo_point  # type: TypeInputGeoPoint
        self.title = title  # type: str
        self.address = address  # type: str
        self.provider = provider  # type: str
        self.venue_id = venue_id  # type: str
        self.venue_type = venue_type  # type: str
        self.reply_markup = reply_markup  # type: Optional[TypeReplyMarkup]

    def to_dict(self):
        return {
            '_': 'InputBotInlineMessageMediaVenue',
            'geo_point': None if self.geo_point is None else self.geo_point.to_dict(),
            'title': self.title,
            'address': self.address,
            'provider': self.provider,
            'venue_id': self.venue_id,
            'venue_type': self.venue_type,
            'reply_markup': None if self.reply_markup is None else self.reply_markup.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\x11\xbf{A',
            struct.pack('<I', (0 if self.reply_markup is None or self.reply_markup is False else 4)),
            bytes(self.geo_point),
            self.serialize_bytes(self.title),
            self.serialize_bytes(self.address),
            self.serialize_bytes(self.provider),
            self.serialize_bytes(self.venue_id),
            self.serialize_bytes(self.venue_type),
            b'' if self.reply_markup is None or self.reply_markup is False else (bytes(self.reply_markup)),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _geo_point = reader.tgread_object()
        _title = reader.tgread_string()
        _address = reader.tgread_string()
        _provider = reader.tgread_string()
        _venue_id = reader.tgread_string()
        _venue_type = reader.tgread_string()
        if flags & 4:
            _reply_markup = reader.tgread_object()
        else:
            _reply_markup = None
        return cls(geo_point=_geo_point, title=_title, address=_address, provider=_provider, venue_id=_venue_id, venue_type=_venue_type, reply_markup=_reply_markup)


class InputBotInlineMessageText(TLObject):
    CONSTRUCTOR_ID = 0x3dcd7a87
    SUBCLASS_OF_ID = 0x53fb4010

    def __init__(self, message, no_webpage=None, entities=None, reply_markup=None):
        """
        :param str message:
        :param Optional[bool] no_webpage:
        :param Optional[List[TypeMessageEntity]] entities:
        :param Optional[TypeReplyMarkup] reply_markup:

        Constructor for InputBotInlineMessage: Instance of either InputBotInlineMessageMediaAuto, InputBotInlineMessageText, InputBotInlineMessageMediaGeo, InputBotInlineMessageMediaVenue, InputBotInlineMessageMediaContact, InputBotInlineMessageGame.
        """
        self.message = message  # type: str
        self.no_webpage = no_webpage  # type: Optional[bool]
        self.entities = entities  # type: Optional[List[TypeMessageEntity]]
        self.reply_markup = reply_markup  # type: Optional[TypeReplyMarkup]

    def to_dict(self):
        return {
            '_': 'InputBotInlineMessageText',
            'message': self.message,
            'no_webpage': self.no_webpage,
            'entities': [] if self.entities is None else [None if x is None else x.to_dict() for x in self.entities],
            'reply_markup': None if self.reply_markup is None else self.reply_markup.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\x87z\xcd=',
            struct.pack('<I', (0 if self.no_webpage is None or self.no_webpage is False else 1) | (0 if self.entities is None or self.entities is False else 2) | (0 if self.reply_markup is None or self.reply_markup is False else 4)),
            self.serialize_bytes(self.message),
            b'' if self.entities is None or self.entities is False else b''.join((b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.entities)),b''.join(bytes(x) for x in self.entities))),
            b'' if self.reply_markup is None or self.reply_markup is False else (bytes(self.reply_markup)),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _no_webpage = bool(flags & 1)
        _message = reader.tgread_string()
        if flags & 2:
            reader.read_int()
            _entities = []
            for _ in range(reader.read_int()):
                _x = reader.tgread_object()
                _entities.append(_x)

        else:
            _entities = None
        if flags & 4:
            _reply_markup = reader.tgread_object()
        else:
            _reply_markup = None
        return cls(message=_message, no_webpage=_no_webpage, entities=_entities, reply_markup=_reply_markup)


class InputBotInlineResult(TLObject):
    CONSTRUCTOR_ID = 0x88bf9319
    SUBCLASS_OF_ID = 0x80a4a3de

    def __init__(self, id, type, send_message, title=None, description=None, url=None, thumb=None, content=None):
        """
        :param str id:
        :param str type:
        :param TypeInputBotInlineMessage send_message:
        :param Optional[str] title:
        :param Optional[str] description:
        :param Optional[str] url:
        :param Optional[TypeInputWebDocument] thumb:
        :param Optional[TypeInputWebDocument] content:

        Constructor for InputBotInlineResult: Instance of either InputBotInlineResult, InputBotInlineResultPhoto, InputBotInlineResultDocument, InputBotInlineResultGame.
        """
        self.id = id  # type: str
        self.type = type  # type: str
        self.send_message = send_message  # type: TypeInputBotInlineMessage
        self.title = title  # type: Optional[str]
        self.description = description  # type: Optional[str]
        self.url = url  # type: Optional[str]
        self.thumb = thumb  # type: Optional[TypeInputWebDocument]
        self.content = content  # type: Optional[TypeInputWebDocument]

    def to_dict(self):
        return {
            '_': 'InputBotInlineResult',
            'id': self.id,
            'type': self.type,
            'send_message': None if self.send_message is None else self.send_message.to_dict(),
            'title': self.title,
            'description': self.description,
            'url': self.url,
            'thumb': None if self.thumb is None else self.thumb.to_dict(),
            'content': None if self.content is None else self.content.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\x19\x93\xbf\x88',
            struct.pack('<I', (0 if self.title is None or self.title is False else 2) | (0 if self.description is None or self.description is False else 4) | (0 if self.url is None or self.url is False else 8) | (0 if self.thumb is None or self.thumb is False else 16) | (0 if self.content is None or self.content is False else 32)),
            self.serialize_bytes(self.id),
            self.serialize_bytes(self.type),
            b'' if self.title is None or self.title is False else (self.serialize_bytes(self.title)),
            b'' if self.description is None or self.description is False else (self.serialize_bytes(self.description)),
            b'' if self.url is None or self.url is False else (self.serialize_bytes(self.url)),
            b'' if self.thumb is None or self.thumb is False else (bytes(self.thumb)),
            b'' if self.content is None or self.content is False else (bytes(self.content)),
            bytes(self.send_message),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _id = reader.tgread_string()
        _type = reader.tgread_string()
        if flags & 2:
            _title = reader.tgread_string()
        else:
            _title = None
        if flags & 4:
            _description = reader.tgread_string()
        else:
            _description = None
        if flags & 8:
            _url = reader.tgread_string()
        else:
            _url = None
        if flags & 16:
            _thumb = reader.tgread_object()
        else:
            _thumb = None
        if flags & 32:
            _content = reader.tgread_object()
        else:
            _content = None
        _send_message = reader.tgread_object()
        return cls(id=_id, type=_type, send_message=_send_message, title=_title, description=_description, url=_url, thumb=_thumb, content=_content)


class InputBotInlineResultDocument(TLObject):
    CONSTRUCTOR_ID = 0xfff8fdc4
    SUBCLASS_OF_ID = 0x80a4a3de

    def __init__(self, id, type, document, send_message, title=None, description=None):
        """
        :param str id:
        :param str type:
        :param TypeInputDocument document:
        :param TypeInputBotInlineMessage send_message:
        :param Optional[str] title:
        :param Optional[str] description:

        Constructor for InputBotInlineResult: Instance of either InputBotInlineResult, InputBotInlineResultPhoto, InputBotInlineResultDocument, InputBotInlineResultGame.
        """
        self.id = id  # type: str
        self.type = type  # type: str
        self.document = document  # type: TypeInputDocument
        self.send_message = send_message  # type: TypeInputBotInlineMessage
        self.title = title  # type: Optional[str]
        self.description = description  # type: Optional[str]

    def to_dict(self):
        return {
            '_': 'InputBotInlineResultDocument',
            'id': self.id,
            'type': self.type,
            'document': None if self.document is None else self.document.to_dict(),
            'send_message': None if self.send_message is None else self.send_message.to_dict(),
            'title': self.title,
            'description': self.description
        }

    def __bytes__(self):
        return b''.join((
            b'\xc4\xfd\xf8\xff',
            struct.pack('<I', (0 if self.title is None or self.title is False else 2) | (0 if self.description is None or self.description is False else 4)),
            self.serialize_bytes(self.id),
            self.serialize_bytes(self.type),
            b'' if self.title is None or self.title is False else (self.serialize_bytes(self.title)),
            b'' if self.description is None or self.description is False else (self.serialize_bytes(self.description)),
            bytes(self.document),
            bytes(self.send_message),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _id = reader.tgread_string()
        _type = reader.tgread_string()
        if flags & 2:
            _title = reader.tgread_string()
        else:
            _title = None
        if flags & 4:
            _description = reader.tgread_string()
        else:
            _description = None
        _document = reader.tgread_object()
        _send_message = reader.tgread_object()
        return cls(id=_id, type=_type, document=_document, send_message=_send_message, title=_title, description=_description)


class InputBotInlineResultGame(TLObject):
    CONSTRUCTOR_ID = 0x4fa417f2
    SUBCLASS_OF_ID = 0x80a4a3de

    def __init__(self, id, short_name, send_message):
        """
        :param str id:
        :param str short_name:
        :param TypeInputBotInlineMessage send_message:

        Constructor for InputBotInlineResult: Instance of either InputBotInlineResult, InputBotInlineResultPhoto, InputBotInlineResultDocument, InputBotInlineResultGame.
        """
        self.id = id  # type: str
        self.short_name = short_name  # type: str
        self.send_message = send_message  # type: TypeInputBotInlineMessage

    def to_dict(self):
        return {
            '_': 'InputBotInlineResultGame',
            'id': self.id,
            'short_name': self.short_name,
            'send_message': None if self.send_message is None else self.send_message.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\xf2\x17\xa4O',
            self.serialize_bytes(self.id),
            self.serialize_bytes(self.short_name),
            bytes(self.send_message),
        ))

    @classmethod
    def from_reader(cls, reader):
        _id = reader.tgread_string()
        _short_name = reader.tgread_string()
        _send_message = reader.tgread_object()
        return cls(id=_id, short_name=_short_name, send_message=_send_message)


class InputBotInlineResultPhoto(TLObject):
    CONSTRUCTOR_ID = 0xa8d864a7
    SUBCLASS_OF_ID = 0x80a4a3de

    def __init__(self, id, type, photo, send_message):
        """
        :param str id:
        :param str type:
        :param TypeInputPhoto photo:
        :param TypeInputBotInlineMessage send_message:

        Constructor for InputBotInlineResult: Instance of either InputBotInlineResult, InputBotInlineResultPhoto, InputBotInlineResultDocument, InputBotInlineResultGame.
        """
        self.id = id  # type: str
        self.type = type  # type: str
        self.photo = photo  # type: TypeInputPhoto
        self.send_message = send_message  # type: TypeInputBotInlineMessage

    def to_dict(self):
        return {
            '_': 'InputBotInlineResultPhoto',
            'id': self.id,
            'type': self.type,
            'photo': None if self.photo is None else self.photo.to_dict(),
            'send_message': None if self.send_message is None else self.send_message.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\xa7d\xd8\xa8',
            self.serialize_bytes(self.id),
            self.serialize_bytes(self.type),
            bytes(self.photo),
            bytes(self.send_message),
        ))

    @classmethod
    def from_reader(cls, reader):
        _id = reader.tgread_string()
        _type = reader.tgread_string()
        _photo = reader.tgread_object()
        _send_message = reader.tgread_object()
        return cls(id=_id, type=_type, photo=_photo, send_message=_send_message)


class InputChannel(TLObject):
    CONSTRUCTOR_ID = 0xafeb712e
    SUBCLASS_OF_ID = 0x40f202fd

    def __init__(self, channel_id, access_hash):
        """
        :param int channel_id:
        :param int access_hash:

        Constructor for InputChannel: Instance of either InputChannelEmpty, InputChannel.
        """
        self.channel_id = channel_id  # type: int
        self.access_hash = access_hash  # type: int

    def to_dict(self):
        return {
            '_': 'InputChannel',
            'channel_id': self.channel_id,
            'access_hash': self.access_hash
        }

    def __bytes__(self):
        return b''.join((
            b'.q\xeb\xaf',
            struct.pack('<i', self.channel_id),
            struct.pack('<q', self.access_hash),
        ))

    @classmethod
    def from_reader(cls, reader):
        _channel_id = reader.read_int()
        _access_hash = reader.read_long()
        return cls(channel_id=_channel_id, access_hash=_access_hash)


class InputChannelEmpty(TLObject):
    CONSTRUCTOR_ID = 0xee8c1e86
    SUBCLASS_OF_ID = 0x40f202fd

    def to_dict(self):
        return {
            '_': 'InputChannelEmpty'
        }

    def __bytes__(self):
        return b''.join((
            b'\x86\x1e\x8c\xee',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class InputChatPhoto(TLObject):
    CONSTRUCTOR_ID = 0x8953ad37
    SUBCLASS_OF_ID = 0xd4eb2d74

    def __init__(self, id):
        """
        :param TypeInputPhoto id:

        Constructor for InputChatPhoto: Instance of either InputChatPhotoEmpty, InputChatUploadedPhoto, InputChatPhoto.
        """
        self.id = id  # type: TypeInputPhoto

    def to_dict(self):
        return {
            '_': 'InputChatPhoto',
            'id': None if self.id is None else self.id.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'7\xadS\x89',
            bytes(self.id),
        ))

    @classmethod
    def from_reader(cls, reader):
        _id = reader.tgread_object()
        return cls(id=_id)


class InputChatPhotoEmpty(TLObject):
    CONSTRUCTOR_ID = 0x1ca48f57
    SUBCLASS_OF_ID = 0xd4eb2d74

    def to_dict(self):
        return {
            '_': 'InputChatPhotoEmpty'
        }

    def __bytes__(self):
        return b''.join((
            b'W\x8f\xa4\x1c',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class InputChatUploadedPhoto(TLObject):
    CONSTRUCTOR_ID = 0x927c55b4
    SUBCLASS_OF_ID = 0xd4eb2d74

    def __init__(self, file):
        """
        :param TypeInputFile file:

        Constructor for InputChatPhoto: Instance of either InputChatPhotoEmpty, InputChatUploadedPhoto, InputChatPhoto.
        """
        self.file = file  # type: TypeInputFile

    def to_dict(self):
        return {
            '_': 'InputChatUploadedPhoto',
            'file': None if self.file is None else self.file.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\xb4U|\x92',
            bytes(self.file),
        ))

    @classmethod
    def from_reader(cls, reader):
        _file = reader.tgread_object()
        return cls(file=_file)


class InputClientProxy(TLObject):
    CONSTRUCTOR_ID = 0x75588b3f
    SUBCLASS_OF_ID = 0x91a4346

    def __init__(self, address, port):
        """
        :param str address:
        :param int port:

        Constructor for InputClientProxy: Instance of InputClientProxy.
        """
        self.address = address  # type: str
        self.port = port  # type: int

    def to_dict(self):
        return {
            '_': 'InputClientProxy',
            'address': self.address,
            'port': self.port
        }

    def __bytes__(self):
        return b''.join((
            b'?\x8bXu',
            self.serialize_bytes(self.address),
            struct.pack('<i', self.port),
        ))

    @classmethod
    def from_reader(cls, reader):
        _address = reader.tgread_string()
        _port = reader.read_int()
        return cls(address=_address, port=_port)


class InputDialogPeer(TLObject):
    CONSTRUCTOR_ID = 0xfcaafeb7
    SUBCLASS_OF_ID = 0xa21c9795

    def __init__(self, peer):
        """
        :param TypeInputPeer peer:

        Constructor for InputDialogPeer: Instance of InputDialogPeer.
        """
        self.peer = peer  # type: TypeInputPeer

    def to_dict(self):
        return {
            '_': 'InputDialogPeer',
            'peer': None if self.peer is None else self.peer.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\xb7\xfe\xaa\xfc',
            bytes(self.peer),
        ))

    @classmethod
    def from_reader(cls, reader):
        _peer = reader.tgread_object()
        return cls(peer=_peer)


class InputDocument(TLObject):
    CONSTRUCTOR_ID = 0x18798952
    SUBCLASS_OF_ID = 0xf33fdb68

    def __init__(self, id, access_hash):
        """
        :param int id:
        :param int access_hash:

        Constructor for InputDocument: Instance of either InputDocumentEmpty, InputDocument.
        """
        self.id = id  # type: int
        self.access_hash = access_hash  # type: int

    def to_dict(self):
        return {
            '_': 'InputDocument',
            'id': self.id,
            'access_hash': self.access_hash
        }

    def __bytes__(self):
        return b''.join((
            b'R\x89y\x18',
            struct.pack('<q', self.id),
            struct.pack('<q', self.access_hash),
        ))

    @classmethod
    def from_reader(cls, reader):
        _id = reader.read_long()
        _access_hash = reader.read_long()
        return cls(id=_id, access_hash=_access_hash)


class InputDocumentEmpty(TLObject):
    CONSTRUCTOR_ID = 0x72f0eaae
    SUBCLASS_OF_ID = 0xf33fdb68

    def to_dict(self):
        return {
            '_': 'InputDocumentEmpty'
        }

    def __bytes__(self):
        return b''.join((
            b'\xae\xea\xf0r',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class InputDocumentFileLocation(TLObject):
    CONSTRUCTOR_ID = 0x430f0724
    SUBCLASS_OF_ID = 0x1523d462

    def __init__(self, id, access_hash, version):
        """
        :param int id:
        :param int access_hash:
        :param int version:

        Constructor for InputFileLocation: Instance of either InputFileLocation, InputEncryptedFileLocation, InputDocumentFileLocation, InputSecureFileLocation, InputTakeoutFileLocation.
        """
        self.id = id  # type: int
        self.access_hash = access_hash  # type: int
        self.version = version  # type: int

    def to_dict(self):
        return {
            '_': 'InputDocumentFileLocation',
            'id': self.id,
            'access_hash': self.access_hash,
            'version': self.version
        }

    def __bytes__(self):
        return b''.join((
            b'$\x07\x0fC',
            struct.pack('<q', self.id),
            struct.pack('<q', self.access_hash),
            struct.pack('<i', self.version),
        ))

    @classmethod
    def from_reader(cls, reader):
        _id = reader.read_long()
        _access_hash = reader.read_long()
        _version = reader.read_int()
        return cls(id=_id, access_hash=_access_hash, version=_version)


class InputEncryptedChat(TLObject):
    CONSTRUCTOR_ID = 0xf141b5e1
    SUBCLASS_OF_ID = 0x6c7606c0

    def __init__(self, chat_id, access_hash):
        """
        :param int chat_id:
        :param int access_hash:

        Constructor for InputEncryptedChat: Instance of InputEncryptedChat.
        """
        self.chat_id = chat_id  # type: int
        self.access_hash = access_hash  # type: int

    def to_dict(self):
        return {
            '_': 'InputEncryptedChat',
            'chat_id': self.chat_id,
            'access_hash': self.access_hash
        }

    def __bytes__(self):
        return b''.join((
            b'\xe1\xb5A\xf1',
            struct.pack('<i', self.chat_id),
            struct.pack('<q', self.access_hash),
        ))

    @classmethod
    def from_reader(cls, reader):
        _chat_id = reader.read_int()
        _access_hash = reader.read_long()
        return cls(chat_id=_chat_id, access_hash=_access_hash)


class InputEncryptedFile(TLObject):
    CONSTRUCTOR_ID = 0x5a17b5e5
    SUBCLASS_OF_ID = 0x8574c27a

    def __init__(self, id, access_hash):
        """
        :param int id:
        :param int access_hash:

        Constructor for InputEncryptedFile: Instance of either InputEncryptedFileEmpty, InputEncryptedFileUploaded, InputEncryptedFile, InputEncryptedFileBigUploaded.
        """
        self.id = id  # type: int
        self.access_hash = access_hash  # type: int

    def to_dict(self):
        return {
            '_': 'InputEncryptedFile',
            'id': self.id,
            'access_hash': self.access_hash
        }

    def __bytes__(self):
        return b''.join((
            b'\xe5\xb5\x17Z',
            struct.pack('<q', self.id),
            struct.pack('<q', self.access_hash),
        ))

    @classmethod
    def from_reader(cls, reader):
        _id = reader.read_long()
        _access_hash = reader.read_long()
        return cls(id=_id, access_hash=_access_hash)


class InputEncryptedFileBigUploaded(TLObject):
    CONSTRUCTOR_ID = 0x2dc173c8
    SUBCLASS_OF_ID = 0x8574c27a

    def __init__(self, id, parts, key_fingerprint):
        """
        :param int id:
        :param int parts:
        :param int key_fingerprint:

        Constructor for InputEncryptedFile: Instance of either InputEncryptedFileEmpty, InputEncryptedFileUploaded, InputEncryptedFile, InputEncryptedFileBigUploaded.
        """
        self.id = id  # type: int
        self.parts = parts  # type: int
        self.key_fingerprint = key_fingerprint  # type: int

    def to_dict(self):
        return {
            '_': 'InputEncryptedFileBigUploaded',
            'id': self.id,
            'parts': self.parts,
            'key_fingerprint': self.key_fingerprint
        }

    def __bytes__(self):
        return b''.join((
            b'\xc8s\xc1-',
            struct.pack('<q', self.id),
            struct.pack('<i', self.parts),
            struct.pack('<i', self.key_fingerprint),
        ))

    @classmethod
    def from_reader(cls, reader):
        _id = reader.read_long()
        _parts = reader.read_int()
        _key_fingerprint = reader.read_int()
        return cls(id=_id, parts=_parts, key_fingerprint=_key_fingerprint)


class InputEncryptedFileEmpty(TLObject):
    CONSTRUCTOR_ID = 0x1837c364
    SUBCLASS_OF_ID = 0x8574c27a

    def to_dict(self):
        return {
            '_': 'InputEncryptedFileEmpty'
        }

    def __bytes__(self):
        return b''.join((
            b'd\xc37\x18',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class InputEncryptedFileLocation(TLObject):
    CONSTRUCTOR_ID = 0xf5235d55
    SUBCLASS_OF_ID = 0x1523d462

    def __init__(self, id, access_hash):
        """
        :param int id:
        :param int access_hash:

        Constructor for InputFileLocation: Instance of either InputFileLocation, InputEncryptedFileLocation, InputDocumentFileLocation, InputSecureFileLocation, InputTakeoutFileLocation.
        """
        self.id = id  # type: int
        self.access_hash = access_hash  # type: int

    def to_dict(self):
        return {
            '_': 'InputEncryptedFileLocation',
            'id': self.id,
            'access_hash': self.access_hash
        }

    def __bytes__(self):
        return b''.join((
            b'U]#\xf5',
            struct.pack('<q', self.id),
            struct.pack('<q', self.access_hash),
        ))

    @classmethod
    def from_reader(cls, reader):
        _id = reader.read_long()
        _access_hash = reader.read_long()
        return cls(id=_id, access_hash=_access_hash)


class InputEncryptedFileUploaded(TLObject):
    CONSTRUCTOR_ID = 0x64bd0306
    SUBCLASS_OF_ID = 0x8574c27a

    def __init__(self, id, parts, md5_checksum, key_fingerprint):
        """
        :param int id:
        :param int parts:
        :param str md5_checksum:
        :param int key_fingerprint:

        Constructor for InputEncryptedFile: Instance of either InputEncryptedFileEmpty, InputEncryptedFileUploaded, InputEncryptedFile, InputEncryptedFileBigUploaded.
        """
        self.id = id  # type: int
        self.parts = parts  # type: int
        self.md5_checksum = md5_checksum  # type: str
        self.key_fingerprint = key_fingerprint  # type: int

    def to_dict(self):
        return {
            '_': 'InputEncryptedFileUploaded',
            'id': self.id,
            'parts': self.parts,
            'md5_checksum': self.md5_checksum,
            'key_fingerprint': self.key_fingerprint
        }

    def __bytes__(self):
        return b''.join((
            b'\x06\x03\xbdd',
            struct.pack('<q', self.id),
            struct.pack('<i', self.parts),
            self.serialize_bytes(self.md5_checksum),
            struct.pack('<i', self.key_fingerprint),
        ))

    @classmethod
    def from_reader(cls, reader):
        _id = reader.read_long()
        _parts = reader.read_int()
        _md5_checksum = reader.tgread_string()
        _key_fingerprint = reader.read_int()
        return cls(id=_id, parts=_parts, md5_checksum=_md5_checksum, key_fingerprint=_key_fingerprint)


class InputFile(TLObject):
    CONSTRUCTOR_ID = 0xf52ff27f
    SUBCLASS_OF_ID = 0xe7655f1f

    def __init__(self, id, parts, name, md5_checksum):
        """
        :param int id:
        :param int parts:
        :param str name:
        :param str md5_checksum:

        Constructor for InputFile: Instance of either InputFile, InputFileBig.
        """
        self.id = id  # type: int
        self.parts = parts  # type: int
        self.name = name  # type: str
        self.md5_checksum = md5_checksum  # type: str

    def to_dict(self):
        return {
            '_': 'InputFile',
            'id': self.id,
            'parts': self.parts,
            'name': self.name,
            'md5_checksum': self.md5_checksum
        }

    def __bytes__(self):
        return b''.join((
            b'\x7f\xf2/\xf5',
            struct.pack('<q', self.id),
            struct.pack('<i', self.parts),
            self.serialize_bytes(self.name),
            self.serialize_bytes(self.md5_checksum),
        ))

    @classmethod
    def from_reader(cls, reader):
        _id = reader.read_long()
        _parts = reader.read_int()
        _name = reader.tgread_string()
        _md5_checksum = reader.tgread_string()
        return cls(id=_id, parts=_parts, name=_name, md5_checksum=_md5_checksum)


class InputFileBig(TLObject):
    CONSTRUCTOR_ID = 0xfa4f0bb5
    SUBCLASS_OF_ID = 0xe7655f1f

    def __init__(self, id, parts, name):
        """
        :param int id:
        :param int parts:
        :param str name:

        Constructor for InputFile: Instance of either InputFile, InputFileBig.
        """
        self.id = id  # type: int
        self.parts = parts  # type: int
        self.name = name  # type: str

    def to_dict(self):
        return {
            '_': 'InputFileBig',
            'id': self.id,
            'parts': self.parts,
            'name': self.name
        }

    def __bytes__(self):
        return b''.join((
            b'\xb5\x0bO\xfa',
            struct.pack('<q', self.id),
            struct.pack('<i', self.parts),
            self.serialize_bytes(self.name),
        ))

    @classmethod
    def from_reader(cls, reader):
        _id = reader.read_long()
        _parts = reader.read_int()
        _name = reader.tgread_string()
        return cls(id=_id, parts=_parts, name=_name)


class InputFileLocation(TLObject):
    CONSTRUCTOR_ID = 0x14637196
    SUBCLASS_OF_ID = 0x1523d462

    def __init__(self, volume_id, local_id, secret):
        """
        :param int volume_id:
        :param int local_id:
        :param int secret:

        Constructor for InputFileLocation: Instance of either InputFileLocation, InputEncryptedFileLocation, InputDocumentFileLocation, InputSecureFileLocation, InputTakeoutFileLocation.
        """
        self.volume_id = volume_id  # type: int
        self.local_id = local_id  # type: int
        self.secret = secret  # type: int

    def to_dict(self):
        return {
            '_': 'InputFileLocation',
            'volume_id': self.volume_id,
            'local_id': self.local_id,
            'secret': self.secret
        }

    def __bytes__(self):
        return b''.join((
            b'\x96qc\x14',
            struct.pack('<q', self.volume_id),
            struct.pack('<i', self.local_id),
            struct.pack('<q', self.secret),
        ))

    @classmethod
    def from_reader(cls, reader):
        _volume_id = reader.read_long()
        _local_id = reader.read_int()
        _secret = reader.read_long()
        return cls(volume_id=_volume_id, local_id=_local_id, secret=_secret)


class InputGameID(TLObject):
    CONSTRUCTOR_ID = 0x32c3e77
    SUBCLASS_OF_ID = 0x48d15883

    def __init__(self, id, access_hash):
        """
        :param int id:
        :param int access_hash:

        Constructor for InputGame: Instance of either InputGameID, InputGameShortName.
        """
        self.id = id  # type: int
        self.access_hash = access_hash  # type: int

    def to_dict(self):
        return {
            '_': 'InputGameID',
            'id': self.id,
            'access_hash': self.access_hash
        }

    def __bytes__(self):
        return b''.join((
            b'w>,\x03',
            struct.pack('<q', self.id),
            struct.pack('<q', self.access_hash),
        ))

    @classmethod
    def from_reader(cls, reader):
        _id = reader.read_long()
        _access_hash = reader.read_long()
        return cls(id=_id, access_hash=_access_hash)


class InputGameShortName(TLObject):
    CONSTRUCTOR_ID = 0xc331e80a
    SUBCLASS_OF_ID = 0x48d15883

    def __init__(self, bot_id, short_name):
        """
        :param TypeInputUser bot_id:
        :param str short_name:

        Constructor for InputGame: Instance of either InputGameID, InputGameShortName.
        """
        self.bot_id = bot_id  # type: TypeInputUser
        self.short_name = short_name  # type: str

    def to_dict(self):
        return {
            '_': 'InputGameShortName',
            'bot_id': None if self.bot_id is None else self.bot_id.to_dict(),
            'short_name': self.short_name
        }

    def __bytes__(self):
        return b''.join((
            b'\n\xe81\xc3',
            bytes(self.bot_id),
            self.serialize_bytes(self.short_name),
        ))

    @classmethod
    def from_reader(cls, reader):
        _bot_id = reader.tgread_object()
        _short_name = reader.tgread_string()
        return cls(bot_id=_bot_id, short_name=_short_name)


class InputGeoPoint(TLObject):
    CONSTRUCTOR_ID = 0xf3b7acc9
    SUBCLASS_OF_ID = 0x430d225

    def __init__(self, lat, long):
        """
        :param Typedouble lat:
        :param Typedouble long:

        Constructor for InputGeoPoint: Instance of either InputGeoPointEmpty, InputGeoPoint.
        """
        self.lat = lat  # type: Typedouble
        self.long = long  # type: Typedouble

    def to_dict(self):
        return {
            '_': 'InputGeoPoint',
            'lat': self.lat,
            'long': self.long
        }

    def __bytes__(self):
        return b''.join((
            b'\xc9\xac\xb7\xf3',
            struct.pack('<d', self.lat),
            struct.pack('<d', self.long),
        ))

    @classmethod
    def from_reader(cls, reader):
        _lat = reader.read_double()
        _long = reader.read_double()
        return cls(lat=_lat, long=_long)


class InputGeoPointEmpty(TLObject):
    CONSTRUCTOR_ID = 0xe4c123d6
    SUBCLASS_OF_ID = 0x430d225

    def to_dict(self):
        return {
            '_': 'InputGeoPointEmpty'
        }

    def __bytes__(self):
        return b''.join((
            b'\xd6#\xc1\xe4',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class InputMediaContact(TLObject):
    CONSTRUCTOR_ID = 0xf8ab7dfb
    SUBCLASS_OF_ID = 0xfaf846f4

    def __init__(self, phone_number, first_name, last_name, vcard):
        """
        :param str phone_number:
        :param str first_name:
        :param str last_name:
        :param str vcard:

        Constructor for InputMedia: Instance of either InputMediaEmpty, InputMediaUploadedPhoto, InputMediaPhoto, InputMediaGeoPoint, InputMediaContact, InputMediaUploadedDocument, InputMediaDocument, InputMediaVenue, InputMediaGifExternal, InputMediaPhotoExternal, InputMediaDocumentExternal, InputMediaGame, InputMediaInvoice, InputMediaGeoLive.
        """
        self.phone_number = phone_number  # type: str
        self.first_name = first_name  # type: str
        self.last_name = last_name  # type: str
        self.vcard = vcard  # type: str

    def to_dict(self):
        return {
            '_': 'InputMediaContact',
            'phone_number': self.phone_number,
            'first_name': self.first_name,
            'last_name': self.last_name,
            'vcard': self.vcard
        }

    def __bytes__(self):
        return b''.join((
            b'\xfb}\xab\xf8',
            self.serialize_bytes(self.phone_number),
            self.serialize_bytes(self.first_name),
            self.serialize_bytes(self.last_name),
            self.serialize_bytes(self.vcard),
        ))

    @classmethod
    def from_reader(cls, reader):
        _phone_number = reader.tgread_string()
        _first_name = reader.tgread_string()
        _last_name = reader.tgread_string()
        _vcard = reader.tgread_string()
        return cls(phone_number=_phone_number, first_name=_first_name, last_name=_last_name, vcard=_vcard)


class InputMediaDocument(TLObject):
    CONSTRUCTOR_ID = 0x23ab23d2
    SUBCLASS_OF_ID = 0xfaf846f4

    def __init__(self, id, ttl_seconds=None):
        """
        :param TypeInputDocument id:
        :param Optional[int] ttl_seconds:

        Constructor for InputMedia: Instance of either InputMediaEmpty, InputMediaUploadedPhoto, InputMediaPhoto, InputMediaGeoPoint, InputMediaContact, InputMediaUploadedDocument, InputMediaDocument, InputMediaVenue, InputMediaGifExternal, InputMediaPhotoExternal, InputMediaDocumentExternal, InputMediaGame, InputMediaInvoice, InputMediaGeoLive.
        """
        self.id = id  # type: TypeInputDocument
        self.ttl_seconds = ttl_seconds  # type: Optional[int]

    def to_dict(self):
        return {
            '_': 'InputMediaDocument',
            'id': None if self.id is None else self.id.to_dict(),
            'ttl_seconds': self.ttl_seconds
        }

    def __bytes__(self):
        return b''.join((
            b'\xd2#\xab#',
            struct.pack('<I', (0 if self.ttl_seconds is None or self.ttl_seconds is False else 1)),
            bytes(self.id),
            b'' if self.ttl_seconds is None or self.ttl_seconds is False else (struct.pack('<i', self.ttl_seconds)),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _id = reader.tgread_object()
        if flags & 1:
            _ttl_seconds = reader.read_int()
        else:
            _ttl_seconds = None
        return cls(id=_id, ttl_seconds=_ttl_seconds)


class InputMediaDocumentExternal(TLObject):
    CONSTRUCTOR_ID = 0xfb52dc99
    SUBCLASS_OF_ID = 0xfaf846f4

    def __init__(self, url, ttl_seconds=None):
        """
        :param str url:
        :param Optional[int] ttl_seconds:

        Constructor for InputMedia: Instance of either InputMediaEmpty, InputMediaUploadedPhoto, InputMediaPhoto, InputMediaGeoPoint, InputMediaContact, InputMediaUploadedDocument, InputMediaDocument, InputMediaVenue, InputMediaGifExternal, InputMediaPhotoExternal, InputMediaDocumentExternal, InputMediaGame, InputMediaInvoice, InputMediaGeoLive.
        """
        self.url = url  # type: str
        self.ttl_seconds = ttl_seconds  # type: Optional[int]

    def to_dict(self):
        return {
            '_': 'InputMediaDocumentExternal',
            'url': self.url,
            'ttl_seconds': self.ttl_seconds
        }

    def __bytes__(self):
        return b''.join((
            b'\x99\xdcR\xfb',
            struct.pack('<I', (0 if self.ttl_seconds is None or self.ttl_seconds is False else 1)),
            self.serialize_bytes(self.url),
            b'' if self.ttl_seconds is None or self.ttl_seconds is False else (struct.pack('<i', self.ttl_seconds)),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _url = reader.tgread_string()
        if flags & 1:
            _ttl_seconds = reader.read_int()
        else:
            _ttl_seconds = None
        return cls(url=_url, ttl_seconds=_ttl_seconds)


class InputMediaEmpty(TLObject):
    CONSTRUCTOR_ID = 0x9664f57f
    SUBCLASS_OF_ID = 0xfaf846f4

    def to_dict(self):
        return {
            '_': 'InputMediaEmpty'
        }

    def __bytes__(self):
        return b''.join((
            b'\x7f\xf5d\x96',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class InputMediaGame(TLObject):
    CONSTRUCTOR_ID = 0xd33f43f3
    SUBCLASS_OF_ID = 0xfaf846f4

    def __init__(self, id):
        """
        :param TypeInputGame id:

        Constructor for InputMedia: Instance of either InputMediaEmpty, InputMediaUploadedPhoto, InputMediaPhoto, InputMediaGeoPoint, InputMediaContact, InputMediaUploadedDocument, InputMediaDocument, InputMediaVenue, InputMediaGifExternal, InputMediaPhotoExternal, InputMediaDocumentExternal, InputMediaGame, InputMediaInvoice, InputMediaGeoLive.
        """
        self.id = id  # type: TypeInputGame

    def to_dict(self):
        return {
            '_': 'InputMediaGame',
            'id': None if self.id is None else self.id.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\xf3C?\xd3',
            bytes(self.id),
        ))

    @classmethod
    def from_reader(cls, reader):
        _id = reader.tgread_object()
        return cls(id=_id)


class InputMediaGeoLive(TLObject):
    CONSTRUCTOR_ID = 0x7b1a118f
    SUBCLASS_OF_ID = 0xfaf846f4

    def __init__(self, geo_point, period):
        """
        :param TypeInputGeoPoint geo_point:
        :param int period:

        Constructor for InputMedia: Instance of either InputMediaEmpty, InputMediaUploadedPhoto, InputMediaPhoto, InputMediaGeoPoint, InputMediaContact, InputMediaUploadedDocument, InputMediaDocument, InputMediaVenue, InputMediaGifExternal, InputMediaPhotoExternal, InputMediaDocumentExternal, InputMediaGame, InputMediaInvoice, InputMediaGeoLive.
        """
        self.geo_point = geo_point  # type: TypeInputGeoPoint
        self.period = period  # type: int

    def to_dict(self):
        return {
            '_': 'InputMediaGeoLive',
            'geo_point': None if self.geo_point is None else self.geo_point.to_dict(),
            'period': self.period
        }

    def __bytes__(self):
        return b''.join((
            b'\x8f\x11\x1a{',
            bytes(self.geo_point),
            struct.pack('<i', self.period),
        ))

    @classmethod
    def from_reader(cls, reader):
        _geo_point = reader.tgread_object()
        _period = reader.read_int()
        return cls(geo_point=_geo_point, period=_period)


class InputMediaGeoPoint(TLObject):
    CONSTRUCTOR_ID = 0xf9c44144
    SUBCLASS_OF_ID = 0xfaf846f4

    def __init__(self, geo_point):
        """
        :param TypeInputGeoPoint geo_point:

        Constructor for InputMedia: Instance of either InputMediaEmpty, InputMediaUploadedPhoto, InputMediaPhoto, InputMediaGeoPoint, InputMediaContact, InputMediaUploadedDocument, InputMediaDocument, InputMediaVenue, InputMediaGifExternal, InputMediaPhotoExternal, InputMediaDocumentExternal, InputMediaGame, InputMediaInvoice, InputMediaGeoLive.
        """
        self.geo_point = geo_point  # type: TypeInputGeoPoint

    def to_dict(self):
        return {
            '_': 'InputMediaGeoPoint',
            'geo_point': None if self.geo_point is None else self.geo_point.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'DA\xc4\xf9',
            bytes(self.geo_point),
        ))

    @classmethod
    def from_reader(cls, reader):
        _geo_point = reader.tgread_object()
        return cls(geo_point=_geo_point)


class InputMediaGifExternal(TLObject):
    CONSTRUCTOR_ID = 0x4843b0fd
    SUBCLASS_OF_ID = 0xfaf846f4

    def __init__(self, url, q):
        """
        :param str url:
        :param str q:

        Constructor for InputMedia: Instance of either InputMediaEmpty, InputMediaUploadedPhoto, InputMediaPhoto, InputMediaGeoPoint, InputMediaContact, InputMediaUploadedDocument, InputMediaDocument, InputMediaVenue, InputMediaGifExternal, InputMediaPhotoExternal, InputMediaDocumentExternal, InputMediaGame, InputMediaInvoice, InputMediaGeoLive.
        """
        self.url = url  # type: str
        self.q = q  # type: str

    def to_dict(self):
        return {
            '_': 'InputMediaGifExternal',
            'url': self.url,
            'q': self.q
        }

    def __bytes__(self):
        return b''.join((
            b'\xfd\xb0CH',
            self.serialize_bytes(self.url),
            self.serialize_bytes(self.q),
        ))

    @classmethod
    def from_reader(cls, reader):
        _url = reader.tgread_string()
        _q = reader.tgread_string()
        return cls(url=_url, q=_q)


class InputMediaInvoice(TLObject):
    CONSTRUCTOR_ID = 0xf4e096c3
    SUBCLASS_OF_ID = 0xfaf846f4

    def __init__(self, title, description, invoice, payload, provider, provider_data, start_param, photo=None):
        """
        :param str title:
        :param str description:
        :param TypeInvoice invoice:
        :param bytes payload:
        :param str provider:
        :param TypeDataJSON provider_data:
        :param str start_param:
        :param Optional[TypeInputWebDocument] photo:

        Constructor for InputMedia: Instance of either InputMediaEmpty, InputMediaUploadedPhoto, InputMediaPhoto, InputMediaGeoPoint, InputMediaContact, InputMediaUploadedDocument, InputMediaDocument, InputMediaVenue, InputMediaGifExternal, InputMediaPhotoExternal, InputMediaDocumentExternal, InputMediaGame, InputMediaInvoice, InputMediaGeoLive.
        """
        self.title = title  # type: str
        self.description = description  # type: str
        self.invoice = invoice  # type: TypeInvoice
        self.payload = payload  # type: bytes
        self.provider = provider  # type: str
        self.provider_data = provider_data  # type: TypeDataJSON
        self.start_param = start_param  # type: str
        self.photo = photo  # type: Optional[TypeInputWebDocument]

    def to_dict(self):
        return {
            '_': 'InputMediaInvoice',
            'title': self.title,
            'description': self.description,
            'invoice': None if self.invoice is None else self.invoice.to_dict(),
            'payload': self.payload,
            'provider': self.provider,
            'provider_data': None if self.provider_data is None else self.provider_data.to_dict(),
            'start_param': self.start_param,
            'photo': None if self.photo is None else self.photo.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\xc3\x96\xe0\xf4',
            struct.pack('<I', (0 if self.photo is None or self.photo is False else 1)),
            self.serialize_bytes(self.title),
            self.serialize_bytes(self.description),
            b'' if self.photo is None or self.photo is False else (bytes(self.photo)),
            bytes(self.invoice),
            self.serialize_bytes(self.payload),
            self.serialize_bytes(self.provider),
            bytes(self.provider_data),
            self.serialize_bytes(self.start_param),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _title = reader.tgread_string()
        _description = reader.tgread_string()
        if flags & 1:
            _photo = reader.tgread_object()
        else:
            _photo = None
        _invoice = reader.tgread_object()
        _payload = reader.tgread_bytes()
        _provider = reader.tgread_string()
        _provider_data = reader.tgread_object()
        _start_param = reader.tgread_string()
        return cls(title=_title, description=_description, invoice=_invoice, payload=_payload, provider=_provider, provider_data=_provider_data, start_param=_start_param, photo=_photo)


class InputMediaPhoto(TLObject):
    CONSTRUCTOR_ID = 0xb3ba0635
    SUBCLASS_OF_ID = 0xfaf846f4

    def __init__(self, id, ttl_seconds=None):
        """
        :param TypeInputPhoto id:
        :param Optional[int] ttl_seconds:

        Constructor for InputMedia: Instance of either InputMediaEmpty, InputMediaUploadedPhoto, InputMediaPhoto, InputMediaGeoPoint, InputMediaContact, InputMediaUploadedDocument, InputMediaDocument, InputMediaVenue, InputMediaGifExternal, InputMediaPhotoExternal, InputMediaDocumentExternal, InputMediaGame, InputMediaInvoice, InputMediaGeoLive.
        """
        self.id = id  # type: TypeInputPhoto
        self.ttl_seconds = ttl_seconds  # type: Optional[int]

    def to_dict(self):
        return {
            '_': 'InputMediaPhoto',
            'id': None if self.id is None else self.id.to_dict(),
            'ttl_seconds': self.ttl_seconds
        }

    def __bytes__(self):
        return b''.join((
            b'5\x06\xba\xb3',
            struct.pack('<I', (0 if self.ttl_seconds is None or self.ttl_seconds is False else 1)),
            bytes(self.id),
            b'' if self.ttl_seconds is None or self.ttl_seconds is False else (struct.pack('<i', self.ttl_seconds)),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _id = reader.tgread_object()
        if flags & 1:
            _ttl_seconds = reader.read_int()
        else:
            _ttl_seconds = None
        return cls(id=_id, ttl_seconds=_ttl_seconds)


class InputMediaPhotoExternal(TLObject):
    CONSTRUCTOR_ID = 0xe5bbfe1a
    SUBCLASS_OF_ID = 0xfaf846f4

    def __init__(self, url, ttl_seconds=None):
        """
        :param str url:
        :param Optional[int] ttl_seconds:

        Constructor for InputMedia: Instance of either InputMediaEmpty, InputMediaUploadedPhoto, InputMediaPhoto, InputMediaGeoPoint, InputMediaContact, InputMediaUploadedDocument, InputMediaDocument, InputMediaVenue, InputMediaGifExternal, InputMediaPhotoExternal, InputMediaDocumentExternal, InputMediaGame, InputMediaInvoice, InputMediaGeoLive.
        """
        self.url = url  # type: str
        self.ttl_seconds = ttl_seconds  # type: Optional[int]

    def to_dict(self):
        return {
            '_': 'InputMediaPhotoExternal',
            'url': self.url,
            'ttl_seconds': self.ttl_seconds
        }

    def __bytes__(self):
        return b''.join((
            b'\x1a\xfe\xbb\xe5',
            struct.pack('<I', (0 if self.ttl_seconds is None or self.ttl_seconds is False else 1)),
            self.serialize_bytes(self.url),
            b'' if self.ttl_seconds is None or self.ttl_seconds is False else (struct.pack('<i', self.ttl_seconds)),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _url = reader.tgread_string()
        if flags & 1:
            _ttl_seconds = reader.read_int()
        else:
            _ttl_seconds = None
        return cls(url=_url, ttl_seconds=_ttl_seconds)


class InputMediaUploadedDocument(TLObject):
    CONSTRUCTOR_ID = 0x5b38c6c1
    SUBCLASS_OF_ID = 0xfaf846f4

    def __init__(self, file, mime_type, attributes, nosound_video=None, thumb=None, stickers=None, ttl_seconds=None):
        """
        :param TypeInputFile file:
        :param str mime_type:
        :param List[TypeDocumentAttribute] attributes:
        :param Optional[bool] nosound_video:
        :param Optional[TypeInputFile] thumb:
        :param Optional[List[TypeInputDocument]] stickers:
        :param Optional[int] ttl_seconds:

        Constructor for InputMedia: Instance of either InputMediaEmpty, InputMediaUploadedPhoto, InputMediaPhoto, InputMediaGeoPoint, InputMediaContact, InputMediaUploadedDocument, InputMediaDocument, InputMediaVenue, InputMediaGifExternal, InputMediaPhotoExternal, InputMediaDocumentExternal, InputMediaGame, InputMediaInvoice, InputMediaGeoLive.
        """
        self.file = file  # type: TypeInputFile
        self.mime_type = mime_type  # type: str
        self.attributes = attributes  # type: List[TypeDocumentAttribute]
        self.nosound_video = nosound_video  # type: Optional[bool]
        self.thumb = thumb  # type: Optional[TypeInputFile]
        self.stickers = stickers  # type: Optional[List[TypeInputDocument]]
        self.ttl_seconds = ttl_seconds  # type: Optional[int]

    def to_dict(self):
        return {
            '_': 'InputMediaUploadedDocument',
            'file': None if self.file is None else self.file.to_dict(),
            'mime_type': self.mime_type,
            'attributes': [] if self.attributes is None else [None if x is None else x.to_dict() for x in self.attributes],
            'nosound_video': self.nosound_video,
            'thumb': None if self.thumb is None else self.thumb.to_dict(),
            'stickers': [] if self.stickers is None else [None if x is None else x.to_dict() for x in self.stickers],
            'ttl_seconds': self.ttl_seconds
        }

    def __bytes__(self):
        return b''.join((
            b'\xc1\xc68[',
            struct.pack('<I', (0 if self.nosound_video is None or self.nosound_video is False else 8) | (0 if self.thumb is None or self.thumb is False else 4) | (0 if self.stickers is None or self.stickers is False else 1) | (0 if self.ttl_seconds is None or self.ttl_seconds is False else 2)),
            bytes(self.file),
            b'' if self.thumb is None or self.thumb is False else (bytes(self.thumb)),
            self.serialize_bytes(self.mime_type),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.attributes)),b''.join(bytes(x) for x in self.attributes),
            b'' if self.stickers is None or self.stickers is False else b''.join((b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.stickers)),b''.join(bytes(x) for x in self.stickers))),
            b'' if self.ttl_seconds is None or self.ttl_seconds is False else (struct.pack('<i', self.ttl_seconds)),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _nosound_video = bool(flags & 8)
        _file = reader.tgread_object()
        if flags & 4:
            _thumb = reader.tgread_object()
        else:
            _thumb = None
        _mime_type = reader.tgread_string()
        reader.read_int()
        _attributes = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _attributes.append(_x)

        if flags & 1:
            reader.read_int()
            _stickers = []
            for _ in range(reader.read_int()):
                _x = reader.tgread_object()
                _stickers.append(_x)

        else:
            _stickers = None
        if flags & 2:
            _ttl_seconds = reader.read_int()
        else:
            _ttl_seconds = None
        return cls(file=_file, mime_type=_mime_type, attributes=_attributes, nosound_video=_nosound_video, thumb=_thumb, stickers=_stickers, ttl_seconds=_ttl_seconds)


class InputMediaUploadedPhoto(TLObject):
    CONSTRUCTOR_ID = 0x1e287d04
    SUBCLASS_OF_ID = 0xfaf846f4

    def __init__(self, file, stickers=None, ttl_seconds=None):
        """
        :param TypeInputFile file:
        :param Optional[List[TypeInputDocument]] stickers:
        :param Optional[int] ttl_seconds:

        Constructor for InputMedia: Instance of either InputMediaEmpty, InputMediaUploadedPhoto, InputMediaPhoto, InputMediaGeoPoint, InputMediaContact, InputMediaUploadedDocument, InputMediaDocument, InputMediaVenue, InputMediaGifExternal, InputMediaPhotoExternal, InputMediaDocumentExternal, InputMediaGame, InputMediaInvoice, InputMediaGeoLive.
        """
        self.file = file  # type: TypeInputFile
        self.stickers = stickers  # type: Optional[List[TypeInputDocument]]
        self.ttl_seconds = ttl_seconds  # type: Optional[int]

    def to_dict(self):
        return {
            '_': 'InputMediaUploadedPhoto',
            'file': None if self.file is None else self.file.to_dict(),
            'stickers': [] if self.stickers is None else [None if x is None else x.to_dict() for x in self.stickers],
            'ttl_seconds': self.ttl_seconds
        }

    def __bytes__(self):
        return b''.join((
            b'\x04}(\x1e',
            struct.pack('<I', (0 if self.stickers is None or self.stickers is False else 1) | (0 if self.ttl_seconds is None or self.ttl_seconds is False else 2)),
            bytes(self.file),
            b'' if self.stickers is None or self.stickers is False else b''.join((b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.stickers)),b''.join(bytes(x) for x in self.stickers))),
            b'' if self.ttl_seconds is None or self.ttl_seconds is False else (struct.pack('<i', self.ttl_seconds)),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _file = reader.tgread_object()
        if flags & 1:
            reader.read_int()
            _stickers = []
            for _ in range(reader.read_int()):
                _x = reader.tgread_object()
                _stickers.append(_x)

        else:
            _stickers = None
        if flags & 2:
            _ttl_seconds = reader.read_int()
        else:
            _ttl_seconds = None
        return cls(file=_file, stickers=_stickers, ttl_seconds=_ttl_seconds)


class InputMediaVenue(TLObject):
    CONSTRUCTOR_ID = 0xc13d1c11
    SUBCLASS_OF_ID = 0xfaf846f4

    def __init__(self, geo_point, title, address, provider, venue_id, venue_type):
        """
        :param TypeInputGeoPoint geo_point:
        :param str title:
        :param str address:
        :param str provider:
        :param str venue_id:
        :param str venue_type:

        Constructor for InputMedia: Instance of either InputMediaEmpty, InputMediaUploadedPhoto, InputMediaPhoto, InputMediaGeoPoint, InputMediaContact, InputMediaUploadedDocument, InputMediaDocument, InputMediaVenue, InputMediaGifExternal, InputMediaPhotoExternal, InputMediaDocumentExternal, InputMediaGame, InputMediaInvoice, InputMediaGeoLive.
        """
        self.geo_point = geo_point  # type: TypeInputGeoPoint
        self.title = title  # type: str
        self.address = address  # type: str
        self.provider = provider  # type: str
        self.venue_id = venue_id  # type: str
        self.venue_type = venue_type  # type: str

    def to_dict(self):
        return {
            '_': 'InputMediaVenue',
            'geo_point': None if self.geo_point is None else self.geo_point.to_dict(),
            'title': self.title,
            'address': self.address,
            'provider': self.provider,
            'venue_id': self.venue_id,
            'venue_type': self.venue_type
        }

    def __bytes__(self):
        return b''.join((
            b'\x11\x1c=\xc1',
            bytes(self.geo_point),
            self.serialize_bytes(self.title),
            self.serialize_bytes(self.address),
            self.serialize_bytes(self.provider),
            self.serialize_bytes(self.venue_id),
            self.serialize_bytes(self.venue_type),
        ))

    @classmethod
    def from_reader(cls, reader):
        _geo_point = reader.tgread_object()
        _title = reader.tgread_string()
        _address = reader.tgread_string()
        _provider = reader.tgread_string()
        _venue_id = reader.tgread_string()
        _venue_type = reader.tgread_string()
        return cls(geo_point=_geo_point, title=_title, address=_address, provider=_provider, venue_id=_venue_id, venue_type=_venue_type)


class InputMessageEntityMentionName(TLObject):
    CONSTRUCTOR_ID = 0x208e68c9
    SUBCLASS_OF_ID = 0xcf6419dc

    def __init__(self, offset, length, user_id):
        """
        :param int offset:
        :param int length:
        :param TypeInputUser user_id:

        Constructor for MessageEntity: Instance of either MessageEntityUnknown, MessageEntityMention, MessageEntityHashtag, MessageEntityBotCommand, MessageEntityUrl, MessageEntityEmail, MessageEntityBold, MessageEntityItalic, MessageEntityCode, MessageEntityPre, MessageEntityTextUrl, MessageEntityMentionName, InputMessageEntityMentionName, MessageEntityPhone, MessageEntityCashtag.
        """
        self.offset = offset  # type: int
        self.length = length  # type: int
        self.user_id = user_id  # type: TypeInputUser

    def to_dict(self):
        return {
            '_': 'InputMessageEntityMentionName',
            'offset': self.offset,
            'length': self.length,
            'user_id': None if self.user_id is None else self.user_id.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\xc9h\x8e ',
            struct.pack('<i', self.offset),
            struct.pack('<i', self.length),
            bytes(self.user_id),
        ))

    @classmethod
    def from_reader(cls, reader):
        _offset = reader.read_int()
        _length = reader.read_int()
        _user_id = reader.tgread_object()
        return cls(offset=_offset, length=_length, user_id=_user_id)


class InputMessageID(TLObject):
    CONSTRUCTOR_ID = 0xa676a322
    SUBCLASS_OF_ID = 0x54b6bcc5

    def __init__(self, id):
        """
        :param int id:

        Constructor for InputMessage: Instance of either InputMessageID, InputMessageReplyTo, InputMessagePinned.
        """
        self.id = id  # type: int

    def to_dict(self):
        return {
            '_': 'InputMessageID',
            'id': self.id
        }

    def __bytes__(self):
        return b''.join((
            b'"\xa3v\xa6',
            struct.pack('<i', self.id),
        ))

    @classmethod
    def from_reader(cls, reader):
        _id = reader.read_int()
        return cls(id=_id)


class InputMessagePinned(TLObject):
    CONSTRUCTOR_ID = 0x86872538
    SUBCLASS_OF_ID = 0x54b6bcc5

    def to_dict(self):
        return {
            '_': 'InputMessagePinned'
        }

    def __bytes__(self):
        return b''.join((
            b'8%\x87\x86',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class InputMessageReplyTo(TLObject):
    CONSTRUCTOR_ID = 0xbad88395
    SUBCLASS_OF_ID = 0x54b6bcc5

    def __init__(self, id):
        """
        :param int id:

        Constructor for InputMessage: Instance of either InputMessageID, InputMessageReplyTo, InputMessagePinned.
        """
        self.id = id  # type: int

    def to_dict(self):
        return {
            '_': 'InputMessageReplyTo',
            'id': self.id
        }

    def __bytes__(self):
        return b''.join((
            b'\x95\x83\xd8\xba',
            struct.pack('<i', self.id),
        ))

    @classmethod
    def from_reader(cls, reader):
        _id = reader.read_int()
        return cls(id=_id)


class InputMessagesFilterChatPhotos(TLObject):
    CONSTRUCTOR_ID = 0x3a20ecb8
    SUBCLASS_OF_ID = 0x8a36ec14

    def to_dict(self):
        return {
            '_': 'InputMessagesFilterChatPhotos'
        }

    def __bytes__(self):
        return b''.join((
            b'\xb8\xec :',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class InputMessagesFilterContacts(TLObject):
    CONSTRUCTOR_ID = 0xe062db83
    SUBCLASS_OF_ID = 0x8a36ec14

    def to_dict(self):
        return {
            '_': 'InputMessagesFilterContacts'
        }

    def __bytes__(self):
        return b''.join((
            b'\x83\xdbb\xe0',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class InputMessagesFilterDocument(TLObject):
    CONSTRUCTOR_ID = 0x9eddf188
    SUBCLASS_OF_ID = 0x8a36ec14

    def to_dict(self):
        return {
            '_': 'InputMessagesFilterDocument'
        }

    def __bytes__(self):
        return b''.join((
            b'\x88\xf1\xdd\x9e',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class InputMessagesFilterEmpty(TLObject):
    CONSTRUCTOR_ID = 0x57e2f66c
    SUBCLASS_OF_ID = 0x8a36ec14

    def to_dict(self):
        return {
            '_': 'InputMessagesFilterEmpty'
        }

    def __bytes__(self):
        return b''.join((
            b'l\xf6\xe2W',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class InputMessagesFilterGeo(TLObject):
    CONSTRUCTOR_ID = 0xe7026d0d
    SUBCLASS_OF_ID = 0x8a36ec14

    def to_dict(self):
        return {
            '_': 'InputMessagesFilterGeo'
        }

    def __bytes__(self):
        return b''.join((
            b'\rm\x02\xe7',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class InputMessagesFilterGif(TLObject):
    CONSTRUCTOR_ID = 0xffc86587
    SUBCLASS_OF_ID = 0x8a36ec14

    def to_dict(self):
        return {
            '_': 'InputMessagesFilterGif'
        }

    def __bytes__(self):
        return b''.join((
            b'\x87e\xc8\xff',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class InputMessagesFilterMusic(TLObject):
    CONSTRUCTOR_ID = 0x3751b49e
    SUBCLASS_OF_ID = 0x8a36ec14

    def to_dict(self):
        return {
            '_': 'InputMessagesFilterMusic'
        }

    def __bytes__(self):
        return b''.join((
            b'\x9e\xb4Q7',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class InputMessagesFilterMyMentions(TLObject):
    CONSTRUCTOR_ID = 0xc1f8e69a
    SUBCLASS_OF_ID = 0x8a36ec14

    def to_dict(self):
        return {
            '_': 'InputMessagesFilterMyMentions'
        }

    def __bytes__(self):
        return b''.join((
            b'\x9a\xe6\xf8\xc1',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class InputMessagesFilterPhoneCalls(TLObject):
    CONSTRUCTOR_ID = 0x80c99768
    SUBCLASS_OF_ID = 0x8a36ec14

    def __init__(self, missed=None):
        """
        :param Optional[bool] missed:

        Constructor for MessagesFilter: Instance of either InputMessagesFilterEmpty, InputMessagesFilterPhotos, InputMessagesFilterVideo, InputMessagesFilterPhotoVideo, InputMessagesFilterDocument, InputMessagesFilterUrl, InputMessagesFilterGif, InputMessagesFilterVoice, InputMessagesFilterMusic, InputMessagesFilterChatPhotos, InputMessagesFilterPhoneCalls, InputMessagesFilterRoundVoice, InputMessagesFilterRoundVideo, InputMessagesFilterMyMentions, InputMessagesFilterGeo, InputMessagesFilterContacts.
        """
        self.missed = missed  # type: Optional[bool]

    def to_dict(self):
        return {
            '_': 'InputMessagesFilterPhoneCalls',
            'missed': self.missed
        }

    def __bytes__(self):
        return b''.join((
            b'h\x97\xc9\x80',
            struct.pack('<I', (0 if self.missed is None or self.missed is False else 1)),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _missed = bool(flags & 1)
        return cls(missed=_missed)


class InputMessagesFilterPhotoVideo(TLObject):
    CONSTRUCTOR_ID = 0x56e9f0e4
    SUBCLASS_OF_ID = 0x8a36ec14

    def to_dict(self):
        return {
            '_': 'InputMessagesFilterPhotoVideo'
        }

    def __bytes__(self):
        return b''.join((
            b'\xe4\xf0\xe9V',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class InputMessagesFilterPhotos(TLObject):
    CONSTRUCTOR_ID = 0x9609a51c
    SUBCLASS_OF_ID = 0x8a36ec14

    def to_dict(self):
        return {
            '_': 'InputMessagesFilterPhotos'
        }

    def __bytes__(self):
        return b''.join((
            b'\x1c\xa5\t\x96',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class InputMessagesFilterRoundVideo(TLObject):
    CONSTRUCTOR_ID = 0xb549da53
    SUBCLASS_OF_ID = 0x8a36ec14

    def to_dict(self):
        return {
            '_': 'InputMessagesFilterRoundVideo'
        }

    def __bytes__(self):
        return b''.join((
            b'S\xdaI\xb5',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class InputMessagesFilterRoundVoice(TLObject):
    CONSTRUCTOR_ID = 0x7a7c17a4
    SUBCLASS_OF_ID = 0x8a36ec14

    def to_dict(self):
        return {
            '_': 'InputMessagesFilterRoundVoice'
        }

    def __bytes__(self):
        return b''.join((
            b'\xa4\x17|z',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class InputMessagesFilterUrl(TLObject):
    CONSTRUCTOR_ID = 0x7ef0dd87
    SUBCLASS_OF_ID = 0x8a36ec14

    def to_dict(self):
        return {
            '_': 'InputMessagesFilterUrl'
        }

    def __bytes__(self):
        return b''.join((
            b'\x87\xdd\xf0~',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class InputMessagesFilterVideo(TLObject):
    CONSTRUCTOR_ID = 0x9fc00e65
    SUBCLASS_OF_ID = 0x8a36ec14

    def to_dict(self):
        return {
            '_': 'InputMessagesFilterVideo'
        }

    def __bytes__(self):
        return b''.join((
            b'e\x0e\xc0\x9f',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class InputMessagesFilterVoice(TLObject):
    CONSTRUCTOR_ID = 0x50f5c392
    SUBCLASS_OF_ID = 0x8a36ec14

    def to_dict(self):
        return {
            '_': 'InputMessagesFilterVoice'
        }

    def __bytes__(self):
        return b''.join((
            b'\x92\xc3\xf5P',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class InputNotifyChats(TLObject):
    CONSTRUCTOR_ID = 0x4a95e84e
    SUBCLASS_OF_ID = 0x58981615

    def to_dict(self):
        return {
            '_': 'InputNotifyChats'
        }

    def __bytes__(self):
        return b''.join((
            b'N\xe8\x95J',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class InputNotifyPeer(TLObject):
    CONSTRUCTOR_ID = 0xb8bc5b0c
    SUBCLASS_OF_ID = 0x58981615

    def __init__(self, peer):
        """
        :param TypeInputPeer peer:

        Constructor for InputNotifyPeer: Instance of either InputNotifyPeer, InputNotifyUsers, InputNotifyChats.
        """
        self.peer = peer  # type: TypeInputPeer

    def to_dict(self):
        return {
            '_': 'InputNotifyPeer',
            'peer': None if self.peer is None else self.peer.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\x0c[\xbc\xb8',
            bytes(self.peer),
        ))

    @classmethod
    def from_reader(cls, reader):
        _peer = reader.tgread_object()
        return cls(peer=_peer)


class InputNotifyUsers(TLObject):
    CONSTRUCTOR_ID = 0x193b4417
    SUBCLASS_OF_ID = 0x58981615

    def to_dict(self):
        return {
            '_': 'InputNotifyUsers'
        }

    def __bytes__(self):
        return b''.join((
            b'\x17D;\x19',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class InputPaymentCredentials(TLObject):
    CONSTRUCTOR_ID = 0x3417d728
    SUBCLASS_OF_ID = 0x2899a53d

    def __init__(self, data, save=None):
        """
        :param TypeDataJSON data:
        :param Optional[bool] save:

        Constructor for InputPaymentCredentials: Instance of either InputPaymentCredentialsSaved, InputPaymentCredentials, InputPaymentCredentialsApplePay, InputPaymentCredentialsAndroidPay.
        """
        self.data = data  # type: TypeDataJSON
        self.save = save  # type: Optional[bool]

    def to_dict(self):
        return {
            '_': 'InputPaymentCredentials',
            'data': None if self.data is None else self.data.to_dict(),
            'save': self.save
        }

    def __bytes__(self):
        return b''.join((
            b'(\xd7\x174',
            struct.pack('<I', (0 if self.save is None or self.save is False else 1)),
            bytes(self.data),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _save = bool(flags & 1)
        _data = reader.tgread_object()
        return cls(data=_data, save=_save)


class InputPaymentCredentialsAndroidPay(TLObject):
    CONSTRUCTOR_ID = 0xca05d50e
    SUBCLASS_OF_ID = 0x2899a53d

    def __init__(self, payment_token, google_transaction_id):
        """
        :param TypeDataJSON payment_token:
        :param str google_transaction_id:

        Constructor for InputPaymentCredentials: Instance of either InputPaymentCredentialsSaved, InputPaymentCredentials, InputPaymentCredentialsApplePay, InputPaymentCredentialsAndroidPay.
        """
        self.payment_token = payment_token  # type: TypeDataJSON
        self.google_transaction_id = google_transaction_id  # type: str

    def to_dict(self):
        return {
            '_': 'InputPaymentCredentialsAndroidPay',
            'payment_token': None if self.payment_token is None else self.payment_token.to_dict(),
            'google_transaction_id': self.google_transaction_id
        }

    def __bytes__(self):
        return b''.join((
            b'\x0e\xd5\x05\xca',
            bytes(self.payment_token),
            self.serialize_bytes(self.google_transaction_id),
        ))

    @classmethod
    def from_reader(cls, reader):
        _payment_token = reader.tgread_object()
        _google_transaction_id = reader.tgread_string()
        return cls(payment_token=_payment_token, google_transaction_id=_google_transaction_id)


class InputPaymentCredentialsApplePay(TLObject):
    CONSTRUCTOR_ID = 0xaa1c39f
    SUBCLASS_OF_ID = 0x2899a53d

    def __init__(self, payment_data):
        """
        :param TypeDataJSON payment_data:

        Constructor for InputPaymentCredentials: Instance of either InputPaymentCredentialsSaved, InputPaymentCredentials, InputPaymentCredentialsApplePay, InputPaymentCredentialsAndroidPay.
        """
        self.payment_data = payment_data  # type: TypeDataJSON

    def to_dict(self):
        return {
            '_': 'InputPaymentCredentialsApplePay',
            'payment_data': None if self.payment_data is None else self.payment_data.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\x9f\xc3\xa1\n',
            bytes(self.payment_data),
        ))

    @classmethod
    def from_reader(cls, reader):
        _payment_data = reader.tgread_object()
        return cls(payment_data=_payment_data)


class InputPaymentCredentialsSaved(TLObject):
    CONSTRUCTOR_ID = 0xc10eb2cf
    SUBCLASS_OF_ID = 0x2899a53d

    def __init__(self, id, tmp_password):
        """
        :param str id:
        :param bytes tmp_password:

        Constructor for InputPaymentCredentials: Instance of either InputPaymentCredentialsSaved, InputPaymentCredentials, InputPaymentCredentialsApplePay, InputPaymentCredentialsAndroidPay.
        """
        self.id = id  # type: str
        self.tmp_password = tmp_password  # type: bytes

    def to_dict(self):
        return {
            '_': 'InputPaymentCredentialsSaved',
            'id': self.id,
            'tmp_password': self.tmp_password
        }

    def __bytes__(self):
        return b''.join((
            b'\xcf\xb2\x0e\xc1',
            self.serialize_bytes(self.id),
            self.serialize_bytes(self.tmp_password),
        ))

    @classmethod
    def from_reader(cls, reader):
        _id = reader.tgread_string()
        _tmp_password = reader.tgread_bytes()
        return cls(id=_id, tmp_password=_tmp_password)


class InputPeerChannel(TLObject):
    CONSTRUCTOR_ID = 0x20adaef8
    SUBCLASS_OF_ID = 0xc91c90b6

    def __init__(self, channel_id, access_hash):
        """
        :param int channel_id:
        :param int access_hash:

        Constructor for InputPeer: Instance of either InputPeerEmpty, InputPeerSelf, InputPeerChat, InputPeerUser, InputPeerChannel.
        """
        self.channel_id = channel_id  # type: int
        self.access_hash = access_hash  # type: int

    def to_dict(self):
        return {
            '_': 'InputPeerChannel',
            'channel_id': self.channel_id,
            'access_hash': self.access_hash
        }

    def __bytes__(self):
        return b''.join((
            b'\xf8\xae\xad ',
            struct.pack('<i', self.channel_id),
            struct.pack('<q', self.access_hash),
        ))

    @classmethod
    def from_reader(cls, reader):
        _channel_id = reader.read_int()
        _access_hash = reader.read_long()
        return cls(channel_id=_channel_id, access_hash=_access_hash)


class InputPeerChat(TLObject):
    CONSTRUCTOR_ID = 0x179be863
    SUBCLASS_OF_ID = 0xc91c90b6

    def __init__(self, chat_id):
        """
        :param int chat_id:

        Constructor for InputPeer: Instance of either InputPeerEmpty, InputPeerSelf, InputPeerChat, InputPeerUser, InputPeerChannel.
        """
        self.chat_id = chat_id  # type: int

    def to_dict(self):
        return {
            '_': 'InputPeerChat',
            'chat_id': self.chat_id
        }

    def __bytes__(self):
        return b''.join((
            b'c\xe8\x9b\x17',
            struct.pack('<i', self.chat_id),
        ))

    @classmethod
    def from_reader(cls, reader):
        _chat_id = reader.read_int()
        return cls(chat_id=_chat_id)


class InputPeerEmpty(TLObject):
    CONSTRUCTOR_ID = 0x7f3b18ea
    SUBCLASS_OF_ID = 0xc91c90b6

    def to_dict(self):
        return {
            '_': 'InputPeerEmpty'
        }

    def __bytes__(self):
        return b''.join((
            b'\xea\x18;\x7f',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class InputPeerNotifySettings(TLObject):
    CONSTRUCTOR_ID = 0x9c3d198e
    SUBCLASS_OF_ID = 0x90db0b0d

    def __init__(self, show_previews=None, silent=None, mute_until=None, sound=None):
        """
        :param Optional[TypeBool] show_previews:
        :param Optional[TypeBool] silent:
        :param Optional[int] mute_until:
        :param Optional[str] sound:

        Constructor for InputPeerNotifySettings: Instance of InputPeerNotifySettings.
        """
        self.show_previews = show_previews  # type: Optional[TypeBool]
        self.silent = silent  # type: Optional[TypeBool]
        self.mute_until = mute_until  # type: Optional[int]
        self.sound = sound  # type: Optional[str]

    def to_dict(self):
        return {
            '_': 'InputPeerNotifySettings',
            'show_previews': self.show_previews,
            'silent': self.silent,
            'mute_until': self.mute_until,
            'sound': self.sound
        }

    def __bytes__(self):
        return b''.join((
            b'\x8e\x19=\x9c',
            struct.pack('<I', (0 if self.show_previews is None or self.show_previews is False else 1) | (0 if self.silent is None or self.silent is False else 2) | (0 if self.mute_until is None or self.mute_until is False else 4) | (0 if self.sound is None or self.sound is False else 8)),
            b'' if self.show_previews is None or self.show_previews is False else (b'\xb5ur\x99' if self.show_previews else b'7\x97y\xbc'),
            b'' if self.silent is None or self.silent is False else (b'\xb5ur\x99' if self.silent else b'7\x97y\xbc'),
            b'' if self.mute_until is None or self.mute_until is False else (struct.pack('<i', self.mute_until)),
            b'' if self.sound is None or self.sound is False else (self.serialize_bytes(self.sound)),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        if flags & 1:
            _show_previews = reader.tgread_bool()
        else:
            _show_previews = None
        if flags & 2:
            _silent = reader.tgread_bool()
        else:
            _silent = None
        if flags & 4:
            _mute_until = reader.read_int()
        else:
            _mute_until = None
        if flags & 8:
            _sound = reader.tgread_string()
        else:
            _sound = None
        return cls(show_previews=_show_previews, silent=_silent, mute_until=_mute_until, sound=_sound)


class InputPeerSelf(TLObject):
    CONSTRUCTOR_ID = 0x7da07ec9
    SUBCLASS_OF_ID = 0xc91c90b6

    def to_dict(self):
        return {
            '_': 'InputPeerSelf'
        }

    def __bytes__(self):
        return b''.join((
            b'\xc9~\xa0}',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class InputPeerUser(TLObject):
    CONSTRUCTOR_ID = 0x7b8e7de6
    SUBCLASS_OF_ID = 0xc91c90b6

    def __init__(self, user_id, access_hash):
        """
        :param int user_id:
        :param int access_hash:

        Constructor for InputPeer: Instance of either InputPeerEmpty, InputPeerSelf, InputPeerChat, InputPeerUser, InputPeerChannel.
        """
        self.user_id = user_id  # type: int
        self.access_hash = access_hash  # type: int

    def to_dict(self):
        return {
            '_': 'InputPeerUser',
            'user_id': self.user_id,
            'access_hash': self.access_hash
        }

    def __bytes__(self):
        return b''.join((
            b'\xe6}\x8e{',
            struct.pack('<i', self.user_id),
            struct.pack('<q', self.access_hash),
        ))

    @classmethod
    def from_reader(cls, reader):
        _user_id = reader.read_int()
        _access_hash = reader.read_long()
        return cls(user_id=_user_id, access_hash=_access_hash)


class InputPhoneCall(TLObject):
    CONSTRUCTOR_ID = 0x1e36fded
    SUBCLASS_OF_ID = 0xbcaaf240

    def __init__(self, id, access_hash):
        """
        :param int id:
        :param int access_hash:

        Constructor for InputPhoneCall: Instance of InputPhoneCall.
        """
        self.id = id  # type: int
        self.access_hash = access_hash  # type: int

    def to_dict(self):
        return {
            '_': 'InputPhoneCall',
            'id': self.id,
            'access_hash': self.access_hash
        }

    def __bytes__(self):
        return b''.join((
            b'\xed\xfd6\x1e',
            struct.pack('<q', self.id),
            struct.pack('<q', self.access_hash),
        ))

    @classmethod
    def from_reader(cls, reader):
        _id = reader.read_long()
        _access_hash = reader.read_long()
        return cls(id=_id, access_hash=_access_hash)


class InputPhoneContact(TLObject):
    CONSTRUCTOR_ID = 0xf392b7f4
    SUBCLASS_OF_ID = 0xae696a82

    def __init__(self, client_id, phone, first_name, last_name):
        """
        :param int client_id:
        :param str phone:
        :param str first_name:
        :param str last_name:

        Constructor for InputContact: Instance of InputPhoneContact.
        """
        self.client_id = client_id  # type: int
        self.phone = phone  # type: str
        self.first_name = first_name  # type: str
        self.last_name = last_name  # type: str

    def to_dict(self):
        return {
            '_': 'InputPhoneContact',
            'client_id': self.client_id,
            'phone': self.phone,
            'first_name': self.first_name,
            'last_name': self.last_name
        }

    def __bytes__(self):
        return b''.join((
            b'\xf4\xb7\x92\xf3',
            struct.pack('<q', self.client_id),
            self.serialize_bytes(self.phone),
            self.serialize_bytes(self.first_name),
            self.serialize_bytes(self.last_name),
        ))

    @classmethod
    def from_reader(cls, reader):
        _client_id = reader.read_long()
        _phone = reader.tgread_string()
        _first_name = reader.tgread_string()
        _last_name = reader.tgread_string()
        return cls(client_id=_client_id, phone=_phone, first_name=_first_name, last_name=_last_name)


class InputPhoto(TLObject):
    CONSTRUCTOR_ID = 0xfb95c6c4
    SUBCLASS_OF_ID = 0x846363e0

    def __init__(self, id, access_hash):
        """
        :param int id:
        :param int access_hash:

        Constructor for InputPhoto: Instance of either InputPhotoEmpty, InputPhoto.
        """
        self.id = id  # type: int
        self.access_hash = access_hash  # type: int

    def to_dict(self):
        return {
            '_': 'InputPhoto',
            'id': self.id,
            'access_hash': self.access_hash
        }

    def __bytes__(self):
        return b''.join((
            b'\xc4\xc6\x95\xfb',
            struct.pack('<q', self.id),
            struct.pack('<q', self.access_hash),
        ))

    @classmethod
    def from_reader(cls, reader):
        _id = reader.read_long()
        _access_hash = reader.read_long()
        return cls(id=_id, access_hash=_access_hash)


class InputPhotoEmpty(TLObject):
    CONSTRUCTOR_ID = 0x1cd7bf0d
    SUBCLASS_OF_ID = 0x846363e0

    def to_dict(self):
        return {
            '_': 'InputPhotoEmpty'
        }

    def __bytes__(self):
        return b''.join((
            b'\r\xbf\xd7\x1c',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class InputPrivacyKeyChatInvite(TLObject):
    CONSTRUCTOR_ID = 0xbdfb0426
    SUBCLASS_OF_ID = 0x53627f8

    def to_dict(self):
        return {
            '_': 'InputPrivacyKeyChatInvite'
        }

    def __bytes__(self):
        return b''.join((
            b'&\x04\xfb\xbd',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class InputPrivacyKeyPhoneCall(TLObject):
    CONSTRUCTOR_ID = 0xfabadc5f
    SUBCLASS_OF_ID = 0x53627f8

    def to_dict(self):
        return {
            '_': 'InputPrivacyKeyPhoneCall'
        }

    def __bytes__(self):
        return b''.join((
            b'_\xdc\xba\xfa',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class InputPrivacyKeyStatusTimestamp(TLObject):
    CONSTRUCTOR_ID = 0x4f96cb18
    SUBCLASS_OF_ID = 0x53627f8

    def to_dict(self):
        return {
            '_': 'InputPrivacyKeyStatusTimestamp'
        }

    def __bytes__(self):
        return b''.join((
            b'\x18\xcb\x96O',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class InputPrivacyValueAllowAll(TLObject):
    CONSTRUCTOR_ID = 0x184b35ce
    SUBCLASS_OF_ID = 0x5a3b6b22

    def to_dict(self):
        return {
            '_': 'InputPrivacyValueAllowAll'
        }

    def __bytes__(self):
        return b''.join((
            b'\xce5K\x18',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class InputPrivacyValueAllowContacts(TLObject):
    CONSTRUCTOR_ID = 0xd09e07b
    SUBCLASS_OF_ID = 0x5a3b6b22

    def to_dict(self):
        return {
            '_': 'InputPrivacyValueAllowContacts'
        }

    def __bytes__(self):
        return b''.join((
            b'{\xe0\t\r',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class InputPrivacyValueAllowUsers(TLObject):
    CONSTRUCTOR_ID = 0x131cc67f
    SUBCLASS_OF_ID = 0x5a3b6b22

    def __init__(self, users):
        """
        :param List[TypeInputUser] users:

        Constructor for InputPrivacyRule: Instance of either InputPrivacyValueAllowContacts, InputPrivacyValueAllowAll, InputPrivacyValueAllowUsers, InputPrivacyValueDisallowContacts, InputPrivacyValueDisallowAll, InputPrivacyValueDisallowUsers.
        """
        self.users = users  # type: List[TypeInputUser]

    def to_dict(self):
        return {
            '_': 'InputPrivacyValueAllowUsers',
            'users': [] if self.users is None else [None if x is None else x.to_dict() for x in self.users]
        }

    def __bytes__(self):
        return b''.join((
            b'\x7f\xc6\x1c\x13',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.users)),b''.join(bytes(x) for x in self.users),
        ))

    @classmethod
    def from_reader(cls, reader):
        reader.read_int()
        _users = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _users.append(_x)

        return cls(users=_users)


class InputPrivacyValueDisallowAll(TLObject):
    CONSTRUCTOR_ID = 0xd66b66c9
    SUBCLASS_OF_ID = 0x5a3b6b22

    def to_dict(self):
        return {
            '_': 'InputPrivacyValueDisallowAll'
        }

    def __bytes__(self):
        return b''.join((
            b'\xc9fk\xd6',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class InputPrivacyValueDisallowContacts(TLObject):
    CONSTRUCTOR_ID = 0xba52007
    SUBCLASS_OF_ID = 0x5a3b6b22

    def to_dict(self):
        return {
            '_': 'InputPrivacyValueDisallowContacts'
        }

    def __bytes__(self):
        return b''.join((
            b'\x07 \xa5\x0b',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class InputPrivacyValueDisallowUsers(TLObject):
    CONSTRUCTOR_ID = 0x90110467
    SUBCLASS_OF_ID = 0x5a3b6b22

    def __init__(self, users):
        """
        :param List[TypeInputUser] users:

        Constructor for InputPrivacyRule: Instance of either InputPrivacyValueAllowContacts, InputPrivacyValueAllowAll, InputPrivacyValueAllowUsers, InputPrivacyValueDisallowContacts, InputPrivacyValueDisallowAll, InputPrivacyValueDisallowUsers.
        """
        self.users = users  # type: List[TypeInputUser]

    def to_dict(self):
        return {
            '_': 'InputPrivacyValueDisallowUsers',
            'users': [] if self.users is None else [None if x is None else x.to_dict() for x in self.users]
        }

    def __bytes__(self):
        return b''.join((
            b'g\x04\x11\x90',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.users)),b''.join(bytes(x) for x in self.users),
        ))

    @classmethod
    def from_reader(cls, reader):
        reader.read_int()
        _users = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _users.append(_x)

        return cls(users=_users)


class InputReportReasonOther(TLObject):
    CONSTRUCTOR_ID = 0xe1746d0a
    SUBCLASS_OF_ID = 0x8401bd27

    def __init__(self, text):
        """
        :param str text:

        Constructor for ReportReason: Instance of either InputReportReasonSpam, InputReportReasonViolence, InputReportReasonPornography, InputReportReasonOther.
        """
        self.text = text  # type: str

    def to_dict(self):
        return {
            '_': 'InputReportReasonOther',
            'text': self.text
        }

    def __bytes__(self):
        return b''.join((
            b'\nmt\xe1',
            self.serialize_bytes(self.text),
        ))

    @classmethod
    def from_reader(cls, reader):
        _text = reader.tgread_string()
        return cls(text=_text)


class InputReportReasonPornography(TLObject):
    CONSTRUCTOR_ID = 0x2e59d922
    SUBCLASS_OF_ID = 0x8401bd27

    def to_dict(self):
        return {
            '_': 'InputReportReasonPornography'
        }

    def __bytes__(self):
        return b''.join((
            b'"\xd9Y.',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class InputReportReasonSpam(TLObject):
    CONSTRUCTOR_ID = 0x58dbcab8
    SUBCLASS_OF_ID = 0x8401bd27

    def to_dict(self):
        return {
            '_': 'InputReportReasonSpam'
        }

    def __bytes__(self):
        return b''.join((
            b'\xb8\xca\xdbX',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class InputReportReasonViolence(TLObject):
    CONSTRUCTOR_ID = 0x1e22c78d
    SUBCLASS_OF_ID = 0x8401bd27

    def to_dict(self):
        return {
            '_': 'InputReportReasonViolence'
        }

    def __bytes__(self):
        return b''.join((
            b'\x8d\xc7"\x1e',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class InputSecureFile(TLObject):
    CONSTRUCTOR_ID = 0x5367e5be
    SUBCLASS_OF_ID = 0xdac8adfc

    def __init__(self, id, access_hash):
        """
        :param int id:
        :param int access_hash:

        Constructor for InputSecureFile: Instance of either InputSecureFileUploaded, InputSecureFile.
        """
        self.id = id  # type: int
        self.access_hash = access_hash  # type: int

    def to_dict(self):
        return {
            '_': 'InputSecureFile',
            'id': self.id,
            'access_hash': self.access_hash
        }

    def __bytes__(self):
        return b''.join((
            b'\xbe\xe5gS',
            struct.pack('<q', self.id),
            struct.pack('<q', self.access_hash),
        ))

    @classmethod
    def from_reader(cls, reader):
        _id = reader.read_long()
        _access_hash = reader.read_long()
        return cls(id=_id, access_hash=_access_hash)


class InputSecureFileLocation(TLObject):
    CONSTRUCTOR_ID = 0xcbc7ee28
    SUBCLASS_OF_ID = 0x1523d462

    def __init__(self, id, access_hash):
        """
        :param int id:
        :param int access_hash:

        Constructor for InputFileLocation: Instance of either InputFileLocation, InputEncryptedFileLocation, InputDocumentFileLocation, InputSecureFileLocation, InputTakeoutFileLocation.
        """
        self.id = id  # type: int
        self.access_hash = access_hash  # type: int

    def to_dict(self):
        return {
            '_': 'InputSecureFileLocation',
            'id': self.id,
            'access_hash': self.access_hash
        }

    def __bytes__(self):
        return b''.join((
            b'(\xee\xc7\xcb',
            struct.pack('<q', self.id),
            struct.pack('<q', self.access_hash),
        ))

    @classmethod
    def from_reader(cls, reader):
        _id = reader.read_long()
        _access_hash = reader.read_long()
        return cls(id=_id, access_hash=_access_hash)


class InputSecureFileUploaded(TLObject):
    CONSTRUCTOR_ID = 0x3334b0f0
    SUBCLASS_OF_ID = 0xdac8adfc

    def __init__(self, id, parts, md5_checksum, file_hash, secret):
        """
        :param int id:
        :param int parts:
        :param str md5_checksum:
        :param bytes file_hash:
        :param bytes secret:

        Constructor for InputSecureFile: Instance of either InputSecureFileUploaded, InputSecureFile.
        """
        self.id = id  # type: int
        self.parts = parts  # type: int
        self.md5_checksum = md5_checksum  # type: str
        self.file_hash = file_hash  # type: bytes
        self.secret = secret  # type: bytes

    def to_dict(self):
        return {
            '_': 'InputSecureFileUploaded',
            'id': self.id,
            'parts': self.parts,
            'md5_checksum': self.md5_checksum,
            'file_hash': self.file_hash,
            'secret': self.secret
        }

    def __bytes__(self):
        return b''.join((
            b'\xf0\xb043',
            struct.pack('<q', self.id),
            struct.pack('<i', self.parts),
            self.serialize_bytes(self.md5_checksum),
            self.serialize_bytes(self.file_hash),
            self.serialize_bytes(self.secret),
        ))

    @classmethod
    def from_reader(cls, reader):
        _id = reader.read_long()
        _parts = reader.read_int()
        _md5_checksum = reader.tgread_string()
        _file_hash = reader.tgread_bytes()
        _secret = reader.tgread_bytes()
        return cls(id=_id, parts=_parts, md5_checksum=_md5_checksum, file_hash=_file_hash, secret=_secret)


class InputSecureValue(TLObject):
    CONSTRUCTOR_ID = 0x67872e8
    SUBCLASS_OF_ID = 0xb49da1fc

    def __init__(self, type, data=None, front_side=None, reverse_side=None, selfie=None, files=None, plain_data=None):
        """
        :param TypeSecureValueType type:
        :param Optional[TypeSecureData] data:
        :param Optional[TypeInputSecureFile] front_side:
        :param Optional[TypeInputSecureFile] reverse_side:
        :param Optional[TypeInputSecureFile] selfie:
        :param Optional[List[TypeInputSecureFile]] files:
        :param Optional[TypeSecurePlainData] plain_data:

        Constructor for InputSecureValue: Instance of InputSecureValue.
        """
        self.type = type  # type: TypeSecureValueType
        self.data = data  # type: Optional[TypeSecureData]
        self.front_side = front_side  # type: Optional[TypeInputSecureFile]
        self.reverse_side = reverse_side  # type: Optional[TypeInputSecureFile]
        self.selfie = selfie  # type: Optional[TypeInputSecureFile]
        self.files = files  # type: Optional[List[TypeInputSecureFile]]
        self.plain_data = plain_data  # type: Optional[TypeSecurePlainData]

    def to_dict(self):
        return {
            '_': 'InputSecureValue',
            'type': None if self.type is None else self.type.to_dict(),
            'data': None if self.data is None else self.data.to_dict(),
            'front_side': None if self.front_side is None else self.front_side.to_dict(),
            'reverse_side': None if self.reverse_side is None else self.reverse_side.to_dict(),
            'selfie': None if self.selfie is None else self.selfie.to_dict(),
            'files': [] if self.files is None else [None if x is None else x.to_dict() for x in self.files],
            'plain_data': None if self.plain_data is None else self.plain_data.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\xe8rx\x06',
            struct.pack('<I', (0 if self.data is None or self.data is False else 1) | (0 if self.front_side is None or self.front_side is False else 2) | (0 if self.reverse_side is None or self.reverse_side is False else 4) | (0 if self.selfie is None or self.selfie is False else 8) | (0 if self.files is None or self.files is False else 16) | (0 if self.plain_data is None or self.plain_data is False else 32)),
            bytes(self.type),
            b'' if self.data is None or self.data is False else (bytes(self.data)),
            b'' if self.front_side is None or self.front_side is False else (bytes(self.front_side)),
            b'' if self.reverse_side is None or self.reverse_side is False else (bytes(self.reverse_side)),
            b'' if self.selfie is None or self.selfie is False else (bytes(self.selfie)),
            b'' if self.files is None or self.files is False else b''.join((b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.files)),b''.join(bytes(x) for x in self.files))),
            b'' if self.plain_data is None or self.plain_data is False else (bytes(self.plain_data)),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _type = reader.tgread_object()
        if flags & 1:
            _data = reader.tgread_object()
        else:
            _data = None
        if flags & 2:
            _front_side = reader.tgread_object()
        else:
            _front_side = None
        if flags & 4:
            _reverse_side = reader.tgread_object()
        else:
            _reverse_side = None
        if flags & 8:
            _selfie = reader.tgread_object()
        else:
            _selfie = None
        if flags & 16:
            reader.read_int()
            _files = []
            for _ in range(reader.read_int()):
                _x = reader.tgread_object()
                _files.append(_x)

        else:
            _files = None
        if flags & 32:
            _plain_data = reader.tgread_object()
        else:
            _plain_data = None
        return cls(type=_type, data=_data, front_side=_front_side, reverse_side=_reverse_side, selfie=_selfie, files=_files, plain_data=_plain_data)


class InputSingleMedia(TLObject):
    CONSTRUCTOR_ID = 0x1cc6e91f
    SUBCLASS_OF_ID = 0x21ca8ed8

    def __init__(self, media, message, random_id=None, entities=None):
        """
        :param TypeInputMedia media:
        :param str message:
        :param int random_id:
        :param Optional[List[TypeMessageEntity]] entities:

        Constructor for InputSingleMedia: Instance of InputSingleMedia.
        """
        self.media = media  # type: TypeInputMedia
        self.message = message  # type: str
        self.random_id = random_id if random_id is not None else int.from_bytes(os.urandom(8), 'big', signed=True)
        self.entities = entities  # type: Optional[List[TypeMessageEntity]]

    def to_dict(self):
        return {
            '_': 'InputSingleMedia',
            'media': None if self.media is None else self.media.to_dict(),
            'message': self.message,
            'random_id': self.random_id,
            'entities': [] if self.entities is None else [None if x is None else x.to_dict() for x in self.entities]
        }

    def __bytes__(self):
        return b''.join((
            b'\x1f\xe9\xc6\x1c',
            struct.pack('<I', (0 if self.entities is None or self.entities is False else 1)),
            bytes(self.media),
            struct.pack('<q', self.random_id),
            self.serialize_bytes(self.message),
            b'' if self.entities is None or self.entities is False else b''.join((b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.entities)),b''.join(bytes(x) for x in self.entities))),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _media = reader.tgread_object()
        _random_id = reader.read_long()
        _message = reader.tgread_string()
        if flags & 1:
            reader.read_int()
            _entities = []
            for _ in range(reader.read_int()):
                _x = reader.tgread_object()
                _entities.append(_x)

        else:
            _entities = None
        return cls(media=_media, message=_message, random_id=_random_id, entities=_entities)


class InputStickerSetEmpty(TLObject):
    CONSTRUCTOR_ID = 0xffb62b95
    SUBCLASS_OF_ID = 0x3da389aa

    def to_dict(self):
        return {
            '_': 'InputStickerSetEmpty'
        }

    def __bytes__(self):
        return b''.join((
            b'\x95+\xb6\xff',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class InputStickerSetID(TLObject):
    CONSTRUCTOR_ID = 0x9de7a269
    SUBCLASS_OF_ID = 0x3da389aa

    def __init__(self, id, access_hash):
        """
        :param int id:
        :param int access_hash:

        Constructor for InputStickerSet: Instance of either InputStickerSetEmpty, InputStickerSetID, InputStickerSetShortName.
        """
        self.id = id  # type: int
        self.access_hash = access_hash  # type: int

    def to_dict(self):
        return {
            '_': 'InputStickerSetID',
            'id': self.id,
            'access_hash': self.access_hash
        }

    def __bytes__(self):
        return b''.join((
            b'i\xa2\xe7\x9d',
            struct.pack('<q', self.id),
            struct.pack('<q', self.access_hash),
        ))

    @classmethod
    def from_reader(cls, reader):
        _id = reader.read_long()
        _access_hash = reader.read_long()
        return cls(id=_id, access_hash=_access_hash)


class InputStickerSetItem(TLObject):
    CONSTRUCTOR_ID = 0xffa0a496
    SUBCLASS_OF_ID = 0xae59f075

    def __init__(self, document, emoji, mask_coords=None):
        """
        :param TypeInputDocument document:
        :param str emoji:
        :param Optional[TypeMaskCoords] mask_coords:

        Constructor for InputStickerSetItem: Instance of InputStickerSetItem.
        """
        self.document = document  # type: TypeInputDocument
        self.emoji = emoji  # type: str
        self.mask_coords = mask_coords  # type: Optional[TypeMaskCoords]

    def to_dict(self):
        return {
            '_': 'InputStickerSetItem',
            'document': None if self.document is None else self.document.to_dict(),
            'emoji': self.emoji,
            'mask_coords': None if self.mask_coords is None else self.mask_coords.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\x96\xa4\xa0\xff',
            struct.pack('<I', (0 if self.mask_coords is None or self.mask_coords is False else 1)),
            bytes(self.document),
            self.serialize_bytes(self.emoji),
            b'' if self.mask_coords is None or self.mask_coords is False else (bytes(self.mask_coords)),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _document = reader.tgread_object()
        _emoji = reader.tgread_string()
        if flags & 1:
            _mask_coords = reader.tgread_object()
        else:
            _mask_coords = None
        return cls(document=_document, emoji=_emoji, mask_coords=_mask_coords)


class InputStickerSetShortName(TLObject):
    CONSTRUCTOR_ID = 0x861cc8a0
    SUBCLASS_OF_ID = 0x3da389aa

    def __init__(self, short_name):
        """
        :param str short_name:

        Constructor for InputStickerSet: Instance of either InputStickerSetEmpty, InputStickerSetID, InputStickerSetShortName.
        """
        self.short_name = short_name  # type: str

    def to_dict(self):
        return {
            '_': 'InputStickerSetShortName',
            'short_name': self.short_name
        }

    def __bytes__(self):
        return b''.join((
            b'\xa0\xc8\x1c\x86',
            self.serialize_bytes(self.short_name),
        ))

    @classmethod
    def from_reader(cls, reader):
        _short_name = reader.tgread_string()
        return cls(short_name=_short_name)


class InputStickeredMediaDocument(TLObject):
    CONSTRUCTOR_ID = 0x438865b
    SUBCLASS_OF_ID = 0x5146d99e

    def __init__(self, id):
        """
        :param TypeInputDocument id:

        Constructor for InputStickeredMedia: Instance of either InputStickeredMediaPhoto, InputStickeredMediaDocument.
        """
        self.id = id  # type: TypeInputDocument

    def to_dict(self):
        return {
            '_': 'InputStickeredMediaDocument',
            'id': None if self.id is None else self.id.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'[\x868\x04',
            bytes(self.id),
        ))

    @classmethod
    def from_reader(cls, reader):
        _id = reader.tgread_object()
        return cls(id=_id)


class InputStickeredMediaPhoto(TLObject):
    CONSTRUCTOR_ID = 0x4a992157
    SUBCLASS_OF_ID = 0x5146d99e

    def __init__(self, id):
        """
        :param TypeInputPhoto id:

        Constructor for InputStickeredMedia: Instance of either InputStickeredMediaPhoto, InputStickeredMediaDocument.
        """
        self.id = id  # type: TypeInputPhoto

    def to_dict(self):
        return {
            '_': 'InputStickeredMediaPhoto',
            'id': None if self.id is None else self.id.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'W!\x99J',
            bytes(self.id),
        ))

    @classmethod
    def from_reader(cls, reader):
        _id = reader.tgread_object()
        return cls(id=_id)


class InputTakeoutFileLocation(TLObject):
    CONSTRUCTOR_ID = 0x29be5899
    SUBCLASS_OF_ID = 0x1523d462

    def to_dict(self):
        return {
            '_': 'InputTakeoutFileLocation'
        }

    def __bytes__(self):
        return b''.join((
            b'\x99X\xbe)',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class InputUser(TLObject):
    CONSTRUCTOR_ID = 0xd8292816
    SUBCLASS_OF_ID = 0xe669bf46

    def __init__(self, user_id, access_hash):
        """
        :param int user_id:
        :param int access_hash:

        Constructor for InputUser: Instance of either InputUserEmpty, InputUserSelf, InputUser.
        """
        self.user_id = user_id  # type: int
        self.access_hash = access_hash  # type: int

    def to_dict(self):
        return {
            '_': 'InputUser',
            'user_id': self.user_id,
            'access_hash': self.access_hash
        }

    def __bytes__(self):
        return b''.join((
            b'\x16()\xd8',
            struct.pack('<i', self.user_id),
            struct.pack('<q', self.access_hash),
        ))

    @classmethod
    def from_reader(cls, reader):
        _user_id = reader.read_int()
        _access_hash = reader.read_long()
        return cls(user_id=_user_id, access_hash=_access_hash)


class InputUserEmpty(TLObject):
    CONSTRUCTOR_ID = 0xb98886cf
    SUBCLASS_OF_ID = 0xe669bf46

    def to_dict(self):
        return {
            '_': 'InputUserEmpty'
        }

    def __bytes__(self):
        return b''.join((
            b'\xcf\x86\x88\xb9',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class InputUserSelf(TLObject):
    CONSTRUCTOR_ID = 0xf7c1b13f
    SUBCLASS_OF_ID = 0xe669bf46

    def to_dict(self):
        return {
            '_': 'InputUserSelf'
        }

    def __bytes__(self):
        return b''.join((
            b'?\xb1\xc1\xf7',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class InputWebDocument(TLObject):
    CONSTRUCTOR_ID = 0x9bed434d
    SUBCLASS_OF_ID = 0x8ae8b146

    def __init__(self, url, size, mime_type, attributes):
        """
        :param str url:
        :param int size:
        :param str mime_type:
        :param List[TypeDocumentAttribute] attributes:

        Constructor for InputWebDocument: Instance of InputWebDocument.
        """
        self.url = url  # type: str
        self.size = size  # type: int
        self.mime_type = mime_type  # type: str
        self.attributes = attributes  # type: List[TypeDocumentAttribute]

    def to_dict(self):
        return {
            '_': 'InputWebDocument',
            'url': self.url,
            'size': self.size,
            'mime_type': self.mime_type,
            'attributes': [] if self.attributes is None else [None if x is None else x.to_dict() for x in self.attributes]
        }

    def __bytes__(self):
        return b''.join((
            b'MC\xed\x9b',
            self.serialize_bytes(self.url),
            struct.pack('<i', self.size),
            self.serialize_bytes(self.mime_type),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.attributes)),b''.join(bytes(x) for x in self.attributes),
        ))

    @classmethod
    def from_reader(cls, reader):
        _url = reader.tgread_string()
        _size = reader.read_int()
        _mime_type = reader.tgread_string()
        reader.read_int()
        _attributes = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _attributes.append(_x)

        return cls(url=_url, size=_size, mime_type=_mime_type, attributes=_attributes)


class InputWebFileGeoPointLocation(TLObject):
    CONSTRUCTOR_ID = 0x9f2221c9
    SUBCLASS_OF_ID = 0xf72ed8d9

    def __init__(self, geo_point, access_hash, w, h, zoom, scale):
        """
        :param TypeInputGeoPoint geo_point:
        :param int access_hash:
        :param int w:
        :param int h:
        :param int zoom:
        :param int scale:

        Constructor for InputWebFileLocation: Instance of either InputWebFileLocation, InputWebFileGeoPointLocation.
        """
        self.geo_point = geo_point  # type: TypeInputGeoPoint
        self.access_hash = access_hash  # type: int
        self.w = w  # type: int
        self.h = h  # type: int
        self.zoom = zoom  # type: int
        self.scale = scale  # type: int

    def to_dict(self):
        return {
            '_': 'InputWebFileGeoPointLocation',
            'geo_point': None if self.geo_point is None else self.geo_point.to_dict(),
            'access_hash': self.access_hash,
            'w': self.w,
            'h': self.h,
            'zoom': self.zoom,
            'scale': self.scale
        }

    def __bytes__(self):
        return b''.join((
            b'\xc9!"\x9f',
            bytes(self.geo_point),
            struct.pack('<q', self.access_hash),
            struct.pack('<i', self.w),
            struct.pack('<i', self.h),
            struct.pack('<i', self.zoom),
            struct.pack('<i', self.scale),
        ))

    @classmethod
    def from_reader(cls, reader):
        _geo_point = reader.tgread_object()
        _access_hash = reader.read_long()
        _w = reader.read_int()
        _h = reader.read_int()
        _zoom = reader.read_int()
        _scale = reader.read_int()
        return cls(geo_point=_geo_point, access_hash=_access_hash, w=_w, h=_h, zoom=_zoom, scale=_scale)


class InputWebFileLocation(TLObject):
    CONSTRUCTOR_ID = 0xc239d686
    SUBCLASS_OF_ID = 0xf72ed8d9

    def __init__(self, url, access_hash):
        """
        :param str url:
        :param int access_hash:

        Constructor for InputWebFileLocation: Instance of either InputWebFileLocation, InputWebFileGeoPointLocation.
        """
        self.url = url  # type: str
        self.access_hash = access_hash  # type: int

    def to_dict(self):
        return {
            '_': 'InputWebFileLocation',
            'url': self.url,
            'access_hash': self.access_hash
        }

    def __bytes__(self):
        return b''.join((
            b'\x86\xd69\xc2',
            self.serialize_bytes(self.url),
            struct.pack('<q', self.access_hash),
        ))

    @classmethod
    def from_reader(cls, reader):
        _url = reader.tgread_string()
        _access_hash = reader.read_long()
        return cls(url=_url, access_hash=_access_hash)


class Invoice(TLObject):
    CONSTRUCTOR_ID = 0xc30aa358
    SUBCLASS_OF_ID = 0x5fd82ed8

    def __init__(self, currency, prices, test=None, name_requested=None, phone_requested=None, email_requested=None, shipping_address_requested=None, flexible=None, phone_to_provider=None, email_to_provider=None):
        """
        :param str currency:
        :param List[TypeLabeledPrice] prices:
        :param Optional[bool] test:
        :param Optional[bool] name_requested:
        :param Optional[bool] phone_requested:
        :param Optional[bool] email_requested:
        :param Optional[bool] shipping_address_requested:
        :param Optional[bool] flexible:
        :param Optional[bool] phone_to_provider:
        :param Optional[bool] email_to_provider:

        Constructor for Invoice: Instance of Invoice.
        """
        self.currency = currency  # type: str
        self.prices = prices  # type: List[TypeLabeledPrice]
        self.test = test  # type: Optional[bool]
        self.name_requested = name_requested  # type: Optional[bool]
        self.phone_requested = phone_requested  # type: Optional[bool]
        self.email_requested = email_requested  # type: Optional[bool]
        self.shipping_address_requested = shipping_address_requested  # type: Optional[bool]
        self.flexible = flexible  # type: Optional[bool]
        self.phone_to_provider = phone_to_provider  # type: Optional[bool]
        self.email_to_provider = email_to_provider  # type: Optional[bool]

    def to_dict(self):
        return {
            '_': 'Invoice',
            'currency': self.currency,
            'prices': [] if self.prices is None else [None if x is None else x.to_dict() for x in self.prices],
            'test': self.test,
            'name_requested': self.name_requested,
            'phone_requested': self.phone_requested,
            'email_requested': self.email_requested,
            'shipping_address_requested': self.shipping_address_requested,
            'flexible': self.flexible,
            'phone_to_provider': self.phone_to_provider,
            'email_to_provider': self.email_to_provider
        }

    def __bytes__(self):
        return b''.join((
            b'X\xa3\n\xc3',
            struct.pack('<I', (0 if self.test is None or self.test is False else 1) | (0 if self.name_requested is None or self.name_requested is False else 2) | (0 if self.phone_requested is None or self.phone_requested is False else 4) | (0 if self.email_requested is None or self.email_requested is False else 8) | (0 if self.shipping_address_requested is None or self.shipping_address_requested is False else 16) | (0 if self.flexible is None or self.flexible is False else 32) | (0 if self.phone_to_provider is None or self.phone_to_provider is False else 64) | (0 if self.email_to_provider is None or self.email_to_provider is False else 128)),
            self.serialize_bytes(self.currency),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.prices)),b''.join(bytes(x) for x in self.prices),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _test = bool(flags & 1)
        _name_requested = bool(flags & 2)
        _phone_requested = bool(flags & 4)
        _email_requested = bool(flags & 8)
        _shipping_address_requested = bool(flags & 16)
        _flexible = bool(flags & 32)
        _phone_to_provider = bool(flags & 64)
        _email_to_provider = bool(flags & 128)
        _currency = reader.tgread_string()
        reader.read_int()
        _prices = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _prices.append(_x)

        return cls(currency=_currency, prices=_prices, test=_test, name_requested=_name_requested, phone_requested=_phone_requested, email_requested=_email_requested, shipping_address_requested=_shipping_address_requested, flexible=_flexible, phone_to_provider=_phone_to_provider, email_to_provider=_email_to_provider)


class IpPort(TLObject):
    CONSTRUCTOR_ID = 0xd433ad73
    SUBCLASS_OF_ID = 0xa2a03726

    def __init__(self, ipv4, port):
        """
        :param int ipv4:
        :param int port:

        Constructor for IpPort: Instance of either IpPort, IpPortSecret.
        """
        self.ipv4 = ipv4  # type: int
        self.port = port  # type: int

    def to_dict(self):
        return {
            '_': 'IpPort',
            'ipv4': self.ipv4,
            'port': self.port
        }

    def __bytes__(self):
        return b''.join((
            b's\xad3\xd4',
            struct.pack('<i', self.ipv4),
            struct.pack('<i', self.port),
        ))

    @classmethod
    def from_reader(cls, reader):
        _ipv4 = reader.read_int()
        _port = reader.read_int()
        return cls(ipv4=_ipv4, port=_port)


class IpPortSecret(TLObject):
    CONSTRUCTOR_ID = 0x37982646
    SUBCLASS_OF_ID = 0xa2a03726

    def __init__(self, ipv4, port, secret):
        """
        :param int ipv4:
        :param int port:
        :param bytes secret:

        Constructor for IpPort: Instance of either IpPort, IpPortSecret.
        """
        self.ipv4 = ipv4  # type: int
        self.port = port  # type: int
        self.secret = secret  # type: bytes

    def to_dict(self):
        return {
            '_': 'IpPortSecret',
            'ipv4': self.ipv4,
            'port': self.port,
            'secret': self.secret
        }

    def __bytes__(self):
        return b''.join((
            b'F&\x987',
            struct.pack('<i', self.ipv4),
            struct.pack('<i', self.port),
            self.serialize_bytes(self.secret),
        ))

    @classmethod
    def from_reader(cls, reader):
        _ipv4 = reader.read_int()
        _port = reader.read_int()
        _secret = reader.tgread_bytes()
        return cls(ipv4=_ipv4, port=_port, secret=_secret)


class KeyboardButton(TLObject):
    CONSTRUCTOR_ID = 0xa2fa4880
    SUBCLASS_OF_ID = 0xbad74a3

    def __init__(self, text):
        """
        :param str text:

        Constructor for KeyboardButton: Instance of either KeyboardButton, KeyboardButtonUrl, KeyboardButtonCallback, KeyboardButtonRequestPhone, KeyboardButtonRequestGeoLocation, KeyboardButtonSwitchInline, KeyboardButtonGame, KeyboardButtonBuy.
        """
        self.text = text  # type: str

    def to_dict(self):
        return {
            '_': 'KeyboardButton',
            'text': self.text
        }

    def __bytes__(self):
        return b''.join((
            b'\x80H\xfa\xa2',
            self.serialize_bytes(self.text),
        ))

    @classmethod
    def from_reader(cls, reader):
        _text = reader.tgread_string()
        return cls(text=_text)


class KeyboardButtonBuy(TLObject):
    CONSTRUCTOR_ID = 0xafd93fbb
    SUBCLASS_OF_ID = 0xbad74a3

    def __init__(self, text):
        """
        :param str text:

        Constructor for KeyboardButton: Instance of either KeyboardButton, KeyboardButtonUrl, KeyboardButtonCallback, KeyboardButtonRequestPhone, KeyboardButtonRequestGeoLocation, KeyboardButtonSwitchInline, KeyboardButtonGame, KeyboardButtonBuy.
        """
        self.text = text  # type: str

    def to_dict(self):
        return {
            '_': 'KeyboardButtonBuy',
            'text': self.text
        }

    def __bytes__(self):
        return b''.join((
            b'\xbb?\xd9\xaf',
            self.serialize_bytes(self.text),
        ))

    @classmethod
    def from_reader(cls, reader):
        _text = reader.tgread_string()
        return cls(text=_text)


class KeyboardButtonCallback(TLObject):
    CONSTRUCTOR_ID = 0x683a5e46
    SUBCLASS_OF_ID = 0xbad74a3

    def __init__(self, text, data):
        """
        :param str text:
        :param bytes data:

        Constructor for KeyboardButton: Instance of either KeyboardButton, KeyboardButtonUrl, KeyboardButtonCallback, KeyboardButtonRequestPhone, KeyboardButtonRequestGeoLocation, KeyboardButtonSwitchInline, KeyboardButtonGame, KeyboardButtonBuy.
        """
        self.text = text  # type: str
        self.data = data  # type: bytes

    def to_dict(self):
        return {
            '_': 'KeyboardButtonCallback',
            'text': self.text,
            'data': self.data
        }

    def __bytes__(self):
        return b''.join((
            b'F^:h',
            self.serialize_bytes(self.text),
            self.serialize_bytes(self.data),
        ))

    @classmethod
    def from_reader(cls, reader):
        _text = reader.tgread_string()
        _data = reader.tgread_bytes()
        return cls(text=_text, data=_data)


class KeyboardButtonGame(TLObject):
    CONSTRUCTOR_ID = 0x50f41ccf
    SUBCLASS_OF_ID = 0xbad74a3

    def __init__(self, text):
        """
        :param str text:

        Constructor for KeyboardButton: Instance of either KeyboardButton, KeyboardButtonUrl, KeyboardButtonCallback, KeyboardButtonRequestPhone, KeyboardButtonRequestGeoLocation, KeyboardButtonSwitchInline, KeyboardButtonGame, KeyboardButtonBuy.
        """
        self.text = text  # type: str

    def to_dict(self):
        return {
            '_': 'KeyboardButtonGame',
            'text': self.text
        }

    def __bytes__(self):
        return b''.join((
            b'\xcf\x1c\xf4P',
            self.serialize_bytes(self.text),
        ))

    @classmethod
    def from_reader(cls, reader):
        _text = reader.tgread_string()
        return cls(text=_text)


class KeyboardButtonRequestGeoLocation(TLObject):
    CONSTRUCTOR_ID = 0xfc796b3f
    SUBCLASS_OF_ID = 0xbad74a3

    def __init__(self, text):
        """
        :param str text:

        Constructor for KeyboardButton: Instance of either KeyboardButton, KeyboardButtonUrl, KeyboardButtonCallback, KeyboardButtonRequestPhone, KeyboardButtonRequestGeoLocation, KeyboardButtonSwitchInline, KeyboardButtonGame, KeyboardButtonBuy.
        """
        self.text = text  # type: str

    def to_dict(self):
        return {
            '_': 'KeyboardButtonRequestGeoLocation',
            'text': self.text
        }

    def __bytes__(self):
        return b''.join((
            b'?ky\xfc',
            self.serialize_bytes(self.text),
        ))

    @classmethod
    def from_reader(cls, reader):
        _text = reader.tgread_string()
        return cls(text=_text)


class KeyboardButtonRequestPhone(TLObject):
    CONSTRUCTOR_ID = 0xb16a6c29
    SUBCLASS_OF_ID = 0xbad74a3

    def __init__(self, text):
        """
        :param str text:

        Constructor for KeyboardButton: Instance of either KeyboardButton, KeyboardButtonUrl, KeyboardButtonCallback, KeyboardButtonRequestPhone, KeyboardButtonRequestGeoLocation, KeyboardButtonSwitchInline, KeyboardButtonGame, KeyboardButtonBuy.
        """
        self.text = text  # type: str

    def to_dict(self):
        return {
            '_': 'KeyboardButtonRequestPhone',
            'text': self.text
        }

    def __bytes__(self):
        return b''.join((
            b')lj\xb1',
            self.serialize_bytes(self.text),
        ))

    @classmethod
    def from_reader(cls, reader):
        _text = reader.tgread_string()
        return cls(text=_text)


class KeyboardButtonRow(TLObject):
    CONSTRUCTOR_ID = 0x77608b83
    SUBCLASS_OF_ID = 0x847730ae

    def __init__(self, buttons):
        """
        :param List[TypeKeyboardButton] buttons:

        Constructor for KeyboardButtonRow: Instance of KeyboardButtonRow.
        """
        self.buttons = buttons  # type: List[TypeKeyboardButton]

    def to_dict(self):
        return {
            '_': 'KeyboardButtonRow',
            'buttons': [] if self.buttons is None else [None if x is None else x.to_dict() for x in self.buttons]
        }

    def __bytes__(self):
        return b''.join((
            b'\x83\x8b`w',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.buttons)),b''.join(bytes(x) for x in self.buttons),
        ))

    @classmethod
    def from_reader(cls, reader):
        reader.read_int()
        _buttons = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _buttons.append(_x)

        return cls(buttons=_buttons)


class KeyboardButtonSwitchInline(TLObject):
    CONSTRUCTOR_ID = 0x568a748
    SUBCLASS_OF_ID = 0xbad74a3

    def __init__(self, text, query, same_peer=None):
        """
        :param str text:
        :param str query:
        :param Optional[bool] same_peer:

        Constructor for KeyboardButton: Instance of either KeyboardButton, KeyboardButtonUrl, KeyboardButtonCallback, KeyboardButtonRequestPhone, KeyboardButtonRequestGeoLocation, KeyboardButtonSwitchInline, KeyboardButtonGame, KeyboardButtonBuy.
        """
        self.text = text  # type: str
        self.query = query  # type: str
        self.same_peer = same_peer  # type: Optional[bool]

    def to_dict(self):
        return {
            '_': 'KeyboardButtonSwitchInline',
            'text': self.text,
            'query': self.query,
            'same_peer': self.same_peer
        }

    def __bytes__(self):
        return b''.join((
            b'H\xa7h\x05',
            struct.pack('<I', (0 if self.same_peer is None or self.same_peer is False else 1)),
            self.serialize_bytes(self.text),
            self.serialize_bytes(self.query),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _same_peer = bool(flags & 1)
        _text = reader.tgread_string()
        _query = reader.tgread_string()
        return cls(text=_text, query=_query, same_peer=_same_peer)


class KeyboardButtonUrl(TLObject):
    CONSTRUCTOR_ID = 0x258aff05
    SUBCLASS_OF_ID = 0xbad74a3

    def __init__(self, text, url):
        """
        :param str text:
        :param str url:

        Constructor for KeyboardButton: Instance of either KeyboardButton, KeyboardButtonUrl, KeyboardButtonCallback, KeyboardButtonRequestPhone, KeyboardButtonRequestGeoLocation, KeyboardButtonSwitchInline, KeyboardButtonGame, KeyboardButtonBuy.
        """
        self.text = text  # type: str
        self.url = url  # type: str

    def to_dict(self):
        return {
            '_': 'KeyboardButtonUrl',
            'text': self.text,
            'url': self.url
        }

    def __bytes__(self):
        return b''.join((
            b'\x05\xff\x8a%',
            self.serialize_bytes(self.text),
            self.serialize_bytes(self.url),
        ))

    @classmethod
    def from_reader(cls, reader):
        _text = reader.tgread_string()
        _url = reader.tgread_string()
        return cls(text=_text, url=_url)


class LabeledPrice(TLObject):
    CONSTRUCTOR_ID = 0xcb296bf8
    SUBCLASS_OF_ID = 0x1c84047a

    def __init__(self, label, amount):
        """
        :param str label:
        :param int amount:

        Constructor for LabeledPrice: Instance of LabeledPrice.
        """
        self.label = label  # type: str
        self.amount = amount  # type: int

    def to_dict(self):
        return {
            '_': 'LabeledPrice',
            'label': self.label,
            'amount': self.amount
        }

    def __bytes__(self):
        return b''.join((
            b'\xf8k)\xcb',
            self.serialize_bytes(self.label),
            struct.pack('<q', self.amount),
        ))

    @classmethod
    def from_reader(cls, reader):
        _label = reader.tgread_string()
        _amount = reader.read_long()
        return cls(label=_label, amount=_amount)


class LangPackDifference(TLObject):
    CONSTRUCTOR_ID = 0xf385c1f6
    SUBCLASS_OF_ID = 0x52662d55

    def __init__(self, lang_code, from_version, version, strings):
        """
        :param str lang_code:
        :param int from_version:
        :param int version:
        :param List[TypeLangPackString] strings:

        Constructor for LangPackDifference: Instance of LangPackDifference.
        """
        self.lang_code = lang_code  # type: str
        self.from_version = from_version  # type: int
        self.version = version  # type: int
        self.strings = strings  # type: List[TypeLangPackString]

    def to_dict(self):
        return {
            '_': 'LangPackDifference',
            'lang_code': self.lang_code,
            'from_version': self.from_version,
            'version': self.version,
            'strings': [] if self.strings is None else [None if x is None else x.to_dict() for x in self.strings]
        }

    def __bytes__(self):
        return b''.join((
            b'\xf6\xc1\x85\xf3',
            self.serialize_bytes(self.lang_code),
            struct.pack('<i', self.from_version),
            struct.pack('<i', self.version),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.strings)),b''.join(bytes(x) for x in self.strings),
        ))

    @classmethod
    def from_reader(cls, reader):
        _lang_code = reader.tgread_string()
        _from_version = reader.read_int()
        _version = reader.read_int()
        reader.read_int()
        _strings = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _strings.append(_x)

        return cls(lang_code=_lang_code, from_version=_from_version, version=_version, strings=_strings)


class LangPackLanguage(TLObject):
    CONSTRUCTOR_ID = 0x117698f1
    SUBCLASS_OF_ID = 0xabac89b7

    def __init__(self, name, native_name, lang_code):
        """
        :param str name:
        :param str native_name:
        :param str lang_code:

        Constructor for LangPackLanguage: Instance of LangPackLanguage.
        """
        self.name = name  # type: str
        self.native_name = native_name  # type: str
        self.lang_code = lang_code  # type: str

    def to_dict(self):
        return {
            '_': 'LangPackLanguage',
            'name': self.name,
            'native_name': self.native_name,
            'lang_code': self.lang_code
        }

    def __bytes__(self):
        return b''.join((
            b'\xf1\x98v\x11',
            self.serialize_bytes(self.name),
            self.serialize_bytes(self.native_name),
            self.serialize_bytes(self.lang_code),
        ))

    @classmethod
    def from_reader(cls, reader):
        _name = reader.tgread_string()
        _native_name = reader.tgread_string()
        _lang_code = reader.tgread_string()
        return cls(name=_name, native_name=_native_name, lang_code=_lang_code)


class LangPackString(TLObject):
    CONSTRUCTOR_ID = 0xcad181f6
    SUBCLASS_OF_ID = 0xdc179ab9

    def __init__(self, key, value):
        """
        :param str key:
        :param str value:

        Constructor for LangPackString: Instance of either LangPackString, LangPackStringPluralized, LangPackStringDeleted.
        """
        self.key = key  # type: str
        self.value = value  # type: str

    def to_dict(self):
        return {
            '_': 'LangPackString',
            'key': self.key,
            'value': self.value
        }

    def __bytes__(self):
        return b''.join((
            b'\xf6\x81\xd1\xca',
            self.serialize_bytes(self.key),
            self.serialize_bytes(self.value),
        ))

    @classmethod
    def from_reader(cls, reader):
        _key = reader.tgread_string()
        _value = reader.tgread_string()
        return cls(key=_key, value=_value)


class LangPackStringDeleted(TLObject):
    CONSTRUCTOR_ID = 0x2979eeb2
    SUBCLASS_OF_ID = 0xdc179ab9

    def __init__(self, key):
        """
        :param str key:

        Constructor for LangPackString: Instance of either LangPackString, LangPackStringPluralized, LangPackStringDeleted.
        """
        self.key = key  # type: str

    def to_dict(self):
        return {
            '_': 'LangPackStringDeleted',
            'key': self.key
        }

    def __bytes__(self):
        return b''.join((
            b'\xb2\xeey)',
            self.serialize_bytes(self.key),
        ))

    @classmethod
    def from_reader(cls, reader):
        _key = reader.tgread_string()
        return cls(key=_key)


class LangPackStringPluralized(TLObject):
    CONSTRUCTOR_ID = 0x6c47ac9f
    SUBCLASS_OF_ID = 0xdc179ab9

    def __init__(self, key, other_value, zero_value=None, one_value=None, two_value=None, few_value=None, many_value=None):
        """
        :param str key:
        :param str other_value:
        :param Optional[str] zero_value:
        :param Optional[str] one_value:
        :param Optional[str] two_value:
        :param Optional[str] few_value:
        :param Optional[str] many_value:

        Constructor for LangPackString: Instance of either LangPackString, LangPackStringPluralized, LangPackStringDeleted.
        """
        self.key = key  # type: str
        self.other_value = other_value  # type: str
        self.zero_value = zero_value  # type: Optional[str]
        self.one_value = one_value  # type: Optional[str]
        self.two_value = two_value  # type: Optional[str]
        self.few_value = few_value  # type: Optional[str]
        self.many_value = many_value  # type: Optional[str]

    def to_dict(self):
        return {
            '_': 'LangPackStringPluralized',
            'key': self.key,
            'other_value': self.other_value,
            'zero_value': self.zero_value,
            'one_value': self.one_value,
            'two_value': self.two_value,
            'few_value': self.few_value,
            'many_value': self.many_value
        }

    def __bytes__(self):
        return b''.join((
            b'\x9f\xacGl',
            struct.pack('<I', (0 if self.zero_value is None or self.zero_value is False else 1) | (0 if self.one_value is None or self.one_value is False else 2) | (0 if self.two_value is None or self.two_value is False else 4) | (0 if self.few_value is None or self.few_value is False else 8) | (0 if self.many_value is None or self.many_value is False else 16)),
            self.serialize_bytes(self.key),
            b'' if self.zero_value is None or self.zero_value is False else (self.serialize_bytes(self.zero_value)),
            b'' if self.one_value is None or self.one_value is False else (self.serialize_bytes(self.one_value)),
            b'' if self.two_value is None or self.two_value is False else (self.serialize_bytes(self.two_value)),
            b'' if self.few_value is None or self.few_value is False else (self.serialize_bytes(self.few_value)),
            b'' if self.many_value is None or self.many_value is False else (self.serialize_bytes(self.many_value)),
            self.serialize_bytes(self.other_value),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _key = reader.tgread_string()
        if flags & 1:
            _zero_value = reader.tgread_string()
        else:
            _zero_value = None
        if flags & 2:
            _one_value = reader.tgread_string()
        else:
            _one_value = None
        if flags & 4:
            _two_value = reader.tgread_string()
        else:
            _two_value = None
        if flags & 8:
            _few_value = reader.tgread_string()
        else:
            _few_value = None
        if flags & 16:
            _many_value = reader.tgread_string()
        else:
            _many_value = None
        _other_value = reader.tgread_string()
        return cls(key=_key, other_value=_other_value, zero_value=_zero_value, one_value=_one_value, two_value=_two_value, few_value=_few_value, many_value=_many_value)


class MaskCoords(TLObject):
    CONSTRUCTOR_ID = 0xaed6dbb2
    SUBCLASS_OF_ID = 0x6bbb2fd

    def __init__(self, n, x, y, zoom):
        """
        :param int n:
        :param Typedouble x:
        :param Typedouble y:
        :param Typedouble zoom:

        Constructor for MaskCoords: Instance of MaskCoords.
        """
        self.n = n  # type: int
        self.x = x  # type: Typedouble
        self.y = y  # type: Typedouble
        self.zoom = zoom  # type: Typedouble

    def to_dict(self):
        return {
            '_': 'MaskCoords',
            'n': self.n,
            'x': self.x,
            'y': self.y,
            'zoom': self.zoom
        }

    def __bytes__(self):
        return b''.join((
            b'\xb2\xdb\xd6\xae',
            struct.pack('<i', self.n),
            struct.pack('<d', self.x),
            struct.pack('<d', self.y),
            struct.pack('<d', self.zoom),
        ))

    @classmethod
    def from_reader(cls, reader):
        _n = reader.read_int()
        _x = reader.read_double()
        _y = reader.read_double()
        _zoom = reader.read_double()
        return cls(n=_n, x=_x, y=_y, zoom=_zoom)
Message = None  # Patched


class MessageActionBotAllowed(TLObject):
    CONSTRUCTOR_ID = 0xabe9affe
    SUBCLASS_OF_ID = 0x8680d126

    def __init__(self, domain):
        """
        :param str domain:

        Constructor for MessageAction: Instance of either MessageActionEmpty, MessageActionChatCreate, MessageActionChatEditTitle, MessageActionChatEditPhoto, MessageActionChatDeletePhoto, MessageActionChatAddUser, MessageActionChatDeleteUser, MessageActionChatJoinedByLink, MessageActionChannelCreate, MessageActionChatMigrateTo, MessageActionChannelMigrateFrom, MessageActionPinMessage, MessageActionHistoryClear, MessageActionGameScore, MessageActionPaymentSentMe, MessageActionPaymentSent, MessageActionPhoneCall, MessageActionScreenshotTaken, MessageActionCustomAction, MessageActionBotAllowed, MessageActionSecureValuesSentMe, MessageActionSecureValuesSent.
        """
        self.domain = domain  # type: str

    def to_dict(self):
        return {
            '_': 'MessageActionBotAllowed',
            'domain': self.domain
        }

    def __bytes__(self):
        return b''.join((
            b'\xfe\xaf\xe9\xab',
            self.serialize_bytes(self.domain),
        ))

    @classmethod
    def from_reader(cls, reader):
        _domain = reader.tgread_string()
        return cls(domain=_domain)


class MessageActionChannelCreate(TLObject):
    CONSTRUCTOR_ID = 0x95d2ac92
    SUBCLASS_OF_ID = 0x8680d126

    def __init__(self, title):
        """
        :param str title:

        Constructor for MessageAction: Instance of either MessageActionEmpty, MessageActionChatCreate, MessageActionChatEditTitle, MessageActionChatEditPhoto, MessageActionChatDeletePhoto, MessageActionChatAddUser, MessageActionChatDeleteUser, MessageActionChatJoinedByLink, MessageActionChannelCreate, MessageActionChatMigrateTo, MessageActionChannelMigrateFrom, MessageActionPinMessage, MessageActionHistoryClear, MessageActionGameScore, MessageActionPaymentSentMe, MessageActionPaymentSent, MessageActionPhoneCall, MessageActionScreenshotTaken, MessageActionCustomAction, MessageActionBotAllowed, MessageActionSecureValuesSentMe, MessageActionSecureValuesSent.
        """
        self.title = title  # type: str

    def to_dict(self):
        return {
            '_': 'MessageActionChannelCreate',
            'title': self.title
        }

    def __bytes__(self):
        return b''.join((
            b'\x92\xac\xd2\x95',
            self.serialize_bytes(self.title),
        ))

    @classmethod
    def from_reader(cls, reader):
        _title = reader.tgread_string()
        return cls(title=_title)


class MessageActionChannelMigrateFrom(TLObject):
    CONSTRUCTOR_ID = 0xb055eaee
    SUBCLASS_OF_ID = 0x8680d126

    def __init__(self, title, chat_id):
        """
        :param str title:
        :param int chat_id:

        Constructor for MessageAction: Instance of either MessageActionEmpty, MessageActionChatCreate, MessageActionChatEditTitle, MessageActionChatEditPhoto, MessageActionChatDeletePhoto, MessageActionChatAddUser, MessageActionChatDeleteUser, MessageActionChatJoinedByLink, MessageActionChannelCreate, MessageActionChatMigrateTo, MessageActionChannelMigrateFrom, MessageActionPinMessage, MessageActionHistoryClear, MessageActionGameScore, MessageActionPaymentSentMe, MessageActionPaymentSent, MessageActionPhoneCall, MessageActionScreenshotTaken, MessageActionCustomAction, MessageActionBotAllowed, MessageActionSecureValuesSentMe, MessageActionSecureValuesSent.
        """
        self.title = title  # type: str
        self.chat_id = chat_id  # type: int

    def to_dict(self):
        return {
            '_': 'MessageActionChannelMigrateFrom',
            'title': self.title,
            'chat_id': self.chat_id
        }

    def __bytes__(self):
        return b''.join((
            b'\xee\xeaU\xb0',
            self.serialize_bytes(self.title),
            struct.pack('<i', self.chat_id),
        ))

    @classmethod
    def from_reader(cls, reader):
        _title = reader.tgread_string()
        _chat_id = reader.read_int()
        return cls(title=_title, chat_id=_chat_id)


class MessageActionChatAddUser(TLObject):
    CONSTRUCTOR_ID = 0x488a7337
    SUBCLASS_OF_ID = 0x8680d126

    def __init__(self, users):
        """
        :param List[int] users:

        Constructor for MessageAction: Instance of either MessageActionEmpty, MessageActionChatCreate, MessageActionChatEditTitle, MessageActionChatEditPhoto, MessageActionChatDeletePhoto, MessageActionChatAddUser, MessageActionChatDeleteUser, MessageActionChatJoinedByLink, MessageActionChannelCreate, MessageActionChatMigrateTo, MessageActionChannelMigrateFrom, MessageActionPinMessage, MessageActionHistoryClear, MessageActionGameScore, MessageActionPaymentSentMe, MessageActionPaymentSent, MessageActionPhoneCall, MessageActionScreenshotTaken, MessageActionCustomAction, MessageActionBotAllowed, MessageActionSecureValuesSentMe, MessageActionSecureValuesSent.
        """
        self.users = users  # type: List[int]

    def to_dict(self):
        return {
            '_': 'MessageActionChatAddUser',
            'users': [] if self.users is None else self.users[:]
        }

    def __bytes__(self):
        return b''.join((
            b'7s\x8aH',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.users)),b''.join(struct.pack('<i', x) for x in self.users),
        ))

    @classmethod
    def from_reader(cls, reader):
        reader.read_int()
        _users = []
        for _ in range(reader.read_int()):
            _x = reader.read_int()
            _users.append(_x)

        return cls(users=_users)


class MessageActionChatCreate(TLObject):
    CONSTRUCTOR_ID = 0xa6638b9a
    SUBCLASS_OF_ID = 0x8680d126

    def __init__(self, title, users):
        """
        :param str title:
        :param List[int] users:

        Constructor for MessageAction: Instance of either MessageActionEmpty, MessageActionChatCreate, MessageActionChatEditTitle, MessageActionChatEditPhoto, MessageActionChatDeletePhoto, MessageActionChatAddUser, MessageActionChatDeleteUser, MessageActionChatJoinedByLink, MessageActionChannelCreate, MessageActionChatMigrateTo, MessageActionChannelMigrateFrom, MessageActionPinMessage, MessageActionHistoryClear, MessageActionGameScore, MessageActionPaymentSentMe, MessageActionPaymentSent, MessageActionPhoneCall, MessageActionScreenshotTaken, MessageActionCustomAction, MessageActionBotAllowed, MessageActionSecureValuesSentMe, MessageActionSecureValuesSent.
        """
        self.title = title  # type: str
        self.users = users  # type: List[int]

    def to_dict(self):
        return {
            '_': 'MessageActionChatCreate',
            'title': self.title,
            'users': [] if self.users is None else self.users[:]
        }

    def __bytes__(self):
        return b''.join((
            b'\x9a\x8bc\xa6',
            self.serialize_bytes(self.title),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.users)),b''.join(struct.pack('<i', x) for x in self.users),
        ))

    @classmethod
    def from_reader(cls, reader):
        _title = reader.tgread_string()
        reader.read_int()
        _users = []
        for _ in range(reader.read_int()):
            _x = reader.read_int()
            _users.append(_x)

        return cls(title=_title, users=_users)


class MessageActionChatDeletePhoto(TLObject):
    CONSTRUCTOR_ID = 0x95e3fbef
    SUBCLASS_OF_ID = 0x8680d126

    def to_dict(self):
        return {
            '_': 'MessageActionChatDeletePhoto'
        }

    def __bytes__(self):
        return b''.join((
            b'\xef\xfb\xe3\x95',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class MessageActionChatDeleteUser(TLObject):
    CONSTRUCTOR_ID = 0xb2ae9b0c
    SUBCLASS_OF_ID = 0x8680d126

    def __init__(self, user_id):
        """
        :param int user_id:

        Constructor for MessageAction: Instance of either MessageActionEmpty, MessageActionChatCreate, MessageActionChatEditTitle, MessageActionChatEditPhoto, MessageActionChatDeletePhoto, MessageActionChatAddUser, MessageActionChatDeleteUser, MessageActionChatJoinedByLink, MessageActionChannelCreate, MessageActionChatMigrateTo, MessageActionChannelMigrateFrom, MessageActionPinMessage, MessageActionHistoryClear, MessageActionGameScore, MessageActionPaymentSentMe, MessageActionPaymentSent, MessageActionPhoneCall, MessageActionScreenshotTaken, MessageActionCustomAction, MessageActionBotAllowed, MessageActionSecureValuesSentMe, MessageActionSecureValuesSent.
        """
        self.user_id = user_id  # type: int

    def to_dict(self):
        return {
            '_': 'MessageActionChatDeleteUser',
            'user_id': self.user_id
        }

    def __bytes__(self):
        return b''.join((
            b'\x0c\x9b\xae\xb2',
            struct.pack('<i', self.user_id),
        ))

    @classmethod
    def from_reader(cls, reader):
        _user_id = reader.read_int()
        return cls(user_id=_user_id)


class MessageActionChatEditPhoto(TLObject):
    CONSTRUCTOR_ID = 0x7fcb13a8
    SUBCLASS_OF_ID = 0x8680d126

    def __init__(self, photo):
        """
        :param TypePhoto photo:

        Constructor for MessageAction: Instance of either MessageActionEmpty, MessageActionChatCreate, MessageActionChatEditTitle, MessageActionChatEditPhoto, MessageActionChatDeletePhoto, MessageActionChatAddUser, MessageActionChatDeleteUser, MessageActionChatJoinedByLink, MessageActionChannelCreate, MessageActionChatMigrateTo, MessageActionChannelMigrateFrom, MessageActionPinMessage, MessageActionHistoryClear, MessageActionGameScore, MessageActionPaymentSentMe, MessageActionPaymentSent, MessageActionPhoneCall, MessageActionScreenshotTaken, MessageActionCustomAction, MessageActionBotAllowed, MessageActionSecureValuesSentMe, MessageActionSecureValuesSent.
        """
        self.photo = photo  # type: TypePhoto

    def to_dict(self):
        return {
            '_': 'MessageActionChatEditPhoto',
            'photo': None if self.photo is None else self.photo.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\xa8\x13\xcb\x7f',
            bytes(self.photo),
        ))

    @classmethod
    def from_reader(cls, reader):
        _photo = reader.tgread_object()
        return cls(photo=_photo)


class MessageActionChatEditTitle(TLObject):
    CONSTRUCTOR_ID = 0xb5a1ce5a
    SUBCLASS_OF_ID = 0x8680d126

    def __init__(self, title):
        """
        :param str title:

        Constructor for MessageAction: Instance of either MessageActionEmpty, MessageActionChatCreate, MessageActionChatEditTitle, MessageActionChatEditPhoto, MessageActionChatDeletePhoto, MessageActionChatAddUser, MessageActionChatDeleteUser, MessageActionChatJoinedByLink, MessageActionChannelCreate, MessageActionChatMigrateTo, MessageActionChannelMigrateFrom, MessageActionPinMessage, MessageActionHistoryClear, MessageActionGameScore, MessageActionPaymentSentMe, MessageActionPaymentSent, MessageActionPhoneCall, MessageActionScreenshotTaken, MessageActionCustomAction, MessageActionBotAllowed, MessageActionSecureValuesSentMe, MessageActionSecureValuesSent.
        """
        self.title = title  # type: str

    def to_dict(self):
        return {
            '_': 'MessageActionChatEditTitle',
            'title': self.title
        }

    def __bytes__(self):
        return b''.join((
            b'Z\xce\xa1\xb5',
            self.serialize_bytes(self.title),
        ))

    @classmethod
    def from_reader(cls, reader):
        _title = reader.tgread_string()
        return cls(title=_title)


class MessageActionChatJoinedByLink(TLObject):
    CONSTRUCTOR_ID = 0xf89cf5e8
    SUBCLASS_OF_ID = 0x8680d126

    def __init__(self, inviter_id):
        """
        :param int inviter_id:

        Constructor for MessageAction: Instance of either MessageActionEmpty, MessageActionChatCreate, MessageActionChatEditTitle, MessageActionChatEditPhoto, MessageActionChatDeletePhoto, MessageActionChatAddUser, MessageActionChatDeleteUser, MessageActionChatJoinedByLink, MessageActionChannelCreate, MessageActionChatMigrateTo, MessageActionChannelMigrateFrom, MessageActionPinMessage, MessageActionHistoryClear, MessageActionGameScore, MessageActionPaymentSentMe, MessageActionPaymentSent, MessageActionPhoneCall, MessageActionScreenshotTaken, MessageActionCustomAction, MessageActionBotAllowed, MessageActionSecureValuesSentMe, MessageActionSecureValuesSent.
        """
        self.inviter_id = inviter_id  # type: int

    def to_dict(self):
        return {
            '_': 'MessageActionChatJoinedByLink',
            'inviter_id': self.inviter_id
        }

    def __bytes__(self):
        return b''.join((
            b'\xe8\xf5\x9c\xf8',
            struct.pack('<i', self.inviter_id),
        ))

    @classmethod
    def from_reader(cls, reader):
        _inviter_id = reader.read_int()
        return cls(inviter_id=_inviter_id)


class MessageActionChatMigrateTo(TLObject):
    CONSTRUCTOR_ID = 0x51bdb021
    SUBCLASS_OF_ID = 0x8680d126

    def __init__(self, channel_id):
        """
        :param int channel_id:

        Constructor for MessageAction: Instance of either MessageActionEmpty, MessageActionChatCreate, MessageActionChatEditTitle, MessageActionChatEditPhoto, MessageActionChatDeletePhoto, MessageActionChatAddUser, MessageActionChatDeleteUser, MessageActionChatJoinedByLink, MessageActionChannelCreate, MessageActionChatMigrateTo, MessageActionChannelMigrateFrom, MessageActionPinMessage, MessageActionHistoryClear, MessageActionGameScore, MessageActionPaymentSentMe, MessageActionPaymentSent, MessageActionPhoneCall, MessageActionScreenshotTaken, MessageActionCustomAction, MessageActionBotAllowed, MessageActionSecureValuesSentMe, MessageActionSecureValuesSent.
        """
        self.channel_id = channel_id  # type: int

    def to_dict(self):
        return {
            '_': 'MessageActionChatMigrateTo',
            'channel_id': self.channel_id
        }

    def __bytes__(self):
        return b''.join((
            b'!\xb0\xbdQ',
            struct.pack('<i', self.channel_id),
        ))

    @classmethod
    def from_reader(cls, reader):
        _channel_id = reader.read_int()
        return cls(channel_id=_channel_id)


class MessageActionCustomAction(TLObject):
    CONSTRUCTOR_ID = 0xfae69f56
    SUBCLASS_OF_ID = 0x8680d126

    def __init__(self, message):
        """
        :param str message:

        Constructor for MessageAction: Instance of either MessageActionEmpty, MessageActionChatCreate, MessageActionChatEditTitle, MessageActionChatEditPhoto, MessageActionChatDeletePhoto, MessageActionChatAddUser, MessageActionChatDeleteUser, MessageActionChatJoinedByLink, MessageActionChannelCreate, MessageActionChatMigrateTo, MessageActionChannelMigrateFrom, MessageActionPinMessage, MessageActionHistoryClear, MessageActionGameScore, MessageActionPaymentSentMe, MessageActionPaymentSent, MessageActionPhoneCall, MessageActionScreenshotTaken, MessageActionCustomAction, MessageActionBotAllowed, MessageActionSecureValuesSentMe, MessageActionSecureValuesSent.
        """
        self.message = message  # type: str

    def to_dict(self):
        return {
            '_': 'MessageActionCustomAction',
            'message': self.message
        }

    def __bytes__(self):
        return b''.join((
            b'V\x9f\xe6\xfa',
            self.serialize_bytes(self.message),
        ))

    @classmethod
    def from_reader(cls, reader):
        _message = reader.tgread_string()
        return cls(message=_message)


class MessageActionEmpty(TLObject):
    CONSTRUCTOR_ID = 0xb6aef7b0
    SUBCLASS_OF_ID = 0x8680d126

    def to_dict(self):
        return {
            '_': 'MessageActionEmpty'
        }

    def __bytes__(self):
        return b''.join((
            b'\xb0\xf7\xae\xb6',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class MessageActionGameScore(TLObject):
    CONSTRUCTOR_ID = 0x92a72876
    SUBCLASS_OF_ID = 0x8680d126

    def __init__(self, game_id, score):
        """
        :param int game_id:
        :param int score:

        Constructor for MessageAction: Instance of either MessageActionEmpty, MessageActionChatCreate, MessageActionChatEditTitle, MessageActionChatEditPhoto, MessageActionChatDeletePhoto, MessageActionChatAddUser, MessageActionChatDeleteUser, MessageActionChatJoinedByLink, MessageActionChannelCreate, MessageActionChatMigrateTo, MessageActionChannelMigrateFrom, MessageActionPinMessage, MessageActionHistoryClear, MessageActionGameScore, MessageActionPaymentSentMe, MessageActionPaymentSent, MessageActionPhoneCall, MessageActionScreenshotTaken, MessageActionCustomAction, MessageActionBotAllowed, MessageActionSecureValuesSentMe, MessageActionSecureValuesSent.
        """
        self.game_id = game_id  # type: int
        self.score = score  # type: int

    def to_dict(self):
        return {
            '_': 'MessageActionGameScore',
            'game_id': self.game_id,
            'score': self.score
        }

    def __bytes__(self):
        return b''.join((
            b'v(\xa7\x92',
            struct.pack('<q', self.game_id),
            struct.pack('<i', self.score),
        ))

    @classmethod
    def from_reader(cls, reader):
        _game_id = reader.read_long()
        _score = reader.read_int()
        return cls(game_id=_game_id, score=_score)


class MessageActionHistoryClear(TLObject):
    CONSTRUCTOR_ID = 0x9fbab604
    SUBCLASS_OF_ID = 0x8680d126

    def to_dict(self):
        return {
            '_': 'MessageActionHistoryClear'
        }

    def __bytes__(self):
        return b''.join((
            b'\x04\xb6\xba\x9f',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class MessageActionPaymentSent(TLObject):
    CONSTRUCTOR_ID = 0x40699cd0
    SUBCLASS_OF_ID = 0x8680d126

    def __init__(self, currency, total_amount):
        """
        :param str currency:
        :param int total_amount:

        Constructor for MessageAction: Instance of either MessageActionEmpty, MessageActionChatCreate, MessageActionChatEditTitle, MessageActionChatEditPhoto, MessageActionChatDeletePhoto, MessageActionChatAddUser, MessageActionChatDeleteUser, MessageActionChatJoinedByLink, MessageActionChannelCreate, MessageActionChatMigrateTo, MessageActionChannelMigrateFrom, MessageActionPinMessage, MessageActionHistoryClear, MessageActionGameScore, MessageActionPaymentSentMe, MessageActionPaymentSent, MessageActionPhoneCall, MessageActionScreenshotTaken, MessageActionCustomAction, MessageActionBotAllowed, MessageActionSecureValuesSentMe, MessageActionSecureValuesSent.
        """
        self.currency = currency  # type: str
        self.total_amount = total_amount  # type: int

    def to_dict(self):
        return {
            '_': 'MessageActionPaymentSent',
            'currency': self.currency,
            'total_amount': self.total_amount
        }

    def __bytes__(self):
        return b''.join((
            b'\xd0\x9ci@',
            self.serialize_bytes(self.currency),
            struct.pack('<q', self.total_amount),
        ))

    @classmethod
    def from_reader(cls, reader):
        _currency = reader.tgread_string()
        _total_amount = reader.read_long()
        return cls(currency=_currency, total_amount=_total_amount)


class MessageActionPaymentSentMe(TLObject):
    CONSTRUCTOR_ID = 0x8f31b327
    SUBCLASS_OF_ID = 0x8680d126

    def __init__(self, currency, total_amount, payload, charge, info=None, shipping_option_id=None):
        """
        :param str currency:
        :param int total_amount:
        :param bytes payload:
        :param TypePaymentCharge charge:
        :param Optional[TypePaymentRequestedInfo] info:
        :param Optional[str] shipping_option_id:

        Constructor for MessageAction: Instance of either MessageActionEmpty, MessageActionChatCreate, MessageActionChatEditTitle, MessageActionChatEditPhoto, MessageActionChatDeletePhoto, MessageActionChatAddUser, MessageActionChatDeleteUser, MessageActionChatJoinedByLink, MessageActionChannelCreate, MessageActionChatMigrateTo, MessageActionChannelMigrateFrom, MessageActionPinMessage, MessageActionHistoryClear, MessageActionGameScore, MessageActionPaymentSentMe, MessageActionPaymentSent, MessageActionPhoneCall, MessageActionScreenshotTaken, MessageActionCustomAction, MessageActionBotAllowed, MessageActionSecureValuesSentMe, MessageActionSecureValuesSent.
        """
        self.currency = currency  # type: str
        self.total_amount = total_amount  # type: int
        self.payload = payload  # type: bytes
        self.charge = charge  # type: TypePaymentCharge
        self.info = info  # type: Optional[TypePaymentRequestedInfo]
        self.shipping_option_id = shipping_option_id  # type: Optional[str]

    def to_dict(self):
        return {
            '_': 'MessageActionPaymentSentMe',
            'currency': self.currency,
            'total_amount': self.total_amount,
            'payload': self.payload,
            'charge': None if self.charge is None else self.charge.to_dict(),
            'info': None if self.info is None else self.info.to_dict(),
            'shipping_option_id': self.shipping_option_id
        }

    def __bytes__(self):
        return b''.join((
            b"'\xb31\x8f",
            struct.pack('<I', (0 if self.info is None or self.info is False else 1) | (0 if self.shipping_option_id is None or self.shipping_option_id is False else 2)),
            self.serialize_bytes(self.currency),
            struct.pack('<q', self.total_amount),
            self.serialize_bytes(self.payload),
            b'' if self.info is None or self.info is False else (bytes(self.info)),
            b'' if self.shipping_option_id is None or self.shipping_option_id is False else (self.serialize_bytes(self.shipping_option_id)),
            bytes(self.charge),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _currency = reader.tgread_string()
        _total_amount = reader.read_long()
        _payload = reader.tgread_bytes()
        if flags & 1:
            _info = reader.tgread_object()
        else:
            _info = None
        if flags & 2:
            _shipping_option_id = reader.tgread_string()
        else:
            _shipping_option_id = None
        _charge = reader.tgread_object()
        return cls(currency=_currency, total_amount=_total_amount, payload=_payload, charge=_charge, info=_info, shipping_option_id=_shipping_option_id)


class MessageActionPhoneCall(TLObject):
    CONSTRUCTOR_ID = 0x80e11a7f
    SUBCLASS_OF_ID = 0x8680d126

    def __init__(self, call_id, reason=None, duration=None):
        """
        :param int call_id:
        :param Optional[TypePhoneCallDiscardReason] reason:
        :param Optional[int] duration:

        Constructor for MessageAction: Instance of either MessageActionEmpty, MessageActionChatCreate, MessageActionChatEditTitle, MessageActionChatEditPhoto, MessageActionChatDeletePhoto, MessageActionChatAddUser, MessageActionChatDeleteUser, MessageActionChatJoinedByLink, MessageActionChannelCreate, MessageActionChatMigrateTo, MessageActionChannelMigrateFrom, MessageActionPinMessage, MessageActionHistoryClear, MessageActionGameScore, MessageActionPaymentSentMe, MessageActionPaymentSent, MessageActionPhoneCall, MessageActionScreenshotTaken, MessageActionCustomAction, MessageActionBotAllowed, MessageActionSecureValuesSentMe, MessageActionSecureValuesSent.
        """
        self.call_id = call_id  # type: int
        self.reason = reason  # type: Optional[TypePhoneCallDiscardReason]
        self.duration = duration  # type: Optional[int]

    def to_dict(self):
        return {
            '_': 'MessageActionPhoneCall',
            'call_id': self.call_id,
            'reason': None if self.reason is None else self.reason.to_dict(),
            'duration': self.duration
        }

    def __bytes__(self):
        return b''.join((
            b'\x7f\x1a\xe1\x80',
            struct.pack('<I', (0 if self.reason is None or self.reason is False else 1) | (0 if self.duration is None or self.duration is False else 2)),
            struct.pack('<q', self.call_id),
            b'' if self.reason is None or self.reason is False else (bytes(self.reason)),
            b'' if self.duration is None or self.duration is False else (struct.pack('<i', self.duration)),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _call_id = reader.read_long()
        if flags & 1:
            _reason = reader.tgread_object()
        else:
            _reason = None
        if flags & 2:
            _duration = reader.read_int()
        else:
            _duration = None
        return cls(call_id=_call_id, reason=_reason, duration=_duration)


class MessageActionPinMessage(TLObject):
    CONSTRUCTOR_ID = 0x94bd38ed
    SUBCLASS_OF_ID = 0x8680d126

    def to_dict(self):
        return {
            '_': 'MessageActionPinMessage'
        }

    def __bytes__(self):
        return b''.join((
            b'\xed8\xbd\x94',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class MessageActionScreenshotTaken(TLObject):
    CONSTRUCTOR_ID = 0x4792929b
    SUBCLASS_OF_ID = 0x8680d126

    def to_dict(self):
        return {
            '_': 'MessageActionScreenshotTaken'
        }

    def __bytes__(self):
        return b''.join((
            b'\x9b\x92\x92G',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class MessageActionSecureValuesSent(TLObject):
    CONSTRUCTOR_ID = 0xd95c6154
    SUBCLASS_OF_ID = 0x8680d126

    def __init__(self, types):
        """
        :param List[TypeSecureValueType] types:

        Constructor for MessageAction: Instance of either MessageActionEmpty, MessageActionChatCreate, MessageActionChatEditTitle, MessageActionChatEditPhoto, MessageActionChatDeletePhoto, MessageActionChatAddUser, MessageActionChatDeleteUser, MessageActionChatJoinedByLink, MessageActionChannelCreate, MessageActionChatMigrateTo, MessageActionChannelMigrateFrom, MessageActionPinMessage, MessageActionHistoryClear, MessageActionGameScore, MessageActionPaymentSentMe, MessageActionPaymentSent, MessageActionPhoneCall, MessageActionScreenshotTaken, MessageActionCustomAction, MessageActionBotAllowed, MessageActionSecureValuesSentMe, MessageActionSecureValuesSent.
        """
        self.types = types  # type: List[TypeSecureValueType]

    def to_dict(self):
        return {
            '_': 'MessageActionSecureValuesSent',
            'types': [] if self.types is None else [None if x is None else x.to_dict() for x in self.types]
        }

    def __bytes__(self):
        return b''.join((
            b'Ta\\\xd9',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.types)),b''.join(bytes(x) for x in self.types),
        ))

    @classmethod
    def from_reader(cls, reader):
        reader.read_int()
        _types = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _types.append(_x)

        return cls(types=_types)


class MessageActionSecureValuesSentMe(TLObject):
    CONSTRUCTOR_ID = 0x1b287353
    SUBCLASS_OF_ID = 0x8680d126

    def __init__(self, values, credentials):
        """
        :param List[TypeSecureValue] values:
        :param TypeSecureCredentialsEncrypted credentials:

        Constructor for MessageAction: Instance of either MessageActionEmpty, MessageActionChatCreate, MessageActionChatEditTitle, MessageActionChatEditPhoto, MessageActionChatDeletePhoto, MessageActionChatAddUser, MessageActionChatDeleteUser, MessageActionChatJoinedByLink, MessageActionChannelCreate, MessageActionChatMigrateTo, MessageActionChannelMigrateFrom, MessageActionPinMessage, MessageActionHistoryClear, MessageActionGameScore, MessageActionPaymentSentMe, MessageActionPaymentSent, MessageActionPhoneCall, MessageActionScreenshotTaken, MessageActionCustomAction, MessageActionBotAllowed, MessageActionSecureValuesSentMe, MessageActionSecureValuesSent.
        """
        self.values = values  # type: List[TypeSecureValue]
        self.credentials = credentials  # type: TypeSecureCredentialsEncrypted

    def to_dict(self):
        return {
            '_': 'MessageActionSecureValuesSentMe',
            'values': [] if self.values is None else [None if x is None else x.to_dict() for x in self.values],
            'credentials': None if self.credentials is None else self.credentials.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'Ss(\x1b',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.values)),b''.join(bytes(x) for x in self.values),
            bytes(self.credentials),
        ))

    @classmethod
    def from_reader(cls, reader):
        reader.read_int()
        _values = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _values.append(_x)

        _credentials = reader.tgread_object()
        return cls(values=_values, credentials=_credentials)
MessageEmpty = None  # Patched


class MessageEntityBold(TLObject):
    CONSTRUCTOR_ID = 0xbd610bc9
    SUBCLASS_OF_ID = 0xcf6419dc

    def __init__(self, offset, length):
        """
        :param int offset:
        :param int length:

        Constructor for MessageEntity: Instance of either MessageEntityUnknown, MessageEntityMention, MessageEntityHashtag, MessageEntityBotCommand, MessageEntityUrl, MessageEntityEmail, MessageEntityBold, MessageEntityItalic, MessageEntityCode, MessageEntityPre, MessageEntityTextUrl, MessageEntityMentionName, InputMessageEntityMentionName, MessageEntityPhone, MessageEntityCashtag.
        """
        self.offset = offset  # type: int
        self.length = length  # type: int

    def to_dict(self):
        return {
            '_': 'MessageEntityBold',
            'offset': self.offset,
            'length': self.length
        }

    def __bytes__(self):
        return b''.join((
            b'\xc9\x0ba\xbd',
            struct.pack('<i', self.offset),
            struct.pack('<i', self.length),
        ))

    @classmethod
    def from_reader(cls, reader):
        _offset = reader.read_int()
        _length = reader.read_int()
        return cls(offset=_offset, length=_length)


class MessageEntityBotCommand(TLObject):
    CONSTRUCTOR_ID = 0x6cef8ac7
    SUBCLASS_OF_ID = 0xcf6419dc

    def __init__(self, offset, length):
        """
        :param int offset:
        :param int length:

        Constructor for MessageEntity: Instance of either MessageEntityUnknown, MessageEntityMention, MessageEntityHashtag, MessageEntityBotCommand, MessageEntityUrl, MessageEntityEmail, MessageEntityBold, MessageEntityItalic, MessageEntityCode, MessageEntityPre, MessageEntityTextUrl, MessageEntityMentionName, InputMessageEntityMentionName, MessageEntityPhone, MessageEntityCashtag.
        """
        self.offset = offset  # type: int
        self.length = length  # type: int

    def to_dict(self):
        return {
            '_': 'MessageEntityBotCommand',
            'offset': self.offset,
            'length': self.length
        }

    def __bytes__(self):
        return b''.join((
            b'\xc7\x8a\xefl',
            struct.pack('<i', self.offset),
            struct.pack('<i', self.length),
        ))

    @classmethod
    def from_reader(cls, reader):
        _offset = reader.read_int()
        _length = reader.read_int()
        return cls(offset=_offset, length=_length)


class MessageEntityCashtag(TLObject):
    CONSTRUCTOR_ID = 0x4c4e743f
    SUBCLASS_OF_ID = 0xcf6419dc

    def __init__(self, offset, length):
        """
        :param int offset:
        :param int length:

        Constructor for MessageEntity: Instance of either MessageEntityUnknown, MessageEntityMention, MessageEntityHashtag, MessageEntityBotCommand, MessageEntityUrl, MessageEntityEmail, MessageEntityBold, MessageEntityItalic, MessageEntityCode, MessageEntityPre, MessageEntityTextUrl, MessageEntityMentionName, InputMessageEntityMentionName, MessageEntityPhone, MessageEntityCashtag.
        """
        self.offset = offset  # type: int
        self.length = length  # type: int

    def to_dict(self):
        return {
            '_': 'MessageEntityCashtag',
            'offset': self.offset,
            'length': self.length
        }

    def __bytes__(self):
        return b''.join((
            b'?tNL',
            struct.pack('<i', self.offset),
            struct.pack('<i', self.length),
        ))

    @classmethod
    def from_reader(cls, reader):
        _offset = reader.read_int()
        _length = reader.read_int()
        return cls(offset=_offset, length=_length)


class MessageEntityCode(TLObject):
    CONSTRUCTOR_ID = 0x28a20571
    SUBCLASS_OF_ID = 0xcf6419dc

    def __init__(self, offset, length):
        """
        :param int offset:
        :param int length:

        Constructor for MessageEntity: Instance of either MessageEntityUnknown, MessageEntityMention, MessageEntityHashtag, MessageEntityBotCommand, MessageEntityUrl, MessageEntityEmail, MessageEntityBold, MessageEntityItalic, MessageEntityCode, MessageEntityPre, MessageEntityTextUrl, MessageEntityMentionName, InputMessageEntityMentionName, MessageEntityPhone, MessageEntityCashtag.
        """
        self.offset = offset  # type: int
        self.length = length  # type: int

    def to_dict(self):
        return {
            '_': 'MessageEntityCode',
            'offset': self.offset,
            'length': self.length
        }

    def __bytes__(self):
        return b''.join((
            b'q\x05\xa2(',
            struct.pack('<i', self.offset),
            struct.pack('<i', self.length),
        ))

    @classmethod
    def from_reader(cls, reader):
        _offset = reader.read_int()
        _length = reader.read_int()
        return cls(offset=_offset, length=_length)


class MessageEntityEmail(TLObject):
    CONSTRUCTOR_ID = 0x64e475c2
    SUBCLASS_OF_ID = 0xcf6419dc

    def __init__(self, offset, length):
        """
        :param int offset:
        :param int length:

        Constructor for MessageEntity: Instance of either MessageEntityUnknown, MessageEntityMention, MessageEntityHashtag, MessageEntityBotCommand, MessageEntityUrl, MessageEntityEmail, MessageEntityBold, MessageEntityItalic, MessageEntityCode, MessageEntityPre, MessageEntityTextUrl, MessageEntityMentionName, InputMessageEntityMentionName, MessageEntityPhone, MessageEntityCashtag.
        """
        self.offset = offset  # type: int
        self.length = length  # type: int

    def to_dict(self):
        return {
            '_': 'MessageEntityEmail',
            'offset': self.offset,
            'length': self.length
        }

    def __bytes__(self):
        return b''.join((
            b'\xc2u\xe4d',
            struct.pack('<i', self.offset),
            struct.pack('<i', self.length),
        ))

    @classmethod
    def from_reader(cls, reader):
        _offset = reader.read_int()
        _length = reader.read_int()
        return cls(offset=_offset, length=_length)


class MessageEntityHashtag(TLObject):
    CONSTRUCTOR_ID = 0x6f635b0d
    SUBCLASS_OF_ID = 0xcf6419dc

    def __init__(self, offset, length):
        """
        :param int offset:
        :param int length:

        Constructor for MessageEntity: Instance of either MessageEntityUnknown, MessageEntityMention, MessageEntityHashtag, MessageEntityBotCommand, MessageEntityUrl, MessageEntityEmail, MessageEntityBold, MessageEntityItalic, MessageEntityCode, MessageEntityPre, MessageEntityTextUrl, MessageEntityMentionName, InputMessageEntityMentionName, MessageEntityPhone, MessageEntityCashtag.
        """
        self.offset = offset  # type: int
        self.length = length  # type: int

    def to_dict(self):
        return {
            '_': 'MessageEntityHashtag',
            'offset': self.offset,
            'length': self.length
        }

    def __bytes__(self):
        return b''.join((
            b'\r[co',
            struct.pack('<i', self.offset),
            struct.pack('<i', self.length),
        ))

    @classmethod
    def from_reader(cls, reader):
        _offset = reader.read_int()
        _length = reader.read_int()
        return cls(offset=_offset, length=_length)


class MessageEntityItalic(TLObject):
    CONSTRUCTOR_ID = 0x826f8b60
    SUBCLASS_OF_ID = 0xcf6419dc

    def __init__(self, offset, length):
        """
        :param int offset:
        :param int length:

        Constructor for MessageEntity: Instance of either MessageEntityUnknown, MessageEntityMention, MessageEntityHashtag, MessageEntityBotCommand, MessageEntityUrl, MessageEntityEmail, MessageEntityBold, MessageEntityItalic, MessageEntityCode, MessageEntityPre, MessageEntityTextUrl, MessageEntityMentionName, InputMessageEntityMentionName, MessageEntityPhone, MessageEntityCashtag.
        """
        self.offset = offset  # type: int
        self.length = length  # type: int

    def to_dict(self):
        return {
            '_': 'MessageEntityItalic',
            'offset': self.offset,
            'length': self.length
        }

    def __bytes__(self):
        return b''.join((
            b'`\x8bo\x82',
            struct.pack('<i', self.offset),
            struct.pack('<i', self.length),
        ))

    @classmethod
    def from_reader(cls, reader):
        _offset = reader.read_int()
        _length = reader.read_int()
        return cls(offset=_offset, length=_length)


class MessageEntityMention(TLObject):
    CONSTRUCTOR_ID = 0xfa04579d
    SUBCLASS_OF_ID = 0xcf6419dc

    def __init__(self, offset, length):
        """
        :param int offset:
        :param int length:

        Constructor for MessageEntity: Instance of either MessageEntityUnknown, MessageEntityMention, MessageEntityHashtag, MessageEntityBotCommand, MessageEntityUrl, MessageEntityEmail, MessageEntityBold, MessageEntityItalic, MessageEntityCode, MessageEntityPre, MessageEntityTextUrl, MessageEntityMentionName, InputMessageEntityMentionName, MessageEntityPhone, MessageEntityCashtag.
        """
        self.offset = offset  # type: int
        self.length = length  # type: int

    def to_dict(self):
        return {
            '_': 'MessageEntityMention',
            'offset': self.offset,
            'length': self.length
        }

    def __bytes__(self):
        return b''.join((
            b'\x9dW\x04\xfa',
            struct.pack('<i', self.offset),
            struct.pack('<i', self.length),
        ))

    @classmethod
    def from_reader(cls, reader):
        _offset = reader.read_int()
        _length = reader.read_int()
        return cls(offset=_offset, length=_length)


class MessageEntityMentionName(TLObject):
    CONSTRUCTOR_ID = 0x352dca58
    SUBCLASS_OF_ID = 0xcf6419dc

    def __init__(self, offset, length, user_id):
        """
        :param int offset:
        :param int length:
        :param int user_id:

        Constructor for MessageEntity: Instance of either MessageEntityUnknown, MessageEntityMention, MessageEntityHashtag, MessageEntityBotCommand, MessageEntityUrl, MessageEntityEmail, MessageEntityBold, MessageEntityItalic, MessageEntityCode, MessageEntityPre, MessageEntityTextUrl, MessageEntityMentionName, InputMessageEntityMentionName, MessageEntityPhone, MessageEntityCashtag.
        """
        self.offset = offset  # type: int
        self.length = length  # type: int
        self.user_id = user_id  # type: int

    def to_dict(self):
        return {
            '_': 'MessageEntityMentionName',
            'offset': self.offset,
            'length': self.length,
            'user_id': self.user_id
        }

    def __bytes__(self):
        return b''.join((
            b'X\xca-5',
            struct.pack('<i', self.offset),
            struct.pack('<i', self.length),
            struct.pack('<i', self.user_id),
        ))

    @classmethod
    def from_reader(cls, reader):
        _offset = reader.read_int()
        _length = reader.read_int()
        _user_id = reader.read_int()
        return cls(offset=_offset, length=_length, user_id=_user_id)


class MessageEntityPhone(TLObject):
    CONSTRUCTOR_ID = 0x9b69e34b
    SUBCLASS_OF_ID = 0xcf6419dc

    def __init__(self, offset, length):
        """
        :param int offset:
        :param int length:

        Constructor for MessageEntity: Instance of either MessageEntityUnknown, MessageEntityMention, MessageEntityHashtag, MessageEntityBotCommand, MessageEntityUrl, MessageEntityEmail, MessageEntityBold, MessageEntityItalic, MessageEntityCode, MessageEntityPre, MessageEntityTextUrl, MessageEntityMentionName, InputMessageEntityMentionName, MessageEntityPhone, MessageEntityCashtag.
        """
        self.offset = offset  # type: int
        self.length = length  # type: int

    def to_dict(self):
        return {
            '_': 'MessageEntityPhone',
            'offset': self.offset,
            'length': self.length
        }

    def __bytes__(self):
        return b''.join((
            b'K\xe3i\x9b',
            struct.pack('<i', self.offset),
            struct.pack('<i', self.length),
        ))

    @classmethod
    def from_reader(cls, reader):
        _offset = reader.read_int()
        _length = reader.read_int()
        return cls(offset=_offset, length=_length)


class MessageEntityPre(TLObject):
    CONSTRUCTOR_ID = 0x73924be0
    SUBCLASS_OF_ID = 0xcf6419dc

    def __init__(self, offset, length, language):
        """
        :param int offset:
        :param int length:
        :param str language:

        Constructor for MessageEntity: Instance of either MessageEntityUnknown, MessageEntityMention, MessageEntityHashtag, MessageEntityBotCommand, MessageEntityUrl, MessageEntityEmail, MessageEntityBold, MessageEntityItalic, MessageEntityCode, MessageEntityPre, MessageEntityTextUrl, MessageEntityMentionName, InputMessageEntityMentionName, MessageEntityPhone, MessageEntityCashtag.
        """
        self.offset = offset  # type: int
        self.length = length  # type: int
        self.language = language  # type: str

    def to_dict(self):
        return {
            '_': 'MessageEntityPre',
            'offset': self.offset,
            'length': self.length,
            'language': self.language
        }

    def __bytes__(self):
        return b''.join((
            b'\xe0K\x92s',
            struct.pack('<i', self.offset),
            struct.pack('<i', self.length),
            self.serialize_bytes(self.language),
        ))

    @classmethod
    def from_reader(cls, reader):
        _offset = reader.read_int()
        _length = reader.read_int()
        _language = reader.tgread_string()
        return cls(offset=_offset, length=_length, language=_language)


class MessageEntityTextUrl(TLObject):
    CONSTRUCTOR_ID = 0x76a6d327
    SUBCLASS_OF_ID = 0xcf6419dc

    def __init__(self, offset, length, url):
        """
        :param int offset:
        :param int length:
        :param str url:

        Constructor for MessageEntity: Instance of either MessageEntityUnknown, MessageEntityMention, MessageEntityHashtag, MessageEntityBotCommand, MessageEntityUrl, MessageEntityEmail, MessageEntityBold, MessageEntityItalic, MessageEntityCode, MessageEntityPre, MessageEntityTextUrl, MessageEntityMentionName, InputMessageEntityMentionName, MessageEntityPhone, MessageEntityCashtag.
        """
        self.offset = offset  # type: int
        self.length = length  # type: int
        self.url = url  # type: str

    def to_dict(self):
        return {
            '_': 'MessageEntityTextUrl',
            'offset': self.offset,
            'length': self.length,
            'url': self.url
        }

    def __bytes__(self):
        return b''.join((
            b"'\xd3\xa6v",
            struct.pack('<i', self.offset),
            struct.pack('<i', self.length),
            self.serialize_bytes(self.url),
        ))

    @classmethod
    def from_reader(cls, reader):
        _offset = reader.read_int()
        _length = reader.read_int()
        _url = reader.tgread_string()
        return cls(offset=_offset, length=_length, url=_url)


class MessageEntityUnknown(TLObject):
    CONSTRUCTOR_ID = 0xbb92ba95
    SUBCLASS_OF_ID = 0xcf6419dc

    def __init__(self, offset, length):
        """
        :param int offset:
        :param int length:

        Constructor for MessageEntity: Instance of either MessageEntityUnknown, MessageEntityMention, MessageEntityHashtag, MessageEntityBotCommand, MessageEntityUrl, MessageEntityEmail, MessageEntityBold, MessageEntityItalic, MessageEntityCode, MessageEntityPre, MessageEntityTextUrl, MessageEntityMentionName, InputMessageEntityMentionName, MessageEntityPhone, MessageEntityCashtag.
        """
        self.offset = offset  # type: int
        self.length = length  # type: int

    def to_dict(self):
        return {
            '_': 'MessageEntityUnknown',
            'offset': self.offset,
            'length': self.length
        }

    def __bytes__(self):
        return b''.join((
            b'\x95\xba\x92\xbb',
            struct.pack('<i', self.offset),
            struct.pack('<i', self.length),
        ))

    @classmethod
    def from_reader(cls, reader):
        _offset = reader.read_int()
        _length = reader.read_int()
        return cls(offset=_offset, length=_length)


class MessageEntityUrl(TLObject):
    CONSTRUCTOR_ID = 0x6ed02538
    SUBCLASS_OF_ID = 0xcf6419dc

    def __init__(self, offset, length):
        """
        :param int offset:
        :param int length:

        Constructor for MessageEntity: Instance of either MessageEntityUnknown, MessageEntityMention, MessageEntityHashtag, MessageEntityBotCommand, MessageEntityUrl, MessageEntityEmail, MessageEntityBold, MessageEntityItalic, MessageEntityCode, MessageEntityPre, MessageEntityTextUrl, MessageEntityMentionName, InputMessageEntityMentionName, MessageEntityPhone, MessageEntityCashtag.
        """
        self.offset = offset  # type: int
        self.length = length  # type: int

    def to_dict(self):
        return {
            '_': 'MessageEntityUrl',
            'offset': self.offset,
            'length': self.length
        }

    def __bytes__(self):
        return b''.join((
            b'8%\xd0n',
            struct.pack('<i', self.offset),
            struct.pack('<i', self.length),
        ))

    @classmethod
    def from_reader(cls, reader):
        _offset = reader.read_int()
        _length = reader.read_int()
        return cls(offset=_offset, length=_length)


class MessageFwdHeader(TLObject):
    CONSTRUCTOR_ID = 0x559ebe6d
    SUBCLASS_OF_ID = 0x7a286804

    def __init__(self, date, from_id=None, channel_id=None, channel_post=None, post_author=None, saved_from_peer=None, saved_from_msg_id=None):
        """
        :param Optional[datetime] date:
        :param Optional[int] from_id:
        :param Optional[int] channel_id:
        :param Optional[int] channel_post:
        :param Optional[str] post_author:
        :param Optional[TypePeer] saved_from_peer:
        :param Optional[int] saved_from_msg_id:

        Constructor for MessageFwdHeader: Instance of MessageFwdHeader.
        """
        self.date = date  # type: Optional[datetime]
        self.from_id = from_id  # type: Optional[int]
        self.channel_id = channel_id  # type: Optional[int]
        self.channel_post = channel_post  # type: Optional[int]
        self.post_author = post_author  # type: Optional[str]
        self.saved_from_peer = saved_from_peer  # type: Optional[TypePeer]
        self.saved_from_msg_id = saved_from_msg_id  # type: Optional[int]

    def to_dict(self):
        return {
            '_': 'MessageFwdHeader',
            'date': self.date,
            'from_id': self.from_id,
            'channel_id': self.channel_id,
            'channel_post': self.channel_post,
            'post_author': self.post_author,
            'saved_from_peer': None if self.saved_from_peer is None else self.saved_from_peer.to_dict(),
            'saved_from_msg_id': self.saved_from_msg_id
        }

    def __bytes__(self):
        assert ((self.saved_from_peer or self.saved_from_peer is not None) and (self.saved_from_msg_id or self.saved_from_msg_id is not None)) or ((self.saved_from_peer is None or self.saved_from_peer is False) and (self.saved_from_msg_id is None or self.saved_from_msg_id is False)), 'saved_from_peer, saved_from_msg_id parameters must all be False-y (like None) or all me True-y'
        return b''.join((
            b'm\xbe\x9eU',
            struct.pack('<I', (0 if self.from_id is None or self.from_id is False else 1) | (0 if self.channel_id is None or self.channel_id is False else 2) | (0 if self.channel_post is None or self.channel_post is False else 4) | (0 if self.post_author is None or self.post_author is False else 8) | (0 if self.saved_from_peer is None or self.saved_from_peer is False else 16) | (0 if self.saved_from_msg_id is None or self.saved_from_msg_id is False else 16)),
            b'' if self.from_id is None or self.from_id is False else (struct.pack('<i', self.from_id)),
            self.serialize_datetime(self.date),
            b'' if self.channel_id is None or self.channel_id is False else (struct.pack('<i', self.channel_id)),
            b'' if self.channel_post is None or self.channel_post is False else (struct.pack('<i', self.channel_post)),
            b'' if self.post_author is None or self.post_author is False else (self.serialize_bytes(self.post_author)),
            b'' if self.saved_from_peer is None or self.saved_from_peer is False else (bytes(self.saved_from_peer)),
            b'' if self.saved_from_msg_id is None or self.saved_from_msg_id is False else (struct.pack('<i', self.saved_from_msg_id)),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        if flags & 1:
            _from_id = reader.read_int()
        else:
            _from_id = None
        _date = reader.tgread_date()
        if flags & 2:
            _channel_id = reader.read_int()
        else:
            _channel_id = None
        if flags & 4:
            _channel_post = reader.read_int()
        else:
            _channel_post = None
        if flags & 8:
            _post_author = reader.tgread_string()
        else:
            _post_author = None
        if flags & 16:
            _saved_from_peer = reader.tgread_object()
        else:
            _saved_from_peer = None
        if flags & 16:
            _saved_from_msg_id = reader.read_int()
        else:
            _saved_from_msg_id = None
        return cls(date=_date, from_id=_from_id, channel_id=_channel_id, channel_post=_channel_post, post_author=_post_author, saved_from_peer=_saved_from_peer, saved_from_msg_id=_saved_from_msg_id)


class MessageMediaContact(TLObject):
    CONSTRUCTOR_ID = 0xcbf24940
    SUBCLASS_OF_ID = 0x476cbe32

    def __init__(self, phone_number, first_name, last_name, vcard, user_id):
        """
        :param str phone_number:
        :param str first_name:
        :param str last_name:
        :param str vcard:
        :param int user_id:

        Constructor for MessageMedia: Instance of either MessageMediaEmpty, MessageMediaPhoto, MessageMediaGeo, MessageMediaContact, MessageMediaUnsupported, MessageMediaDocument, MessageMediaWebPage, MessageMediaVenue, MessageMediaGame, MessageMediaInvoice, MessageMediaGeoLive.
        """
        self.phone_number = phone_number  # type: str
        self.first_name = first_name  # type: str
        self.last_name = last_name  # type: str
        self.vcard = vcard  # type: str
        self.user_id = user_id  # type: int

    def to_dict(self):
        return {
            '_': 'MessageMediaContact',
            'phone_number': self.phone_number,
            'first_name': self.first_name,
            'last_name': self.last_name,
            'vcard': self.vcard,
            'user_id': self.user_id
        }

    def __bytes__(self):
        return b''.join((
            b'@I\xf2\xcb',
            self.serialize_bytes(self.phone_number),
            self.serialize_bytes(self.first_name),
            self.serialize_bytes(self.last_name),
            self.serialize_bytes(self.vcard),
            struct.pack('<i', self.user_id),
        ))

    @classmethod
    def from_reader(cls, reader):
        _phone_number = reader.tgread_string()
        _first_name = reader.tgread_string()
        _last_name = reader.tgread_string()
        _vcard = reader.tgread_string()
        _user_id = reader.read_int()
        return cls(phone_number=_phone_number, first_name=_first_name, last_name=_last_name, vcard=_vcard, user_id=_user_id)


class MessageMediaDocument(TLObject):
    CONSTRUCTOR_ID = 0x9cb070d7
    SUBCLASS_OF_ID = 0x476cbe32

    def __init__(self, document=None, ttl_seconds=None):
        """
        :param Optional[TypeDocument] document:
        :param Optional[int] ttl_seconds:

        Constructor for MessageMedia: Instance of either MessageMediaEmpty, MessageMediaPhoto, MessageMediaGeo, MessageMediaContact, MessageMediaUnsupported, MessageMediaDocument, MessageMediaWebPage, MessageMediaVenue, MessageMediaGame, MessageMediaInvoice, MessageMediaGeoLive.
        """
        self.document = document  # type: Optional[TypeDocument]
        self.ttl_seconds = ttl_seconds  # type: Optional[int]

    def to_dict(self):
        return {
            '_': 'MessageMediaDocument',
            'document': None if self.document is None else self.document.to_dict(),
            'ttl_seconds': self.ttl_seconds
        }

    def __bytes__(self):
        return b''.join((
            b'\xd7p\xb0\x9c',
            struct.pack('<I', (0 if self.document is None or self.document is False else 1) | (0 if self.ttl_seconds is None or self.ttl_seconds is False else 4)),
            b'' if self.document is None or self.document is False else (bytes(self.document)),
            b'' if self.ttl_seconds is None or self.ttl_seconds is False else (struct.pack('<i', self.ttl_seconds)),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        if flags & 1:
            _document = reader.tgread_object()
        else:
            _document = None
        if flags & 4:
            _ttl_seconds = reader.read_int()
        else:
            _ttl_seconds = None
        return cls(document=_document, ttl_seconds=_ttl_seconds)


class MessageMediaEmpty(TLObject):
    CONSTRUCTOR_ID = 0x3ded6320
    SUBCLASS_OF_ID = 0x476cbe32

    def to_dict(self):
        return {
            '_': 'MessageMediaEmpty'
        }

    def __bytes__(self):
        return b''.join((
            b' c\xed=',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class MessageMediaGame(TLObject):
    CONSTRUCTOR_ID = 0xfdb19008
    SUBCLASS_OF_ID = 0x476cbe32

    def __init__(self, game):
        """
        :param TypeGame game:

        Constructor for MessageMedia: Instance of either MessageMediaEmpty, MessageMediaPhoto, MessageMediaGeo, MessageMediaContact, MessageMediaUnsupported, MessageMediaDocument, MessageMediaWebPage, MessageMediaVenue, MessageMediaGame, MessageMediaInvoice, MessageMediaGeoLive.
        """
        self.game = game  # type: TypeGame

    def to_dict(self):
        return {
            '_': 'MessageMediaGame',
            'game': None if self.game is None else self.game.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\x08\x90\xb1\xfd',
            bytes(self.game),
        ))

    @classmethod
    def from_reader(cls, reader):
        _game = reader.tgread_object()
        return cls(game=_game)


class MessageMediaGeo(TLObject):
    CONSTRUCTOR_ID = 0x56e0d474
    SUBCLASS_OF_ID = 0x476cbe32

    def __init__(self, geo):
        """
        :param TypeGeoPoint geo:

        Constructor for MessageMedia: Instance of either MessageMediaEmpty, MessageMediaPhoto, MessageMediaGeo, MessageMediaContact, MessageMediaUnsupported, MessageMediaDocument, MessageMediaWebPage, MessageMediaVenue, MessageMediaGame, MessageMediaInvoice, MessageMediaGeoLive.
        """
        self.geo = geo  # type: TypeGeoPoint

    def to_dict(self):
        return {
            '_': 'MessageMediaGeo',
            'geo': None if self.geo is None else self.geo.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b't\xd4\xe0V',
            bytes(self.geo),
        ))

    @classmethod
    def from_reader(cls, reader):
        _geo = reader.tgread_object()
        return cls(geo=_geo)


class MessageMediaGeoLive(TLObject):
    CONSTRUCTOR_ID = 0x7c3c2609
    SUBCLASS_OF_ID = 0x476cbe32

    def __init__(self, geo, period):
        """
        :param TypeGeoPoint geo:
        :param int period:

        Constructor for MessageMedia: Instance of either MessageMediaEmpty, MessageMediaPhoto, MessageMediaGeo, MessageMediaContact, MessageMediaUnsupported, MessageMediaDocument, MessageMediaWebPage, MessageMediaVenue, MessageMediaGame, MessageMediaInvoice, MessageMediaGeoLive.
        """
        self.geo = geo  # type: TypeGeoPoint
        self.period = period  # type: int

    def to_dict(self):
        return {
            '_': 'MessageMediaGeoLive',
            'geo': None if self.geo is None else self.geo.to_dict(),
            'period': self.period
        }

    def __bytes__(self):
        return b''.join((
            b'\t&<|',
            bytes(self.geo),
            struct.pack('<i', self.period),
        ))

    @classmethod
    def from_reader(cls, reader):
        _geo = reader.tgread_object()
        _period = reader.read_int()
        return cls(geo=_geo, period=_period)


class MessageMediaInvoice(TLObject):
    CONSTRUCTOR_ID = 0x84551347
    SUBCLASS_OF_ID = 0x476cbe32

    def __init__(self, title, description, currency, total_amount, start_param, shipping_address_requested=None, test=None, photo=None, receipt_msg_id=None):
        """
        :param str title:
        :param str description:
        :param str currency:
        :param int total_amount:
        :param str start_param:
        :param Optional[bool] shipping_address_requested:
        :param Optional[bool] test:
        :param Optional[TypeWebDocument] photo:
        :param Optional[int] receipt_msg_id:

        Constructor for MessageMedia: Instance of either MessageMediaEmpty, MessageMediaPhoto, MessageMediaGeo, MessageMediaContact, MessageMediaUnsupported, MessageMediaDocument, MessageMediaWebPage, MessageMediaVenue, MessageMediaGame, MessageMediaInvoice, MessageMediaGeoLive.
        """
        self.title = title  # type: str
        self.description = description  # type: str
        self.currency = currency  # type: str
        self.total_amount = total_amount  # type: int
        self.start_param = start_param  # type: str
        self.shipping_address_requested = shipping_address_requested  # type: Optional[bool]
        self.test = test  # type: Optional[bool]
        self.photo = photo  # type: Optional[TypeWebDocument]
        self.receipt_msg_id = receipt_msg_id  # type: Optional[int]

    def to_dict(self):
        return {
            '_': 'MessageMediaInvoice',
            'title': self.title,
            'description': self.description,
            'currency': self.currency,
            'total_amount': self.total_amount,
            'start_param': self.start_param,
            'shipping_address_requested': self.shipping_address_requested,
            'test': self.test,
            'photo': None if self.photo is None else self.photo.to_dict(),
            'receipt_msg_id': self.receipt_msg_id
        }

    def __bytes__(self):
        return b''.join((
            b'G\x13U\x84',
            struct.pack('<I', (0 if self.shipping_address_requested is None or self.shipping_address_requested is False else 2) | (0 if self.test is None or self.test is False else 8) | (0 if self.photo is None or self.photo is False else 1) | (0 if self.receipt_msg_id is None or self.receipt_msg_id is False else 4)),
            self.serialize_bytes(self.title),
            self.serialize_bytes(self.description),
            b'' if self.photo is None or self.photo is False else (bytes(self.photo)),
            b'' if self.receipt_msg_id is None or self.receipt_msg_id is False else (struct.pack('<i', self.receipt_msg_id)),
            self.serialize_bytes(self.currency),
            struct.pack('<q', self.total_amount),
            self.serialize_bytes(self.start_param),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _shipping_address_requested = bool(flags & 2)
        _test = bool(flags & 8)
        _title = reader.tgread_string()
        _description = reader.tgread_string()
        if flags & 1:
            _photo = reader.tgread_object()
        else:
            _photo = None
        if flags & 4:
            _receipt_msg_id = reader.read_int()
        else:
            _receipt_msg_id = None
        _currency = reader.tgread_string()
        _total_amount = reader.read_long()
        _start_param = reader.tgread_string()
        return cls(title=_title, description=_description, currency=_currency, total_amount=_total_amount, start_param=_start_param, shipping_address_requested=_shipping_address_requested, test=_test, photo=_photo, receipt_msg_id=_receipt_msg_id)


class MessageMediaPhoto(TLObject):
    CONSTRUCTOR_ID = 0x695150d7
    SUBCLASS_OF_ID = 0x476cbe32

    def __init__(self, photo=None, ttl_seconds=None):
        """
        :param Optional[TypePhoto] photo:
        :param Optional[int] ttl_seconds:

        Constructor for MessageMedia: Instance of either MessageMediaEmpty, MessageMediaPhoto, MessageMediaGeo, MessageMediaContact, MessageMediaUnsupported, MessageMediaDocument, MessageMediaWebPage, MessageMediaVenue, MessageMediaGame, MessageMediaInvoice, MessageMediaGeoLive.
        """
        self.photo = photo  # type: Optional[TypePhoto]
        self.ttl_seconds = ttl_seconds  # type: Optional[int]

    def to_dict(self):
        return {
            '_': 'MessageMediaPhoto',
            'photo': None if self.photo is None else self.photo.to_dict(),
            'ttl_seconds': self.ttl_seconds
        }

    def __bytes__(self):
        return b''.join((
            b'\xd7PQi',
            struct.pack('<I', (0 if self.photo is None or self.photo is False else 1) | (0 if self.ttl_seconds is None or self.ttl_seconds is False else 4)),
            b'' if self.photo is None or self.photo is False else (bytes(self.photo)),
            b'' if self.ttl_seconds is None or self.ttl_seconds is False else (struct.pack('<i', self.ttl_seconds)),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        if flags & 1:
            _photo = reader.tgread_object()
        else:
            _photo = None
        if flags & 4:
            _ttl_seconds = reader.read_int()
        else:
            _ttl_seconds = None
        return cls(photo=_photo, ttl_seconds=_ttl_seconds)


class MessageMediaUnsupported(TLObject):
    CONSTRUCTOR_ID = 0x9f84f49e
    SUBCLASS_OF_ID = 0x476cbe32

    def to_dict(self):
        return {
            '_': 'MessageMediaUnsupported'
        }

    def __bytes__(self):
        return b''.join((
            b'\x9e\xf4\x84\x9f',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class MessageMediaVenue(TLObject):
    CONSTRUCTOR_ID = 0x2ec0533f
    SUBCLASS_OF_ID = 0x476cbe32

    def __init__(self, geo, title, address, provider, venue_id, venue_type):
        """
        :param TypeGeoPoint geo:
        :param str title:
        :param str address:
        :param str provider:
        :param str venue_id:
        :param str venue_type:

        Constructor for MessageMedia: Instance of either MessageMediaEmpty, MessageMediaPhoto, MessageMediaGeo, MessageMediaContact, MessageMediaUnsupported, MessageMediaDocument, MessageMediaWebPage, MessageMediaVenue, MessageMediaGame, MessageMediaInvoice, MessageMediaGeoLive.
        """
        self.geo = geo  # type: TypeGeoPoint
        self.title = title  # type: str
        self.address = address  # type: str
        self.provider = provider  # type: str
        self.venue_id = venue_id  # type: str
        self.venue_type = venue_type  # type: str

    def to_dict(self):
        return {
            '_': 'MessageMediaVenue',
            'geo': None if self.geo is None else self.geo.to_dict(),
            'title': self.title,
            'address': self.address,
            'provider': self.provider,
            'venue_id': self.venue_id,
            'venue_type': self.venue_type
        }

    def __bytes__(self):
        return b''.join((
            b'?S\xc0.',
            bytes(self.geo),
            self.serialize_bytes(self.title),
            self.serialize_bytes(self.address),
            self.serialize_bytes(self.provider),
            self.serialize_bytes(self.venue_id),
            self.serialize_bytes(self.venue_type),
        ))

    @classmethod
    def from_reader(cls, reader):
        _geo = reader.tgread_object()
        _title = reader.tgread_string()
        _address = reader.tgread_string()
        _provider = reader.tgread_string()
        _venue_id = reader.tgread_string()
        _venue_type = reader.tgread_string()
        return cls(geo=_geo, title=_title, address=_address, provider=_provider, venue_id=_venue_id, venue_type=_venue_type)


class MessageMediaWebPage(TLObject):
    CONSTRUCTOR_ID = 0xa32dd600
    SUBCLASS_OF_ID = 0x476cbe32

    def __init__(self, webpage):
        """
        :param TypeWebPage webpage:

        Constructor for MessageMedia: Instance of either MessageMediaEmpty, MessageMediaPhoto, MessageMediaGeo, MessageMediaContact, MessageMediaUnsupported, MessageMediaDocument, MessageMediaWebPage, MessageMediaVenue, MessageMediaGame, MessageMediaInvoice, MessageMediaGeoLive.
        """
        self.webpage = webpage  # type: TypeWebPage

    def to_dict(self):
        return {
            '_': 'MessageMediaWebPage',
            'webpage': None if self.webpage is None else self.webpage.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\x00\xd6-\xa3',
            bytes(self.webpage),
        ))

    @classmethod
    def from_reader(cls, reader):
        _webpage = reader.tgread_object()
        return cls(webpage=_webpage)


class MessageRange(TLObject):
    CONSTRUCTOR_ID = 0xae30253
    SUBCLASS_OF_ID = 0xbec74577

    def __init__(self, min_id, max_id):
        """
        :param int min_id:
        :param int max_id:

        Constructor for MessageRange: Instance of MessageRange.
        """
        self.min_id = min_id  # type: int
        self.max_id = max_id  # type: int

    def to_dict(self):
        return {
            '_': 'MessageRange',
            'min_id': self.min_id,
            'max_id': self.max_id
        }

    def __bytes__(self):
        return b''.join((
            b'S\x02\xe3\n',
            struct.pack('<i', self.min_id),
            struct.pack('<i', self.max_id),
        ))

    @classmethod
    def from_reader(cls, reader):
        _min_id = reader.read_int()
        _max_id = reader.read_int()
        return cls(min_id=_min_id, max_id=_max_id)
MessageService = None  # Patched


class MsgDetailedInfo(TLObject):
    CONSTRUCTOR_ID = 0x276d3ec6
    SUBCLASS_OF_ID = 0x5f32d5ee

    def __init__(self, msg_id, answer_msg_id, bytes, status):
        """
        :param int msg_id:
        :param int answer_msg_id:
        :param int bytes:
        :param int status:

        Constructor for MsgDetailedInfo: Instance of either MsgDetailedInfo, MsgNewDetailedInfo.
        """
        self.msg_id = msg_id  # type: int
        self.answer_msg_id = answer_msg_id  # type: int
        self.bytes = bytes  # type: int
        self.status = status  # type: int

    def to_dict(self):
        return {
            '_': 'MsgDetailedInfo',
            'msg_id': self.msg_id,
            'answer_msg_id': self.answer_msg_id,
            'bytes': self.bytes,
            'status': self.status
        }

    def __bytes__(self):
        return b''.join((
            b"\xc6>m'",
            struct.pack('<q', self.msg_id),
            struct.pack('<q', self.answer_msg_id),
            struct.pack('<i', self.bytes),
            struct.pack('<i', self.status),
        ))

    @classmethod
    def from_reader(cls, reader):
        _msg_id = reader.read_long()
        _answer_msg_id = reader.read_long()
        _bytes = reader.read_int()
        _status = reader.read_int()
        return cls(msg_id=_msg_id, answer_msg_id=_answer_msg_id, bytes=_bytes, status=_status)


class MsgNewDetailedInfo(TLObject):
    CONSTRUCTOR_ID = 0x809db6df
    SUBCLASS_OF_ID = 0x5f32d5ee

    def __init__(self, answer_msg_id, bytes, status):
        """
        :param int answer_msg_id:
        :param int bytes:
        :param int status:

        Constructor for MsgDetailedInfo: Instance of either MsgDetailedInfo, MsgNewDetailedInfo.
        """
        self.answer_msg_id = answer_msg_id  # type: int
        self.bytes = bytes  # type: int
        self.status = status  # type: int

    def to_dict(self):
        return {
            '_': 'MsgNewDetailedInfo',
            'answer_msg_id': self.answer_msg_id,
            'bytes': self.bytes,
            'status': self.status
        }

    def __bytes__(self):
        return b''.join((
            b'\xdf\xb6\x9d\x80',
            struct.pack('<q', self.answer_msg_id),
            struct.pack('<i', self.bytes),
            struct.pack('<i', self.status),
        ))

    @classmethod
    def from_reader(cls, reader):
        _answer_msg_id = reader.read_long()
        _bytes = reader.read_int()
        _status = reader.read_int()
        return cls(answer_msg_id=_answer_msg_id, bytes=_bytes, status=_status)


class MsgResendReq(TLObject):
    CONSTRUCTOR_ID = 0x7d861a08
    SUBCLASS_OF_ID = 0x2024514

    def __init__(self, msg_ids):
        """
        :param List[int] msg_ids:

        Constructor for MsgResendReq: Instance of MsgResendReq.
        """
        self.msg_ids = msg_ids  # type: List[int]

    def to_dict(self):
        return {
            '_': 'MsgResendReq',
            'msg_ids': [] if self.msg_ids is None else self.msg_ids[:]
        }

    def __bytes__(self):
        return b''.join((
            b'\x08\x1a\x86}',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.msg_ids)),b''.join(struct.pack('<q', x) for x in self.msg_ids),
        ))

    @classmethod
    def from_reader(cls, reader):
        reader.read_int()
        _msg_ids = []
        for _ in range(reader.read_int()):
            _x = reader.read_long()
            _msg_ids.append(_x)

        return cls(msg_ids=_msg_ids)


class MsgsAck(TLObject):
    CONSTRUCTOR_ID = 0x62d6b459
    SUBCLASS_OF_ID = 0x827677c4

    def __init__(self, msg_ids):
        """
        :param List[int] msg_ids:

        Constructor for MsgsAck: Instance of MsgsAck.
        """
        self.msg_ids = msg_ids  # type: List[int]

    def to_dict(self):
        return {
            '_': 'MsgsAck',
            'msg_ids': [] if self.msg_ids is None else self.msg_ids[:]
        }

    def __bytes__(self):
        return b''.join((
            b'Y\xb4\xd6b',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.msg_ids)),b''.join(struct.pack('<q', x) for x in self.msg_ids),
        ))

    @classmethod
    def from_reader(cls, reader):
        reader.read_int()
        _msg_ids = []
        for _ in range(reader.read_int()):
            _x = reader.read_long()
            _msg_ids.append(_x)

        return cls(msg_ids=_msg_ids)


class MsgsAllInfo(TLObject):
    CONSTRUCTOR_ID = 0x8cc0d131
    SUBCLASS_OF_ID = 0xfa8fcb54

    def __init__(self, msg_ids, info):
        """
        :param List[int] msg_ids:
        :param str info:

        Constructor for MsgsAllInfo: Instance of MsgsAllInfo.
        """
        self.msg_ids = msg_ids  # type: List[int]
        self.info = info  # type: str

    def to_dict(self):
        return {
            '_': 'MsgsAllInfo',
            'msg_ids': [] if self.msg_ids is None else self.msg_ids[:],
            'info': self.info
        }

    def __bytes__(self):
        return b''.join((
            b'1\xd1\xc0\x8c',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.msg_ids)),b''.join(struct.pack('<q', x) for x in self.msg_ids),
            self.serialize_bytes(self.info),
        ))

    @classmethod
    def from_reader(cls, reader):
        reader.read_int()
        _msg_ids = []
        for _ in range(reader.read_int()):
            _x = reader.read_long()
            _msg_ids.append(_x)

        _info = reader.tgread_string()
        return cls(msg_ids=_msg_ids, info=_info)


class MsgsStateInfo(TLObject):
    CONSTRUCTOR_ID = 0x4deb57d
    SUBCLASS_OF_ID = 0x70a0a64

    def __init__(self, req_msg_id, info):
        """
        :param int req_msg_id:
        :param str info:

        Constructor for MsgsStateInfo: Instance of MsgsStateInfo.
        """
        self.req_msg_id = req_msg_id  # type: int
        self.info = info  # type: str

    def to_dict(self):
        return {
            '_': 'MsgsStateInfo',
            'req_msg_id': self.req_msg_id,
            'info': self.info
        }

    def __bytes__(self):
        return b''.join((
            b'}\xb5\xde\x04',
            struct.pack('<q', self.req_msg_id),
            self.serialize_bytes(self.info),
        ))

    @classmethod
    def from_reader(cls, reader):
        _req_msg_id = reader.read_long()
        _info = reader.tgread_string()
        return cls(req_msg_id=_req_msg_id, info=_info)


class MsgsStateReq(TLObject):
    CONSTRUCTOR_ID = 0xda69fb52
    SUBCLASS_OF_ID = 0x18f01dd0

    def __init__(self, msg_ids):
        """
        :param List[int] msg_ids:

        Constructor for MsgsStateReq: Instance of MsgsStateReq.
        """
        self.msg_ids = msg_ids  # type: List[int]

    def to_dict(self):
        return {
            '_': 'MsgsStateReq',
            'msg_ids': [] if self.msg_ids is None else self.msg_ids[:]
        }

    def __bytes__(self):
        return b''.join((
            b'R\xfbi\xda',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.msg_ids)),b''.join(struct.pack('<q', x) for x in self.msg_ids),
        ))

    @classmethod
    def from_reader(cls, reader):
        reader.read_int()
        _msg_ids = []
        for _ in range(reader.read_int()):
            _x = reader.read_long()
            _msg_ids.append(_x)

        return cls(msg_ids=_msg_ids)


class NearestDc(TLObject):
    CONSTRUCTOR_ID = 0x8e1a1775
    SUBCLASS_OF_ID = 0x3877045f

    def __init__(self, country, this_dc, nearest_dc):
        """
        :param str country:
        :param int this_dc:
        :param int nearest_dc:

        Constructor for NearestDc: Instance of NearestDc.
        """
        self.country = country  # type: str
        self.this_dc = this_dc  # type: int
        self.nearest_dc = nearest_dc  # type: int

    def to_dict(self):
        return {
            '_': 'NearestDc',
            'country': self.country,
            'this_dc': self.this_dc,
            'nearest_dc': self.nearest_dc
        }

    def __bytes__(self):
        return b''.join((
            b'u\x17\x1a\x8e',
            self.serialize_bytes(self.country),
            struct.pack('<i', self.this_dc),
            struct.pack('<i', self.nearest_dc),
        ))

    @classmethod
    def from_reader(cls, reader):
        _country = reader.tgread_string()
        _this_dc = reader.read_int()
        _nearest_dc = reader.read_int()
        return cls(country=_country, this_dc=_this_dc, nearest_dc=_nearest_dc)


class NewSessionCreated(TLObject):
    CONSTRUCTOR_ID = 0x9ec20908
    SUBCLASS_OF_ID = 0x510d3031

    def __init__(self, first_msg_id, unique_id, server_salt):
        """
        :param int first_msg_id:
        :param int unique_id:
        :param int server_salt:

        Constructor for NewSession: Instance of NewSessionCreated.
        """
        self.first_msg_id = first_msg_id  # type: int
        self.unique_id = unique_id  # type: int
        self.server_salt = server_salt  # type: int

    def to_dict(self):
        return {
            '_': 'NewSessionCreated',
            'first_msg_id': self.first_msg_id,
            'unique_id': self.unique_id,
            'server_salt': self.server_salt
        }

    def __bytes__(self):
        return b''.join((
            b'\x08\t\xc2\x9e',
            struct.pack('<q', self.first_msg_id),
            struct.pack('<q', self.unique_id),
            struct.pack('<q', self.server_salt),
        ))

    @classmethod
    def from_reader(cls, reader):
        _first_msg_id = reader.read_long()
        _unique_id = reader.read_long()
        _server_salt = reader.read_long()
        return cls(first_msg_id=_first_msg_id, unique_id=_unique_id, server_salt=_server_salt)


class NotifyChats(TLObject):
    CONSTRUCTOR_ID = 0xc007cec3
    SUBCLASS_OF_ID = 0xdfe8602e

    def to_dict(self):
        return {
            '_': 'NotifyChats'
        }

    def __bytes__(self):
        return b''.join((
            b'\xc3\xce\x07\xc0',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class NotifyPeer(TLObject):
    CONSTRUCTOR_ID = 0x9fd40bd8
    SUBCLASS_OF_ID = 0xdfe8602e

    def __init__(self, peer):
        """
        :param TypePeer peer:

        Constructor for NotifyPeer: Instance of either NotifyPeer, NotifyUsers, NotifyChats.
        """
        self.peer = peer  # type: TypePeer

    def to_dict(self):
        return {
            '_': 'NotifyPeer',
            'peer': None if self.peer is None else self.peer.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\xd8\x0b\xd4\x9f',
            bytes(self.peer),
        ))

    @classmethod
    def from_reader(cls, reader):
        _peer = reader.tgread_object()
        return cls(peer=_peer)


class NotifyUsers(TLObject):
    CONSTRUCTOR_ID = 0xb4c83b4c
    SUBCLASS_OF_ID = 0xdfe8602e

    def to_dict(self):
        return {
            '_': 'NotifyUsers'
        }

    def __bytes__(self):
        return b''.join((
            b'L;\xc8\xb4',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class PQInnerData(TLObject):
    CONSTRUCTOR_ID = 0x83c95aec
    SUBCLASS_OF_ID = 0x41701377

    def __init__(self, pq, p, q, nonce, server_nonce, new_nonce):
        """
        :param bytes pq:
        :param bytes p:
        :param bytes q:
        :param int nonce:
        :param int server_nonce:
        :param int new_nonce:

        Constructor for P_Q_inner_data: Instance of either PQInnerData, PQInnerDataTemp.
        """
        self.pq = pq  # type: bytes
        self.p = p  # type: bytes
        self.q = q  # type: bytes
        self.nonce = nonce  # type: int
        self.server_nonce = server_nonce  # type: int
        self.new_nonce = new_nonce  # type: int

    def to_dict(self):
        return {
            '_': 'PQInnerData',
            'pq': self.pq,
            'p': self.p,
            'q': self.q,
            'nonce': self.nonce,
            'server_nonce': self.server_nonce,
            'new_nonce': self.new_nonce
        }

    def __bytes__(self):
        return b''.join((
            b'\xecZ\xc9\x83',
            self.serialize_bytes(self.pq),
            self.serialize_bytes(self.p),
            self.serialize_bytes(self.q),
            self.nonce.to_bytes(16, 'little', signed=True),
            self.server_nonce.to_bytes(16, 'little', signed=True),
            self.new_nonce.to_bytes(32, 'little', signed=True),
        ))

    @classmethod
    def from_reader(cls, reader):
        _pq = reader.tgread_bytes()
        _p = reader.tgread_bytes()
        _q = reader.tgread_bytes()
        _nonce = reader.read_large_int(bits=128)
        _server_nonce = reader.read_large_int(bits=128)
        _new_nonce = reader.read_large_int(bits=256)
        return cls(pq=_pq, p=_p, q=_q, nonce=_nonce, server_nonce=_server_nonce, new_nonce=_new_nonce)


class PQInnerDataTemp(TLObject):
    CONSTRUCTOR_ID = 0x3c6a84d4
    SUBCLASS_OF_ID = 0x41701377

    def __init__(self, pq, p, q, nonce, server_nonce, new_nonce, expires_in):
        """
        :param bytes pq:
        :param bytes p:
        :param bytes q:
        :param int nonce:
        :param int server_nonce:
        :param int new_nonce:
        :param int expires_in:

        Constructor for P_Q_inner_data: Instance of either PQInnerData, PQInnerDataTemp.
        """
        self.pq = pq  # type: bytes
        self.p = p  # type: bytes
        self.q = q  # type: bytes
        self.nonce = nonce  # type: int
        self.server_nonce = server_nonce  # type: int
        self.new_nonce = new_nonce  # type: int
        self.expires_in = expires_in  # type: int

    def to_dict(self):
        return {
            '_': 'PQInnerDataTemp',
            'pq': self.pq,
            'p': self.p,
            'q': self.q,
            'nonce': self.nonce,
            'server_nonce': self.server_nonce,
            'new_nonce': self.new_nonce,
            'expires_in': self.expires_in
        }

    def __bytes__(self):
        return b''.join((
            b'\xd4\x84j<',
            self.serialize_bytes(self.pq),
            self.serialize_bytes(self.p),
            self.serialize_bytes(self.q),
            self.nonce.to_bytes(16, 'little', signed=True),
            self.server_nonce.to_bytes(16, 'little', signed=True),
            self.new_nonce.to_bytes(32, 'little', signed=True),
            struct.pack('<i', self.expires_in),
        ))

    @classmethod
    def from_reader(cls, reader):
        _pq = reader.tgread_bytes()
        _p = reader.tgread_bytes()
        _q = reader.tgread_bytes()
        _nonce = reader.read_large_int(bits=128)
        _server_nonce = reader.read_large_int(bits=128)
        _new_nonce = reader.read_large_int(bits=256)
        _expires_in = reader.read_int()
        return cls(pq=_pq, p=_p, q=_q, nonce=_nonce, server_nonce=_server_nonce, new_nonce=_new_nonce, expires_in=_expires_in)


class PageBlockAnchor(TLObject):
    CONSTRUCTOR_ID = 0xce0d37b0
    SUBCLASS_OF_ID = 0x1aca5644

    def __init__(self, name):
        """
        :param str name:

        Constructor for PageBlock: Instance of either PageBlockUnsupported, PageBlockTitle, PageBlockSubtitle, PageBlockAuthorDate, PageBlockHeader, PageBlockSubheader, PageBlockParagraph, PageBlockPreformatted, PageBlockFooter, PageBlockDivider, PageBlockAnchor, PageBlockList, PageBlockBlockquote, PageBlockPullquote, PageBlockPhoto, PageBlockVideo, PageBlockCover, PageBlockEmbed, PageBlockEmbedPost, PageBlockCollage, PageBlockSlideshow, PageBlockChannel, PageBlockAudio.
        """
        self.name = name  # type: str

    def to_dict(self):
        return {
            '_': 'PageBlockAnchor',
            'name': self.name
        }

    def __bytes__(self):
        return b''.join((
            b'\xb07\r\xce',
            self.serialize_bytes(self.name),
        ))

    @classmethod
    def from_reader(cls, reader):
        _name = reader.tgread_string()
        return cls(name=_name)


class PageBlockAudio(TLObject):
    CONSTRUCTOR_ID = 0x31b81a7f
    SUBCLASS_OF_ID = 0x1aca5644

    def __init__(self, audio_id, caption):
        """
        :param int audio_id:
        :param TypeRichText caption:

        Constructor for PageBlock: Instance of either PageBlockUnsupported, PageBlockTitle, PageBlockSubtitle, PageBlockAuthorDate, PageBlockHeader, PageBlockSubheader, PageBlockParagraph, PageBlockPreformatted, PageBlockFooter, PageBlockDivider, PageBlockAnchor, PageBlockList, PageBlockBlockquote, PageBlockPullquote, PageBlockPhoto, PageBlockVideo, PageBlockCover, PageBlockEmbed, PageBlockEmbedPost, PageBlockCollage, PageBlockSlideshow, PageBlockChannel, PageBlockAudio.
        """
        self.audio_id = audio_id  # type: int
        self.caption = caption  # type: TypeRichText

    def to_dict(self):
        return {
            '_': 'PageBlockAudio',
            'audio_id': self.audio_id,
            'caption': None if self.caption is None else self.caption.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\x7f\x1a\xb81',
            struct.pack('<q', self.audio_id),
            bytes(self.caption),
        ))

    @classmethod
    def from_reader(cls, reader):
        _audio_id = reader.read_long()
        _caption = reader.tgread_object()
        return cls(audio_id=_audio_id, caption=_caption)


class PageBlockAuthorDate(TLObject):
    CONSTRUCTOR_ID = 0xbaafe5e0
    SUBCLASS_OF_ID = 0x1aca5644

    def __init__(self, author, published_date):
        """
        :param TypeRichText author:
        :param Optional[datetime] published_date:

        Constructor for PageBlock: Instance of either PageBlockUnsupported, PageBlockTitle, PageBlockSubtitle, PageBlockAuthorDate, PageBlockHeader, PageBlockSubheader, PageBlockParagraph, PageBlockPreformatted, PageBlockFooter, PageBlockDivider, PageBlockAnchor, PageBlockList, PageBlockBlockquote, PageBlockPullquote, PageBlockPhoto, PageBlockVideo, PageBlockCover, PageBlockEmbed, PageBlockEmbedPost, PageBlockCollage, PageBlockSlideshow, PageBlockChannel, PageBlockAudio.
        """
        self.author = author  # type: TypeRichText
        self.published_date = published_date  # type: Optional[datetime]

    def to_dict(self):
        return {
            '_': 'PageBlockAuthorDate',
            'author': None if self.author is None else self.author.to_dict(),
            'published_date': self.published_date
        }

    def __bytes__(self):
        return b''.join((
            b'\xe0\xe5\xaf\xba',
            bytes(self.author),
            self.serialize_datetime(self.published_date),
        ))

    @classmethod
    def from_reader(cls, reader):
        _author = reader.tgread_object()
        _published_date = reader.tgread_date()
        return cls(author=_author, published_date=_published_date)


class PageBlockBlockquote(TLObject):
    CONSTRUCTOR_ID = 0x263d7c26
    SUBCLASS_OF_ID = 0x1aca5644

    def __init__(self, text, caption):
        """
        :param TypeRichText text:
        :param TypeRichText caption:

        Constructor for PageBlock: Instance of either PageBlockUnsupported, PageBlockTitle, PageBlockSubtitle, PageBlockAuthorDate, PageBlockHeader, PageBlockSubheader, PageBlockParagraph, PageBlockPreformatted, PageBlockFooter, PageBlockDivider, PageBlockAnchor, PageBlockList, PageBlockBlockquote, PageBlockPullquote, PageBlockPhoto, PageBlockVideo, PageBlockCover, PageBlockEmbed, PageBlockEmbedPost, PageBlockCollage, PageBlockSlideshow, PageBlockChannel, PageBlockAudio.
        """
        self.text = text  # type: TypeRichText
        self.caption = caption  # type: TypeRichText

    def to_dict(self):
        return {
            '_': 'PageBlockBlockquote',
            'text': None if self.text is None else self.text.to_dict(),
            'caption': None if self.caption is None else self.caption.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'&|=&',
            bytes(self.text),
            bytes(self.caption),
        ))

    @classmethod
    def from_reader(cls, reader):
        _text = reader.tgread_object()
        _caption = reader.tgread_object()
        return cls(text=_text, caption=_caption)


class PageBlockChannel(TLObject):
    CONSTRUCTOR_ID = 0xef1751b5
    SUBCLASS_OF_ID = 0x1aca5644

    def __init__(self, channel):
        """
        :param TypeChat channel:

        Constructor for PageBlock: Instance of either PageBlockUnsupported, PageBlockTitle, PageBlockSubtitle, PageBlockAuthorDate, PageBlockHeader, PageBlockSubheader, PageBlockParagraph, PageBlockPreformatted, PageBlockFooter, PageBlockDivider, PageBlockAnchor, PageBlockList, PageBlockBlockquote, PageBlockPullquote, PageBlockPhoto, PageBlockVideo, PageBlockCover, PageBlockEmbed, PageBlockEmbedPost, PageBlockCollage, PageBlockSlideshow, PageBlockChannel, PageBlockAudio.
        """
        self.channel = channel  # type: TypeChat

    def to_dict(self):
        return {
            '_': 'PageBlockChannel',
            'channel': None if self.channel is None else self.channel.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\xb5Q\x17\xef',
            bytes(self.channel),
        ))

    @classmethod
    def from_reader(cls, reader):
        _channel = reader.tgread_object()
        return cls(channel=_channel)


class PageBlockCollage(TLObject):
    CONSTRUCTOR_ID = 0x8b31c4f
    SUBCLASS_OF_ID = 0x1aca5644

    def __init__(self, items, caption):
        """
        :param List[TypePageBlock] items:
        :param TypeRichText caption:

        Constructor for PageBlock: Instance of either PageBlockUnsupported, PageBlockTitle, PageBlockSubtitle, PageBlockAuthorDate, PageBlockHeader, PageBlockSubheader, PageBlockParagraph, PageBlockPreformatted, PageBlockFooter, PageBlockDivider, PageBlockAnchor, PageBlockList, PageBlockBlockquote, PageBlockPullquote, PageBlockPhoto, PageBlockVideo, PageBlockCover, PageBlockEmbed, PageBlockEmbedPost, PageBlockCollage, PageBlockSlideshow, PageBlockChannel, PageBlockAudio.
        """
        self.items = items  # type: List[TypePageBlock]
        self.caption = caption  # type: TypeRichText

    def to_dict(self):
        return {
            '_': 'PageBlockCollage',
            'items': [] if self.items is None else [None if x is None else x.to_dict() for x in self.items],
            'caption': None if self.caption is None else self.caption.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'O\x1c\xb3\x08',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.items)),b''.join(bytes(x) for x in self.items),
            bytes(self.caption),
        ))

    @classmethod
    def from_reader(cls, reader):
        reader.read_int()
        _items = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _items.append(_x)

        _caption = reader.tgread_object()
        return cls(items=_items, caption=_caption)


class PageBlockCover(TLObject):
    CONSTRUCTOR_ID = 0x39f23300
    SUBCLASS_OF_ID = 0x1aca5644

    def __init__(self, cover):
        """
        :param TypePageBlock cover:

        Constructor for PageBlock: Instance of either PageBlockUnsupported, PageBlockTitle, PageBlockSubtitle, PageBlockAuthorDate, PageBlockHeader, PageBlockSubheader, PageBlockParagraph, PageBlockPreformatted, PageBlockFooter, PageBlockDivider, PageBlockAnchor, PageBlockList, PageBlockBlockquote, PageBlockPullquote, PageBlockPhoto, PageBlockVideo, PageBlockCover, PageBlockEmbed, PageBlockEmbedPost, PageBlockCollage, PageBlockSlideshow, PageBlockChannel, PageBlockAudio.
        """
        self.cover = cover  # type: TypePageBlock

    def to_dict(self):
        return {
            '_': 'PageBlockCover',
            'cover': None if self.cover is None else self.cover.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\x003\xf29',
            bytes(self.cover),
        ))

    @classmethod
    def from_reader(cls, reader):
        _cover = reader.tgread_object()
        return cls(cover=_cover)


class PageBlockDivider(TLObject):
    CONSTRUCTOR_ID = 0xdb20b188
    SUBCLASS_OF_ID = 0x1aca5644

    def to_dict(self):
        return {
            '_': 'PageBlockDivider'
        }

    def __bytes__(self):
        return b''.join((
            b'\x88\xb1 \xdb',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class PageBlockEmbed(TLObject):
    CONSTRUCTOR_ID = 0xcde200d1
    SUBCLASS_OF_ID = 0x1aca5644

    def __init__(self, w, h, caption, full_width=None, allow_scrolling=None, url=None, html=None, poster_photo_id=None):
        """
        :param int w:
        :param int h:
        :param TypeRichText caption:
        :param Optional[bool] full_width:
        :param Optional[bool] allow_scrolling:
        :param Optional[str] url:
        :param Optional[str] html:
        :param Optional[int] poster_photo_id:

        Constructor for PageBlock: Instance of either PageBlockUnsupported, PageBlockTitle, PageBlockSubtitle, PageBlockAuthorDate, PageBlockHeader, PageBlockSubheader, PageBlockParagraph, PageBlockPreformatted, PageBlockFooter, PageBlockDivider, PageBlockAnchor, PageBlockList, PageBlockBlockquote, PageBlockPullquote, PageBlockPhoto, PageBlockVideo, PageBlockCover, PageBlockEmbed, PageBlockEmbedPost, PageBlockCollage, PageBlockSlideshow, PageBlockChannel, PageBlockAudio.
        """
        self.w = w  # type: int
        self.h = h  # type: int
        self.caption = caption  # type: TypeRichText
        self.full_width = full_width  # type: Optional[bool]
        self.allow_scrolling = allow_scrolling  # type: Optional[bool]
        self.url = url  # type: Optional[str]
        self.html = html  # type: Optional[str]
        self.poster_photo_id = poster_photo_id  # type: Optional[int]

    def to_dict(self):
        return {
            '_': 'PageBlockEmbed',
            'w': self.w,
            'h': self.h,
            'caption': None if self.caption is None else self.caption.to_dict(),
            'full_width': self.full_width,
            'allow_scrolling': self.allow_scrolling,
            'url': self.url,
            'html': self.html,
            'poster_photo_id': self.poster_photo_id
        }

    def __bytes__(self):
        return b''.join((
            b'\xd1\x00\xe2\xcd',
            struct.pack('<I', (0 if self.full_width is None or self.full_width is False else 1) | (0 if self.allow_scrolling is None or self.allow_scrolling is False else 8) | (0 if self.url is None or self.url is False else 2) | (0 if self.html is None or self.html is False else 4) | (0 if self.poster_photo_id is None or self.poster_photo_id is False else 16)),
            b'' if self.url is None or self.url is False else (self.serialize_bytes(self.url)),
            b'' if self.html is None or self.html is False else (self.serialize_bytes(self.html)),
            b'' if self.poster_photo_id is None or self.poster_photo_id is False else (struct.pack('<q', self.poster_photo_id)),
            struct.pack('<i', self.w),
            struct.pack('<i', self.h),
            bytes(self.caption),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _full_width = bool(flags & 1)
        _allow_scrolling = bool(flags & 8)
        if flags & 2:
            _url = reader.tgread_string()
        else:
            _url = None
        if flags & 4:
            _html = reader.tgread_string()
        else:
            _html = None
        if flags & 16:
            _poster_photo_id = reader.read_long()
        else:
            _poster_photo_id = None
        _w = reader.read_int()
        _h = reader.read_int()
        _caption = reader.tgread_object()
        return cls(w=_w, h=_h, caption=_caption, full_width=_full_width, allow_scrolling=_allow_scrolling, url=_url, html=_html, poster_photo_id=_poster_photo_id)


class PageBlockEmbedPost(TLObject):
    CONSTRUCTOR_ID = 0x292c7be9
    SUBCLASS_OF_ID = 0x1aca5644

    def __init__(self, url, webpage_id, author_photo_id, author, date, blocks, caption):
        """
        :param str url:
        :param int webpage_id:
        :param int author_photo_id:
        :param str author:
        :param Optional[datetime] date:
        :param List[TypePageBlock] blocks:
        :param TypeRichText caption:

        Constructor for PageBlock: Instance of either PageBlockUnsupported, PageBlockTitle, PageBlockSubtitle, PageBlockAuthorDate, PageBlockHeader, PageBlockSubheader, PageBlockParagraph, PageBlockPreformatted, PageBlockFooter, PageBlockDivider, PageBlockAnchor, PageBlockList, PageBlockBlockquote, PageBlockPullquote, PageBlockPhoto, PageBlockVideo, PageBlockCover, PageBlockEmbed, PageBlockEmbedPost, PageBlockCollage, PageBlockSlideshow, PageBlockChannel, PageBlockAudio.
        """
        self.url = url  # type: str
        self.webpage_id = webpage_id  # type: int
        self.author_photo_id = author_photo_id  # type: int
        self.author = author  # type: str
        self.date = date  # type: Optional[datetime]
        self.blocks = blocks  # type: List[TypePageBlock]
        self.caption = caption  # type: TypeRichText

    def to_dict(self):
        return {
            '_': 'PageBlockEmbedPost',
            'url': self.url,
            'webpage_id': self.webpage_id,
            'author_photo_id': self.author_photo_id,
            'author': self.author,
            'date': self.date,
            'blocks': [] if self.blocks is None else [None if x is None else x.to_dict() for x in self.blocks],
            'caption': None if self.caption is None else self.caption.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\xe9{,)',
            self.serialize_bytes(self.url),
            struct.pack('<q', self.webpage_id),
            struct.pack('<q', self.author_photo_id),
            self.serialize_bytes(self.author),
            self.serialize_datetime(self.date),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.blocks)),b''.join(bytes(x) for x in self.blocks),
            bytes(self.caption),
        ))

    @classmethod
    def from_reader(cls, reader):
        _url = reader.tgread_string()
        _webpage_id = reader.read_long()
        _author_photo_id = reader.read_long()
        _author = reader.tgread_string()
        _date = reader.tgread_date()
        reader.read_int()
        _blocks = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _blocks.append(_x)

        _caption = reader.tgread_object()
        return cls(url=_url, webpage_id=_webpage_id, author_photo_id=_author_photo_id, author=_author, date=_date, blocks=_blocks, caption=_caption)


class PageBlockFooter(TLObject):
    CONSTRUCTOR_ID = 0x48870999
    SUBCLASS_OF_ID = 0x1aca5644

    def __init__(self, text):
        """
        :param TypeRichText text:

        Constructor for PageBlock: Instance of either PageBlockUnsupported, PageBlockTitle, PageBlockSubtitle, PageBlockAuthorDate, PageBlockHeader, PageBlockSubheader, PageBlockParagraph, PageBlockPreformatted, PageBlockFooter, PageBlockDivider, PageBlockAnchor, PageBlockList, PageBlockBlockquote, PageBlockPullquote, PageBlockPhoto, PageBlockVideo, PageBlockCover, PageBlockEmbed, PageBlockEmbedPost, PageBlockCollage, PageBlockSlideshow, PageBlockChannel, PageBlockAudio.
        """
        self.text = text  # type: TypeRichText

    def to_dict(self):
        return {
            '_': 'PageBlockFooter',
            'text': None if self.text is None else self.text.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\x99\t\x87H',
            bytes(self.text),
        ))

    @classmethod
    def from_reader(cls, reader):
        _text = reader.tgread_object()
        return cls(text=_text)


class PageBlockHeader(TLObject):
    CONSTRUCTOR_ID = 0xbfd064ec
    SUBCLASS_OF_ID = 0x1aca5644

    def __init__(self, text):
        """
        :param TypeRichText text:

        Constructor for PageBlock: Instance of either PageBlockUnsupported, PageBlockTitle, PageBlockSubtitle, PageBlockAuthorDate, PageBlockHeader, PageBlockSubheader, PageBlockParagraph, PageBlockPreformatted, PageBlockFooter, PageBlockDivider, PageBlockAnchor, PageBlockList, PageBlockBlockquote, PageBlockPullquote, PageBlockPhoto, PageBlockVideo, PageBlockCover, PageBlockEmbed, PageBlockEmbedPost, PageBlockCollage, PageBlockSlideshow, PageBlockChannel, PageBlockAudio.
        """
        self.text = text  # type: TypeRichText

    def to_dict(self):
        return {
            '_': 'PageBlockHeader',
            'text': None if self.text is None else self.text.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\xecd\xd0\xbf',
            bytes(self.text),
        ))

    @classmethod
    def from_reader(cls, reader):
        _text = reader.tgread_object()
        return cls(text=_text)


class PageBlockList(TLObject):
    CONSTRUCTOR_ID = 0x3a58c7f4
    SUBCLASS_OF_ID = 0x1aca5644

    def __init__(self, ordered, items):
        """
        :param TypeBool ordered:
        :param List[TypeRichText] items:

        Constructor for PageBlock: Instance of either PageBlockUnsupported, PageBlockTitle, PageBlockSubtitle, PageBlockAuthorDate, PageBlockHeader, PageBlockSubheader, PageBlockParagraph, PageBlockPreformatted, PageBlockFooter, PageBlockDivider, PageBlockAnchor, PageBlockList, PageBlockBlockquote, PageBlockPullquote, PageBlockPhoto, PageBlockVideo, PageBlockCover, PageBlockEmbed, PageBlockEmbedPost, PageBlockCollage, PageBlockSlideshow, PageBlockChannel, PageBlockAudio.
        """
        self.ordered = ordered  # type: TypeBool
        self.items = items  # type: List[TypeRichText]

    def to_dict(self):
        return {
            '_': 'PageBlockList',
            'ordered': self.ordered,
            'items': [] if self.items is None else [None if x is None else x.to_dict() for x in self.items]
        }

    def __bytes__(self):
        return b''.join((
            b'\xf4\xc7X:',
            b'\xb5ur\x99' if self.ordered else b'7\x97y\xbc',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.items)),b''.join(bytes(x) for x in self.items),
        ))

    @classmethod
    def from_reader(cls, reader):
        _ordered = reader.tgread_bool()
        reader.read_int()
        _items = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _items.append(_x)

        return cls(ordered=_ordered, items=_items)


class PageBlockParagraph(TLObject):
    CONSTRUCTOR_ID = 0x467a0766
    SUBCLASS_OF_ID = 0x1aca5644

    def __init__(self, text):
        """
        :param TypeRichText text:

        Constructor for PageBlock: Instance of either PageBlockUnsupported, PageBlockTitle, PageBlockSubtitle, PageBlockAuthorDate, PageBlockHeader, PageBlockSubheader, PageBlockParagraph, PageBlockPreformatted, PageBlockFooter, PageBlockDivider, PageBlockAnchor, PageBlockList, PageBlockBlockquote, PageBlockPullquote, PageBlockPhoto, PageBlockVideo, PageBlockCover, PageBlockEmbed, PageBlockEmbedPost, PageBlockCollage, PageBlockSlideshow, PageBlockChannel, PageBlockAudio.
        """
        self.text = text  # type: TypeRichText

    def to_dict(self):
        return {
            '_': 'PageBlockParagraph',
            'text': None if self.text is None else self.text.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'f\x07zF',
            bytes(self.text),
        ))

    @classmethod
    def from_reader(cls, reader):
        _text = reader.tgread_object()
        return cls(text=_text)


class PageBlockPhoto(TLObject):
    CONSTRUCTOR_ID = 0xe9c69982
    SUBCLASS_OF_ID = 0x1aca5644

    def __init__(self, photo_id, caption):
        """
        :param int photo_id:
        :param TypeRichText caption:

        Constructor for PageBlock: Instance of either PageBlockUnsupported, PageBlockTitle, PageBlockSubtitle, PageBlockAuthorDate, PageBlockHeader, PageBlockSubheader, PageBlockParagraph, PageBlockPreformatted, PageBlockFooter, PageBlockDivider, PageBlockAnchor, PageBlockList, PageBlockBlockquote, PageBlockPullquote, PageBlockPhoto, PageBlockVideo, PageBlockCover, PageBlockEmbed, PageBlockEmbedPost, PageBlockCollage, PageBlockSlideshow, PageBlockChannel, PageBlockAudio.
        """
        self.photo_id = photo_id  # type: int
        self.caption = caption  # type: TypeRichText

    def to_dict(self):
        return {
            '_': 'PageBlockPhoto',
            'photo_id': self.photo_id,
            'caption': None if self.caption is None else self.caption.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\x82\x99\xc6\xe9',
            struct.pack('<q', self.photo_id),
            bytes(self.caption),
        ))

    @classmethod
    def from_reader(cls, reader):
        _photo_id = reader.read_long()
        _caption = reader.tgread_object()
        return cls(photo_id=_photo_id, caption=_caption)


class PageBlockPreformatted(TLObject):
    CONSTRUCTOR_ID = 0xc070d93e
    SUBCLASS_OF_ID = 0x1aca5644

    def __init__(self, text, language):
        """
        :param TypeRichText text:
        :param str language:

        Constructor for PageBlock: Instance of either PageBlockUnsupported, PageBlockTitle, PageBlockSubtitle, PageBlockAuthorDate, PageBlockHeader, PageBlockSubheader, PageBlockParagraph, PageBlockPreformatted, PageBlockFooter, PageBlockDivider, PageBlockAnchor, PageBlockList, PageBlockBlockquote, PageBlockPullquote, PageBlockPhoto, PageBlockVideo, PageBlockCover, PageBlockEmbed, PageBlockEmbedPost, PageBlockCollage, PageBlockSlideshow, PageBlockChannel, PageBlockAudio.
        """
        self.text = text  # type: TypeRichText
        self.language = language  # type: str

    def to_dict(self):
        return {
            '_': 'PageBlockPreformatted',
            'text': None if self.text is None else self.text.to_dict(),
            'language': self.language
        }

    def __bytes__(self):
        return b''.join((
            b'>\xd9p\xc0',
            bytes(self.text),
            self.serialize_bytes(self.language),
        ))

    @classmethod
    def from_reader(cls, reader):
        _text = reader.tgread_object()
        _language = reader.tgread_string()
        return cls(text=_text, language=_language)


class PageBlockPullquote(TLObject):
    CONSTRUCTOR_ID = 0x4f4456d3
    SUBCLASS_OF_ID = 0x1aca5644

    def __init__(self, text, caption):
        """
        :param TypeRichText text:
        :param TypeRichText caption:

        Constructor for PageBlock: Instance of either PageBlockUnsupported, PageBlockTitle, PageBlockSubtitle, PageBlockAuthorDate, PageBlockHeader, PageBlockSubheader, PageBlockParagraph, PageBlockPreformatted, PageBlockFooter, PageBlockDivider, PageBlockAnchor, PageBlockList, PageBlockBlockquote, PageBlockPullquote, PageBlockPhoto, PageBlockVideo, PageBlockCover, PageBlockEmbed, PageBlockEmbedPost, PageBlockCollage, PageBlockSlideshow, PageBlockChannel, PageBlockAudio.
        """
        self.text = text  # type: TypeRichText
        self.caption = caption  # type: TypeRichText

    def to_dict(self):
        return {
            '_': 'PageBlockPullquote',
            'text': None if self.text is None else self.text.to_dict(),
            'caption': None if self.caption is None else self.caption.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\xd3VDO',
            bytes(self.text),
            bytes(self.caption),
        ))

    @classmethod
    def from_reader(cls, reader):
        _text = reader.tgread_object()
        _caption = reader.tgread_object()
        return cls(text=_text, caption=_caption)


class PageBlockSlideshow(TLObject):
    CONSTRUCTOR_ID = 0x130c8963
    SUBCLASS_OF_ID = 0x1aca5644

    def __init__(self, items, caption):
        """
        :param List[TypePageBlock] items:
        :param TypeRichText caption:

        Constructor for PageBlock: Instance of either PageBlockUnsupported, PageBlockTitle, PageBlockSubtitle, PageBlockAuthorDate, PageBlockHeader, PageBlockSubheader, PageBlockParagraph, PageBlockPreformatted, PageBlockFooter, PageBlockDivider, PageBlockAnchor, PageBlockList, PageBlockBlockquote, PageBlockPullquote, PageBlockPhoto, PageBlockVideo, PageBlockCover, PageBlockEmbed, PageBlockEmbedPost, PageBlockCollage, PageBlockSlideshow, PageBlockChannel, PageBlockAudio.
        """
        self.items = items  # type: List[TypePageBlock]
        self.caption = caption  # type: TypeRichText

    def to_dict(self):
        return {
            '_': 'PageBlockSlideshow',
            'items': [] if self.items is None else [None if x is None else x.to_dict() for x in self.items],
            'caption': None if self.caption is None else self.caption.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'c\x89\x0c\x13',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.items)),b''.join(bytes(x) for x in self.items),
            bytes(self.caption),
        ))

    @classmethod
    def from_reader(cls, reader):
        reader.read_int()
        _items = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _items.append(_x)

        _caption = reader.tgread_object()
        return cls(items=_items, caption=_caption)


class PageBlockSubheader(TLObject):
    CONSTRUCTOR_ID = 0xf12bb6e1
    SUBCLASS_OF_ID = 0x1aca5644

    def __init__(self, text):
        """
        :param TypeRichText text:

        Constructor for PageBlock: Instance of either PageBlockUnsupported, PageBlockTitle, PageBlockSubtitle, PageBlockAuthorDate, PageBlockHeader, PageBlockSubheader, PageBlockParagraph, PageBlockPreformatted, PageBlockFooter, PageBlockDivider, PageBlockAnchor, PageBlockList, PageBlockBlockquote, PageBlockPullquote, PageBlockPhoto, PageBlockVideo, PageBlockCover, PageBlockEmbed, PageBlockEmbedPost, PageBlockCollage, PageBlockSlideshow, PageBlockChannel, PageBlockAudio.
        """
        self.text = text  # type: TypeRichText

    def to_dict(self):
        return {
            '_': 'PageBlockSubheader',
            'text': None if self.text is None else self.text.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\xe1\xb6+\xf1',
            bytes(self.text),
        ))

    @classmethod
    def from_reader(cls, reader):
        _text = reader.tgread_object()
        return cls(text=_text)


class PageBlockSubtitle(TLObject):
    CONSTRUCTOR_ID = 0x8ffa9a1f
    SUBCLASS_OF_ID = 0x1aca5644

    def __init__(self, text):
        """
        :param TypeRichText text:

        Constructor for PageBlock: Instance of either PageBlockUnsupported, PageBlockTitle, PageBlockSubtitle, PageBlockAuthorDate, PageBlockHeader, PageBlockSubheader, PageBlockParagraph, PageBlockPreformatted, PageBlockFooter, PageBlockDivider, PageBlockAnchor, PageBlockList, PageBlockBlockquote, PageBlockPullquote, PageBlockPhoto, PageBlockVideo, PageBlockCover, PageBlockEmbed, PageBlockEmbedPost, PageBlockCollage, PageBlockSlideshow, PageBlockChannel, PageBlockAudio.
        """
        self.text = text  # type: TypeRichText

    def to_dict(self):
        return {
            '_': 'PageBlockSubtitle',
            'text': None if self.text is None else self.text.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\x1f\x9a\xfa\x8f',
            bytes(self.text),
        ))

    @classmethod
    def from_reader(cls, reader):
        _text = reader.tgread_object()
        return cls(text=_text)


class PageBlockTitle(TLObject):
    CONSTRUCTOR_ID = 0x70abc3fd
    SUBCLASS_OF_ID = 0x1aca5644

    def __init__(self, text):
        """
        :param TypeRichText text:

        Constructor for PageBlock: Instance of either PageBlockUnsupported, PageBlockTitle, PageBlockSubtitle, PageBlockAuthorDate, PageBlockHeader, PageBlockSubheader, PageBlockParagraph, PageBlockPreformatted, PageBlockFooter, PageBlockDivider, PageBlockAnchor, PageBlockList, PageBlockBlockquote, PageBlockPullquote, PageBlockPhoto, PageBlockVideo, PageBlockCover, PageBlockEmbed, PageBlockEmbedPost, PageBlockCollage, PageBlockSlideshow, PageBlockChannel, PageBlockAudio.
        """
        self.text = text  # type: TypeRichText

    def to_dict(self):
        return {
            '_': 'PageBlockTitle',
            'text': None if self.text is None else self.text.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\xfd\xc3\xabp',
            bytes(self.text),
        ))

    @classmethod
    def from_reader(cls, reader):
        _text = reader.tgread_object()
        return cls(text=_text)


class PageBlockUnsupported(TLObject):
    CONSTRUCTOR_ID = 0x13567e8a
    SUBCLASS_OF_ID = 0x1aca5644

    def to_dict(self):
        return {
            '_': 'PageBlockUnsupported'
        }

    def __bytes__(self):
        return b''.join((
            b'\x8a~V\x13',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class PageBlockVideo(TLObject):
    CONSTRUCTOR_ID = 0xd9d71866
    SUBCLASS_OF_ID = 0x1aca5644

    def __init__(self, video_id, caption, autoplay=None, loop=None):
        """
        :param int video_id:
        :param TypeRichText caption:
        :param Optional[bool] autoplay:
        :param Optional[bool] loop:

        Constructor for PageBlock: Instance of either PageBlockUnsupported, PageBlockTitle, PageBlockSubtitle, PageBlockAuthorDate, PageBlockHeader, PageBlockSubheader, PageBlockParagraph, PageBlockPreformatted, PageBlockFooter, PageBlockDivider, PageBlockAnchor, PageBlockList, PageBlockBlockquote, PageBlockPullquote, PageBlockPhoto, PageBlockVideo, PageBlockCover, PageBlockEmbed, PageBlockEmbedPost, PageBlockCollage, PageBlockSlideshow, PageBlockChannel, PageBlockAudio.
        """
        self.video_id = video_id  # type: int
        self.caption = caption  # type: TypeRichText
        self.autoplay = autoplay  # type: Optional[bool]
        self.loop = loop  # type: Optional[bool]

    def to_dict(self):
        return {
            '_': 'PageBlockVideo',
            'video_id': self.video_id,
            'caption': None if self.caption is None else self.caption.to_dict(),
            'autoplay': self.autoplay,
            'loop': self.loop
        }

    def __bytes__(self):
        return b''.join((
            b'f\x18\xd7\xd9',
            struct.pack('<I', (0 if self.autoplay is None or self.autoplay is False else 1) | (0 if self.loop is None or self.loop is False else 2)),
            struct.pack('<q', self.video_id),
            bytes(self.caption),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _autoplay = bool(flags & 1)
        _loop = bool(flags & 2)
        _video_id = reader.read_long()
        _caption = reader.tgread_object()
        return cls(video_id=_video_id, caption=_caption, autoplay=_autoplay, loop=_loop)


class PageFull(TLObject):
    CONSTRUCTOR_ID = 0x556ec7aa
    SUBCLASS_OF_ID = 0xb438191e

    def __init__(self, blocks, photos, documents):
        """
        :param List[TypePageBlock] blocks:
        :param List[TypePhoto] photos:
        :param List[TypeDocument] documents:

        Constructor for Page: Instance of either PagePart, PageFull.
        """
        self.blocks = blocks  # type: List[TypePageBlock]
        self.photos = photos  # type: List[TypePhoto]
        self.documents = documents  # type: List[TypeDocument]

    def to_dict(self):
        return {
            '_': 'PageFull',
            'blocks': [] if self.blocks is None else [None if x is None else x.to_dict() for x in self.blocks],
            'photos': [] if self.photos is None else [None if x is None else x.to_dict() for x in self.photos],
            'documents': [] if self.documents is None else [None if x is None else x.to_dict() for x in self.documents]
        }

    def __bytes__(self):
        return b''.join((
            b'\xaa\xc7nU',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.blocks)),b''.join(bytes(x) for x in self.blocks),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.photos)),b''.join(bytes(x) for x in self.photos),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.documents)),b''.join(bytes(x) for x in self.documents),
        ))

    @classmethod
    def from_reader(cls, reader):
        reader.read_int()
        _blocks = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _blocks.append(_x)

        reader.read_int()
        _photos = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _photos.append(_x)

        reader.read_int()
        _documents = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _documents.append(_x)

        return cls(blocks=_blocks, photos=_photos, documents=_documents)


class PagePart(TLObject):
    CONSTRUCTOR_ID = 0x8e3f9ebe
    SUBCLASS_OF_ID = 0xb438191e

    def __init__(self, blocks, photos, documents):
        """
        :param List[TypePageBlock] blocks:
        :param List[TypePhoto] photos:
        :param List[TypeDocument] documents:

        Constructor for Page: Instance of either PagePart, PageFull.
        """
        self.blocks = blocks  # type: List[TypePageBlock]
        self.photos = photos  # type: List[TypePhoto]
        self.documents = documents  # type: List[TypeDocument]

    def to_dict(self):
        return {
            '_': 'PagePart',
            'blocks': [] if self.blocks is None else [None if x is None else x.to_dict() for x in self.blocks],
            'photos': [] if self.photos is None else [None if x is None else x.to_dict() for x in self.photos],
            'documents': [] if self.documents is None else [None if x is None else x.to_dict() for x in self.documents]
        }

    def __bytes__(self):
        return b''.join((
            b'\xbe\x9e?\x8e',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.blocks)),b''.join(bytes(x) for x in self.blocks),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.photos)),b''.join(bytes(x) for x in self.photos),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.documents)),b''.join(bytes(x) for x in self.documents),
        ))

    @classmethod
    def from_reader(cls, reader):
        reader.read_int()
        _blocks = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _blocks.append(_x)

        reader.read_int()
        _photos = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _photos.append(_x)

        reader.read_int()
        _documents = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _documents.append(_x)

        return cls(blocks=_blocks, photos=_photos, documents=_documents)


class PaymentCharge(TLObject):
    CONSTRUCTOR_ID = 0xea02c27e
    SUBCLASS_OF_ID = 0x3cc830d9

    def __init__(self, id, provider_charge_id):
        """
        :param str id:
        :param str provider_charge_id:

        Constructor for PaymentCharge: Instance of PaymentCharge.
        """
        self.id = id  # type: str
        self.provider_charge_id = provider_charge_id  # type: str

    def to_dict(self):
        return {
            '_': 'PaymentCharge',
            'id': self.id,
            'provider_charge_id': self.provider_charge_id
        }

    def __bytes__(self):
        return b''.join((
            b'~\xc2\x02\xea',
            self.serialize_bytes(self.id),
            self.serialize_bytes(self.provider_charge_id),
        ))

    @classmethod
    def from_reader(cls, reader):
        _id = reader.tgread_string()
        _provider_charge_id = reader.tgread_string()
        return cls(id=_id, provider_charge_id=_provider_charge_id)


class PaymentRequestedInfo(TLObject):
    CONSTRUCTOR_ID = 0x909c3f94
    SUBCLASS_OF_ID = 0x8db03146

    def __init__(self, name=None, phone=None, email=None, shipping_address=None):
        """
        :param Optional[str] name:
        :param Optional[str] phone:
        :param Optional[str] email:
        :param Optional[TypePostAddress] shipping_address:

        Constructor for PaymentRequestedInfo: Instance of PaymentRequestedInfo.
        """
        self.name = name  # type: Optional[str]
        self.phone = phone  # type: Optional[str]
        self.email = email  # type: Optional[str]
        self.shipping_address = shipping_address  # type: Optional[TypePostAddress]

    def to_dict(self):
        return {
            '_': 'PaymentRequestedInfo',
            'name': self.name,
            'phone': self.phone,
            'email': self.email,
            'shipping_address': None if self.shipping_address is None else self.shipping_address.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\x94?\x9c\x90',
            struct.pack('<I', (0 if self.name is None or self.name is False else 1) | (0 if self.phone is None or self.phone is False else 2) | (0 if self.email is None or self.email is False else 4) | (0 if self.shipping_address is None or self.shipping_address is False else 8)),
            b'' if self.name is None or self.name is False else (self.serialize_bytes(self.name)),
            b'' if self.phone is None or self.phone is False else (self.serialize_bytes(self.phone)),
            b'' if self.email is None or self.email is False else (self.serialize_bytes(self.email)),
            b'' if self.shipping_address is None or self.shipping_address is False else (bytes(self.shipping_address)),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        if flags & 1:
            _name = reader.tgread_string()
        else:
            _name = None
        if flags & 2:
            _phone = reader.tgread_string()
        else:
            _phone = None
        if flags & 4:
            _email = reader.tgread_string()
        else:
            _email = None
        if flags & 8:
            _shipping_address = reader.tgread_object()
        else:
            _shipping_address = None
        return cls(name=_name, phone=_phone, email=_email, shipping_address=_shipping_address)


class PaymentSavedCredentialsCard(TLObject):
    CONSTRUCTOR_ID = 0xcdc27a1f
    SUBCLASS_OF_ID = 0xb3627ee3

    def __init__(self, id, title):
        """
        :param str id:
        :param str title:

        Constructor for PaymentSavedCredentials: Instance of PaymentSavedCredentialsCard.
        """
        self.id = id  # type: str
        self.title = title  # type: str

    def to_dict(self):
        return {
            '_': 'PaymentSavedCredentialsCard',
            'id': self.id,
            'title': self.title
        }

    def __bytes__(self):
        return b''.join((
            b'\x1fz\xc2\xcd',
            self.serialize_bytes(self.id),
            self.serialize_bytes(self.title),
        ))

    @classmethod
    def from_reader(cls, reader):
        _id = reader.tgread_string()
        _title = reader.tgread_string()
        return cls(id=_id, title=_title)


class PeerChannel(TLObject):
    CONSTRUCTOR_ID = 0xbddde532
    SUBCLASS_OF_ID = 0x2d45687

    def __init__(self, channel_id):
        """
        :param int channel_id:

        Constructor for Peer: Instance of either PeerUser, PeerChat, PeerChannel.
        """
        self.channel_id = channel_id  # type: int

    def to_dict(self):
        return {
            '_': 'PeerChannel',
            'channel_id': self.channel_id
        }

    def __bytes__(self):
        return b''.join((
            b'2\xe5\xdd\xbd',
            struct.pack('<i', self.channel_id),
        ))

    @classmethod
    def from_reader(cls, reader):
        _channel_id = reader.read_int()
        return cls(channel_id=_channel_id)


class PeerChat(TLObject):
    CONSTRUCTOR_ID = 0xbad0e5bb
    SUBCLASS_OF_ID = 0x2d45687

    def __init__(self, chat_id):
        """
        :param int chat_id:

        Constructor for Peer: Instance of either PeerUser, PeerChat, PeerChannel.
        """
        self.chat_id = chat_id  # type: int

    def to_dict(self):
        return {
            '_': 'PeerChat',
            'chat_id': self.chat_id
        }

    def __bytes__(self):
        return b''.join((
            b'\xbb\xe5\xd0\xba',
            struct.pack('<i', self.chat_id),
        ))

    @classmethod
    def from_reader(cls, reader):
        _chat_id = reader.read_int()
        return cls(chat_id=_chat_id)


class PeerNotifySettings(TLObject):
    CONSTRUCTOR_ID = 0xaf509d20
    SUBCLASS_OF_ID = 0xcf20c074

    def __init__(self, show_previews=None, silent=None, mute_until=None, sound=None):
        """
        :param Optional[TypeBool] show_previews:
        :param Optional[TypeBool] silent:
        :param Optional[int] mute_until:
        :param Optional[str] sound:

        Constructor for PeerNotifySettings: Instance of PeerNotifySettings.
        """
        self.show_previews = show_previews  # type: Optional[TypeBool]
        self.silent = silent  # type: Optional[TypeBool]
        self.mute_until = mute_until  # type: Optional[int]
        self.sound = sound  # type: Optional[str]

    def to_dict(self):
        return {
            '_': 'PeerNotifySettings',
            'show_previews': self.show_previews,
            'silent': self.silent,
            'mute_until': self.mute_until,
            'sound': self.sound
        }

    def __bytes__(self):
        return b''.join((
            b' \x9dP\xaf',
            struct.pack('<I', (0 if self.show_previews is None or self.show_previews is False else 1) | (0 if self.silent is None or self.silent is False else 2) | (0 if self.mute_until is None or self.mute_until is False else 4) | (0 if self.sound is None or self.sound is False else 8)),
            b'' if self.show_previews is None or self.show_previews is False else (b'\xb5ur\x99' if self.show_previews else b'7\x97y\xbc'),
            b'' if self.silent is None or self.silent is False else (b'\xb5ur\x99' if self.silent else b'7\x97y\xbc'),
            b'' if self.mute_until is None or self.mute_until is False else (struct.pack('<i', self.mute_until)),
            b'' if self.sound is None or self.sound is False else (self.serialize_bytes(self.sound)),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        if flags & 1:
            _show_previews = reader.tgread_bool()
        else:
            _show_previews = None
        if flags & 2:
            _silent = reader.tgread_bool()
        else:
            _silent = None
        if flags & 4:
            _mute_until = reader.read_int()
        else:
            _mute_until = None
        if flags & 8:
            _sound = reader.tgread_string()
        else:
            _sound = None
        return cls(show_previews=_show_previews, silent=_silent, mute_until=_mute_until, sound=_sound)


class PeerSettings(TLObject):
    CONSTRUCTOR_ID = 0x818426cd
    SUBCLASS_OF_ID = 0xf6a79f84

    def __init__(self, report_spam=None):
        """
        :param Optional[bool] report_spam:

        Constructor for PeerSettings: Instance of PeerSettings.
        """
        self.report_spam = report_spam  # type: Optional[bool]

    def to_dict(self):
        return {
            '_': 'PeerSettings',
            'report_spam': self.report_spam
        }

    def __bytes__(self):
        return b''.join((
            b'\xcd&\x84\x81',
            struct.pack('<I', (0 if self.report_spam is None or self.report_spam is False else 1)),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _report_spam = bool(flags & 1)
        return cls(report_spam=_report_spam)


class PeerUser(TLObject):
    CONSTRUCTOR_ID = 0x9db1bc6d
    SUBCLASS_OF_ID = 0x2d45687

    def __init__(self, user_id):
        """
        :param int user_id:

        Constructor for Peer: Instance of either PeerUser, PeerChat, PeerChannel.
        """
        self.user_id = user_id  # type: int

    def to_dict(self):
        return {
            '_': 'PeerUser',
            'user_id': self.user_id
        }

    def __bytes__(self):
        return b''.join((
            b'm\xbc\xb1\x9d',
            struct.pack('<i', self.user_id),
        ))

    @classmethod
    def from_reader(cls, reader):
        _user_id = reader.read_int()
        return cls(user_id=_user_id)


class PhoneCall(TLObject):
    CONSTRUCTOR_ID = 0xffe6ab67
    SUBCLASS_OF_ID = 0xc47f1bd1

    def __init__(self, id, access_hash, date, admin_id, participant_id, g_a_or_b, key_fingerprint, protocol, connection, alternative_connections, start_date):
        """
        :param int id:
        :param int access_hash:
        :param Optional[datetime] date:
        :param int admin_id:
        :param int participant_id:
        :param bytes g_a_or_b:
        :param int key_fingerprint:
        :param TypePhoneCallProtocol protocol:
        :param TypePhoneConnection connection:
        :param List[TypePhoneConnection] alternative_connections:
        :param Optional[datetime] start_date:

        Constructor for PhoneCall: Instance of either PhoneCallEmpty, PhoneCallWaiting, PhoneCallRequested, PhoneCallAccepted, PhoneCall, PhoneCallDiscarded.
        """
        self.id = id  # type: int
        self.access_hash = access_hash  # type: int
        self.date = date  # type: Optional[datetime]
        self.admin_id = admin_id  # type: int
        self.participant_id = participant_id  # type: int
        self.g_a_or_b = g_a_or_b  # type: bytes
        self.key_fingerprint = key_fingerprint  # type: int
        self.protocol = protocol  # type: TypePhoneCallProtocol
        self.connection = connection  # type: TypePhoneConnection
        self.alternative_connections = alternative_connections  # type: List[TypePhoneConnection]
        self.start_date = start_date  # type: Optional[datetime]

    def to_dict(self):
        return {
            '_': 'PhoneCall',
            'id': self.id,
            'access_hash': self.access_hash,
            'date': self.date,
            'admin_id': self.admin_id,
            'participant_id': self.participant_id,
            'g_a_or_b': self.g_a_or_b,
            'key_fingerprint': self.key_fingerprint,
            'protocol': None if self.protocol is None else self.protocol.to_dict(),
            'connection': None if self.connection is None else self.connection.to_dict(),
            'alternative_connections': [] if self.alternative_connections is None else [None if x is None else x.to_dict() for x in self.alternative_connections],
            'start_date': self.start_date
        }

    def __bytes__(self):
        return b''.join((
            b'g\xab\xe6\xff',
            struct.pack('<q', self.id),
            struct.pack('<q', self.access_hash),
            self.serialize_datetime(self.date),
            struct.pack('<i', self.admin_id),
            struct.pack('<i', self.participant_id),
            self.serialize_bytes(self.g_a_or_b),
            struct.pack('<q', self.key_fingerprint),
            bytes(self.protocol),
            bytes(self.connection),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.alternative_connections)),b''.join(bytes(x) for x in self.alternative_connections),
            self.serialize_datetime(self.start_date),
        ))

    @classmethod
    def from_reader(cls, reader):
        _id = reader.read_long()
        _access_hash = reader.read_long()
        _date = reader.tgread_date()
        _admin_id = reader.read_int()
        _participant_id = reader.read_int()
        _g_a_or_b = reader.tgread_bytes()
        _key_fingerprint = reader.read_long()
        _protocol = reader.tgread_object()
        _connection = reader.tgread_object()
        reader.read_int()
        _alternative_connections = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _alternative_connections.append(_x)

        _start_date = reader.tgread_date()
        return cls(id=_id, access_hash=_access_hash, date=_date, admin_id=_admin_id, participant_id=_participant_id, g_a_or_b=_g_a_or_b, key_fingerprint=_key_fingerprint, protocol=_protocol, connection=_connection, alternative_connections=_alternative_connections, start_date=_start_date)


class PhoneCallAccepted(TLObject):
    CONSTRUCTOR_ID = 0x6d003d3f
    SUBCLASS_OF_ID = 0xc47f1bd1

    def __init__(self, id, access_hash, date, admin_id, participant_id, g_b, protocol):
        """
        :param int id:
        :param int access_hash:
        :param Optional[datetime] date:
        :param int admin_id:
        :param int participant_id:
        :param bytes g_b:
        :param TypePhoneCallProtocol protocol:

        Constructor for PhoneCall: Instance of either PhoneCallEmpty, PhoneCallWaiting, PhoneCallRequested, PhoneCallAccepted, PhoneCall, PhoneCallDiscarded.
        """
        self.id = id  # type: int
        self.access_hash = access_hash  # type: int
        self.date = date  # type: Optional[datetime]
        self.admin_id = admin_id  # type: int
        self.participant_id = participant_id  # type: int
        self.g_b = g_b  # type: bytes
        self.protocol = protocol  # type: TypePhoneCallProtocol

    def to_dict(self):
        return {
            '_': 'PhoneCallAccepted',
            'id': self.id,
            'access_hash': self.access_hash,
            'date': self.date,
            'admin_id': self.admin_id,
            'participant_id': self.participant_id,
            'g_b': self.g_b,
            'protocol': None if self.protocol is None else self.protocol.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'?=\x00m',
            struct.pack('<q', self.id),
            struct.pack('<q', self.access_hash),
            self.serialize_datetime(self.date),
            struct.pack('<i', self.admin_id),
            struct.pack('<i', self.participant_id),
            self.serialize_bytes(self.g_b),
            bytes(self.protocol),
        ))

    @classmethod
    def from_reader(cls, reader):
        _id = reader.read_long()
        _access_hash = reader.read_long()
        _date = reader.tgread_date()
        _admin_id = reader.read_int()
        _participant_id = reader.read_int()
        _g_b = reader.tgread_bytes()
        _protocol = reader.tgread_object()
        return cls(id=_id, access_hash=_access_hash, date=_date, admin_id=_admin_id, participant_id=_participant_id, g_b=_g_b, protocol=_protocol)


class PhoneCallDiscardReasonBusy(TLObject):
    CONSTRUCTOR_ID = 0xfaf7e8c9
    SUBCLASS_OF_ID = 0xd89bad3d

    def to_dict(self):
        return {
            '_': 'PhoneCallDiscardReasonBusy'
        }

    def __bytes__(self):
        return b''.join((
            b'\xc9\xe8\xf7\xfa',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class PhoneCallDiscardReasonDisconnect(TLObject):
    CONSTRUCTOR_ID = 0xe095c1a0
    SUBCLASS_OF_ID = 0xd89bad3d

    def to_dict(self):
        return {
            '_': 'PhoneCallDiscardReasonDisconnect'
        }

    def __bytes__(self):
        return b''.join((
            b'\xa0\xc1\x95\xe0',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class PhoneCallDiscardReasonHangup(TLObject):
    CONSTRUCTOR_ID = 0x57adc690
    SUBCLASS_OF_ID = 0xd89bad3d

    def to_dict(self):
        return {
            '_': 'PhoneCallDiscardReasonHangup'
        }

    def __bytes__(self):
        return b''.join((
            b'\x90\xc6\xadW',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class PhoneCallDiscardReasonMissed(TLObject):
    CONSTRUCTOR_ID = 0x85e42301
    SUBCLASS_OF_ID = 0xd89bad3d

    def to_dict(self):
        return {
            '_': 'PhoneCallDiscardReasonMissed'
        }

    def __bytes__(self):
        return b''.join((
            b'\x01#\xe4\x85',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class PhoneCallDiscarded(TLObject):
    CONSTRUCTOR_ID = 0x50ca4de1
    SUBCLASS_OF_ID = 0xc47f1bd1

    def __init__(self, id, need_rating=None, need_debug=None, reason=None, duration=None):
        """
        :param int id:
        :param Optional[bool] need_rating:
        :param Optional[bool] need_debug:
        :param Optional[TypePhoneCallDiscardReason] reason:
        :param Optional[int] duration:

        Constructor for PhoneCall: Instance of either PhoneCallEmpty, PhoneCallWaiting, PhoneCallRequested, PhoneCallAccepted, PhoneCall, PhoneCallDiscarded.
        """
        self.id = id  # type: int
        self.need_rating = need_rating  # type: Optional[bool]
        self.need_debug = need_debug  # type: Optional[bool]
        self.reason = reason  # type: Optional[TypePhoneCallDiscardReason]
        self.duration = duration  # type: Optional[int]

    def to_dict(self):
        return {
            '_': 'PhoneCallDiscarded',
            'id': self.id,
            'need_rating': self.need_rating,
            'need_debug': self.need_debug,
            'reason': None if self.reason is None else self.reason.to_dict(),
            'duration': self.duration
        }

    def __bytes__(self):
        return b''.join((
            b'\xe1M\xcaP',
            struct.pack('<I', (0 if self.need_rating is None or self.need_rating is False else 4) | (0 if self.need_debug is None or self.need_debug is False else 8) | (0 if self.reason is None or self.reason is False else 1) | (0 if self.duration is None or self.duration is False else 2)),
            struct.pack('<q', self.id),
            b'' if self.reason is None or self.reason is False else (bytes(self.reason)),
            b'' if self.duration is None or self.duration is False else (struct.pack('<i', self.duration)),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _need_rating = bool(flags & 4)
        _need_debug = bool(flags & 8)
        _id = reader.read_long()
        if flags & 1:
            _reason = reader.tgread_object()
        else:
            _reason = None
        if flags & 2:
            _duration = reader.read_int()
        else:
            _duration = None
        return cls(id=_id, need_rating=_need_rating, need_debug=_need_debug, reason=_reason, duration=_duration)


class PhoneCallEmpty(TLObject):
    CONSTRUCTOR_ID = 0x5366c915
    SUBCLASS_OF_ID = 0xc47f1bd1

    def __init__(self, id):
        """
        :param int id:

        Constructor for PhoneCall: Instance of either PhoneCallEmpty, PhoneCallWaiting, PhoneCallRequested, PhoneCallAccepted, PhoneCall, PhoneCallDiscarded.
        """
        self.id = id  # type: int

    def to_dict(self):
        return {
            '_': 'PhoneCallEmpty',
            'id': self.id
        }

    def __bytes__(self):
        return b''.join((
            b'\x15\xc9fS',
            struct.pack('<q', self.id),
        ))

    @classmethod
    def from_reader(cls, reader):
        _id = reader.read_long()
        return cls(id=_id)


class PhoneCallProtocol(TLObject):
    CONSTRUCTOR_ID = 0xa2bb35cb
    SUBCLASS_OF_ID = 0x783991a3

    def __init__(self, min_layer, max_layer, udp_p2p=None, udp_reflector=None):
        """
        :param int min_layer:
        :param int max_layer:
        :param Optional[bool] udp_p2p:
        :param Optional[bool] udp_reflector:

        Constructor for PhoneCallProtocol: Instance of PhoneCallProtocol.
        """
        self.min_layer = min_layer  # type: int
        self.max_layer = max_layer  # type: int
        self.udp_p2p = udp_p2p  # type: Optional[bool]
        self.udp_reflector = udp_reflector  # type: Optional[bool]

    def to_dict(self):
        return {
            '_': 'PhoneCallProtocol',
            'min_layer': self.min_layer,
            'max_layer': self.max_layer,
            'udp_p2p': self.udp_p2p,
            'udp_reflector': self.udp_reflector
        }

    def __bytes__(self):
        return b''.join((
            b'\xcb5\xbb\xa2',
            struct.pack('<I', (0 if self.udp_p2p is None or self.udp_p2p is False else 1) | (0 if self.udp_reflector is None or self.udp_reflector is False else 2)),
            struct.pack('<i', self.min_layer),
            struct.pack('<i', self.max_layer),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _udp_p2p = bool(flags & 1)
        _udp_reflector = bool(flags & 2)
        _min_layer = reader.read_int()
        _max_layer = reader.read_int()
        return cls(min_layer=_min_layer, max_layer=_max_layer, udp_p2p=_udp_p2p, udp_reflector=_udp_reflector)


class PhoneCallRequested(TLObject):
    CONSTRUCTOR_ID = 0x83761ce4
    SUBCLASS_OF_ID = 0xc47f1bd1

    def __init__(self, id, access_hash, date, admin_id, participant_id, g_a_hash, protocol):
        """
        :param int id:
        :param int access_hash:
        :param Optional[datetime] date:
        :param int admin_id:
        :param int participant_id:
        :param bytes g_a_hash:
        :param TypePhoneCallProtocol protocol:

        Constructor for PhoneCall: Instance of either PhoneCallEmpty, PhoneCallWaiting, PhoneCallRequested, PhoneCallAccepted, PhoneCall, PhoneCallDiscarded.
        """
        self.id = id  # type: int
        self.access_hash = access_hash  # type: int
        self.date = date  # type: Optional[datetime]
        self.admin_id = admin_id  # type: int
        self.participant_id = participant_id  # type: int
        self.g_a_hash = g_a_hash  # type: bytes
        self.protocol = protocol  # type: TypePhoneCallProtocol

    def to_dict(self):
        return {
            '_': 'PhoneCallRequested',
            'id': self.id,
            'access_hash': self.access_hash,
            'date': self.date,
            'admin_id': self.admin_id,
            'participant_id': self.participant_id,
            'g_a_hash': self.g_a_hash,
            'protocol': None if self.protocol is None else self.protocol.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\xe4\x1cv\x83',
            struct.pack('<q', self.id),
            struct.pack('<q', self.access_hash),
            self.serialize_datetime(self.date),
            struct.pack('<i', self.admin_id),
            struct.pack('<i', self.participant_id),
            self.serialize_bytes(self.g_a_hash),
            bytes(self.protocol),
        ))

    @classmethod
    def from_reader(cls, reader):
        _id = reader.read_long()
        _access_hash = reader.read_long()
        _date = reader.tgread_date()
        _admin_id = reader.read_int()
        _participant_id = reader.read_int()
        _g_a_hash = reader.tgread_bytes()
        _protocol = reader.tgread_object()
        return cls(id=_id, access_hash=_access_hash, date=_date, admin_id=_admin_id, participant_id=_participant_id, g_a_hash=_g_a_hash, protocol=_protocol)


class PhoneCallWaiting(TLObject):
    CONSTRUCTOR_ID = 0x1b8f4ad1
    SUBCLASS_OF_ID = 0xc47f1bd1

    def __init__(self, id, access_hash, date, admin_id, participant_id, protocol, receive_date=None):
        """
        :param int id:
        :param int access_hash:
        :param Optional[datetime] date:
        :param int admin_id:
        :param int participant_id:
        :param TypePhoneCallProtocol protocol:
        :param Optional[datetime] receive_date:

        Constructor for PhoneCall: Instance of either PhoneCallEmpty, PhoneCallWaiting, PhoneCallRequested, PhoneCallAccepted, PhoneCall, PhoneCallDiscarded.
        """
        self.id = id  # type: int
        self.access_hash = access_hash  # type: int
        self.date = date  # type: Optional[datetime]
        self.admin_id = admin_id  # type: int
        self.participant_id = participant_id  # type: int
        self.protocol = protocol  # type: TypePhoneCallProtocol
        self.receive_date = receive_date  # type: Optional[datetime]

    def to_dict(self):
        return {
            '_': 'PhoneCallWaiting',
            'id': self.id,
            'access_hash': self.access_hash,
            'date': self.date,
            'admin_id': self.admin_id,
            'participant_id': self.participant_id,
            'protocol': None if self.protocol is None else self.protocol.to_dict(),
            'receive_date': self.receive_date
        }

    def __bytes__(self):
        return b''.join((
            b'\xd1J\x8f\x1b',
            struct.pack('<I', (0 if self.receive_date is None or self.receive_date is False else 1)),
            struct.pack('<q', self.id),
            struct.pack('<q', self.access_hash),
            self.serialize_datetime(self.date),
            struct.pack('<i', self.admin_id),
            struct.pack('<i', self.participant_id),
            bytes(self.protocol),
            b'' if self.receive_date is None or self.receive_date is False else (self.serialize_datetime(self.receive_date)),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _id = reader.read_long()
        _access_hash = reader.read_long()
        _date = reader.tgread_date()
        _admin_id = reader.read_int()
        _participant_id = reader.read_int()
        _protocol = reader.tgread_object()
        if flags & 1:
            _receive_date = reader.tgread_date()
        else:
            _receive_date = None
        return cls(id=_id, access_hash=_access_hash, date=_date, admin_id=_admin_id, participant_id=_participant_id, protocol=_protocol, receive_date=_receive_date)


class PhoneConnection(TLObject):
    CONSTRUCTOR_ID = 0x9d4c17c0
    SUBCLASS_OF_ID = 0xaa8de40d

    def __init__(self, id, ip, ipv6, port, peer_tag):
        """
        :param int id:
        :param str ip:
        :param str ipv6:
        :param int port:
        :param bytes peer_tag:

        Constructor for PhoneConnection: Instance of PhoneConnection.
        """
        self.id = id  # type: int
        self.ip = ip  # type: str
        self.ipv6 = ipv6  # type: str
        self.port = port  # type: int
        self.peer_tag = peer_tag  # type: bytes

    def to_dict(self):
        return {
            '_': 'PhoneConnection',
            'id': self.id,
            'ip': self.ip,
            'ipv6': self.ipv6,
            'port': self.port,
            'peer_tag': self.peer_tag
        }

    def __bytes__(self):
        return b''.join((
            b'\xc0\x17L\x9d',
            struct.pack('<q', self.id),
            self.serialize_bytes(self.ip),
            self.serialize_bytes(self.ipv6),
            struct.pack('<i', self.port),
            self.serialize_bytes(self.peer_tag),
        ))

    @classmethod
    def from_reader(cls, reader):
        _id = reader.read_long()
        _ip = reader.tgread_string()
        _ipv6 = reader.tgread_string()
        _port = reader.read_int()
        _peer_tag = reader.tgread_bytes()
        return cls(id=_id, ip=_ip, ipv6=_ipv6, port=_port, peer_tag=_peer_tag)


class Photo(TLObject):
    CONSTRUCTOR_ID = 0x9288dd29
    SUBCLASS_OF_ID = 0xd576ab1c

    def __init__(self, id, access_hash, date, sizes, has_stickers=None):
        """
        :param int id:
        :param int access_hash:
        :param Optional[datetime] date:
        :param List[TypePhotoSize] sizes:
        :param Optional[bool] has_stickers:

        Constructor for Photo: Instance of either PhotoEmpty, Photo.
        """
        self.id = id  # type: int
        self.access_hash = access_hash  # type: int
        self.date = date  # type: Optional[datetime]
        self.sizes = sizes  # type: List[TypePhotoSize]
        self.has_stickers = has_stickers  # type: Optional[bool]

    def to_dict(self):
        return {
            '_': 'Photo',
            'id': self.id,
            'access_hash': self.access_hash,
            'date': self.date,
            'sizes': [] if self.sizes is None else [None if x is None else x.to_dict() for x in self.sizes],
            'has_stickers': self.has_stickers
        }

    def __bytes__(self):
        return b''.join((
            b')\xdd\x88\x92',
            struct.pack('<I', (0 if self.has_stickers is None or self.has_stickers is False else 1)),
            struct.pack('<q', self.id),
            struct.pack('<q', self.access_hash),
            self.serialize_datetime(self.date),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.sizes)),b''.join(bytes(x) for x in self.sizes),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _has_stickers = bool(flags & 1)
        _id = reader.read_long()
        _access_hash = reader.read_long()
        _date = reader.tgread_date()
        reader.read_int()
        _sizes = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _sizes.append(_x)

        return cls(id=_id, access_hash=_access_hash, date=_date, sizes=_sizes, has_stickers=_has_stickers)


class PhotoCachedSize(TLObject):
    CONSTRUCTOR_ID = 0xe9a734fa
    SUBCLASS_OF_ID = 0x17cc29d9

    def __init__(self, type, location, w, h, bytes):
        """
        :param str type:
        :param TypeFileLocation location:
        :param int w:
        :param int h:
        :param bytes bytes:

        Constructor for PhotoSize: Instance of either PhotoSizeEmpty, PhotoSize, PhotoCachedSize.
        """
        self.type = type  # type: str
        self.location = location  # type: TypeFileLocation
        self.w = w  # type: int
        self.h = h  # type: int
        self.bytes = bytes  # type: bytes

    def to_dict(self):
        return {
            '_': 'PhotoCachedSize',
            'type': self.type,
            'location': None if self.location is None else self.location.to_dict(),
            'w': self.w,
            'h': self.h,
            'bytes': self.bytes
        }

    def __bytes__(self):
        return b''.join((
            b'\xfa4\xa7\xe9',
            self.serialize_bytes(self.type),
            bytes(self.location),
            struct.pack('<i', self.w),
            struct.pack('<i', self.h),
            self.serialize_bytes(self.bytes),
        ))

    @classmethod
    def from_reader(cls, reader):
        _type = reader.tgread_string()
        _location = reader.tgread_object()
        _w = reader.read_int()
        _h = reader.read_int()
        _bytes = reader.tgread_bytes()
        return cls(type=_type, location=_location, w=_w, h=_h, bytes=_bytes)


class PhotoEmpty(TLObject):
    CONSTRUCTOR_ID = 0x2331b22d
    SUBCLASS_OF_ID = 0xd576ab1c

    def __init__(self, id):
        """
        :param int id:

        Constructor for Photo: Instance of either PhotoEmpty, Photo.
        """
        self.id = id  # type: int

    def to_dict(self):
        return {
            '_': 'PhotoEmpty',
            'id': self.id
        }

    def __bytes__(self):
        return b''.join((
            b'-\xb21#',
            struct.pack('<q', self.id),
        ))

    @classmethod
    def from_reader(cls, reader):
        _id = reader.read_long()
        return cls(id=_id)


class PhotoSize(TLObject):
    CONSTRUCTOR_ID = 0x77bfb61b
    SUBCLASS_OF_ID = 0x17cc29d9

    def __init__(self, type, location, w, h, size):
        """
        :param str type:
        :param TypeFileLocation location:
        :param int w:
        :param int h:
        :param int size:

        Constructor for PhotoSize: Instance of either PhotoSizeEmpty, PhotoSize, PhotoCachedSize.
        """
        self.type = type  # type: str
        self.location = location  # type: TypeFileLocation
        self.w = w  # type: int
        self.h = h  # type: int
        self.size = size  # type: int

    def to_dict(self):
        return {
            '_': 'PhotoSize',
            'type': self.type,
            'location': None if self.location is None else self.location.to_dict(),
            'w': self.w,
            'h': self.h,
            'size': self.size
        }

    def __bytes__(self):
        return b''.join((
            b'\x1b\xb6\xbfw',
            self.serialize_bytes(self.type),
            bytes(self.location),
            struct.pack('<i', self.w),
            struct.pack('<i', self.h),
            struct.pack('<i', self.size),
        ))

    @classmethod
    def from_reader(cls, reader):
        _type = reader.tgread_string()
        _location = reader.tgread_object()
        _w = reader.read_int()
        _h = reader.read_int()
        _size = reader.read_int()
        return cls(type=_type, location=_location, w=_w, h=_h, size=_size)


class PhotoSizeEmpty(TLObject):
    CONSTRUCTOR_ID = 0xe17e23c
    SUBCLASS_OF_ID = 0x17cc29d9

    def __init__(self, type):
        """
        :param str type:

        Constructor for PhotoSize: Instance of either PhotoSizeEmpty, PhotoSize, PhotoCachedSize.
        """
        self.type = type  # type: str

    def to_dict(self):
        return {
            '_': 'PhotoSizeEmpty',
            'type': self.type
        }

    def __bytes__(self):
        return b''.join((
            b'<\xe2\x17\x0e',
            self.serialize_bytes(self.type),
        ))

    @classmethod
    def from_reader(cls, reader):
        _type = reader.tgread_string()
        return cls(type=_type)


class Pong(TLObject):
    CONSTRUCTOR_ID = 0x347773c5
    SUBCLASS_OF_ID = 0x816aee71

    def __init__(self, msg_id, ping_id):
        """
        :param int msg_id:
        :param int ping_id:

        Constructor for Pong: Instance of Pong.
        """
        self.msg_id = msg_id  # type: int
        self.ping_id = ping_id  # type: int

    def to_dict(self):
        return {
            '_': 'Pong',
            'msg_id': self.msg_id,
            'ping_id': self.ping_id
        }

    def __bytes__(self):
        return b''.join((
            b'\xc5sw4',
            struct.pack('<q', self.msg_id),
            struct.pack('<q', self.ping_id),
        ))

    @classmethod
    def from_reader(cls, reader):
        _msg_id = reader.read_long()
        _ping_id = reader.read_long()
        return cls(msg_id=_msg_id, ping_id=_ping_id)


class PopularContact(TLObject):
    CONSTRUCTOR_ID = 0x5ce14175
    SUBCLASS_OF_ID = 0x409255a

    def __init__(self, client_id, importers):
        """
        :param int client_id:
        :param int importers:

        Constructor for PopularContact: Instance of PopularContact.
        """
        self.client_id = client_id  # type: int
        self.importers = importers  # type: int

    def to_dict(self):
        return {
            '_': 'PopularContact',
            'client_id': self.client_id,
            'importers': self.importers
        }

    def __bytes__(self):
        return b''.join((
            b'uA\xe1\\',
            struct.pack('<q', self.client_id),
            struct.pack('<i', self.importers),
        ))

    @classmethod
    def from_reader(cls, reader):
        _client_id = reader.read_long()
        _importers = reader.read_int()
        return cls(client_id=_client_id, importers=_importers)


class PostAddress(TLObject):
    CONSTRUCTOR_ID = 0x1e8caaeb
    SUBCLASS_OF_ID = 0x8d7eda2c

    def __init__(self, street_line1, street_line2, city, state, country_iso2, post_code):
        """
        :param str street_line1:
        :param str street_line2:
        :param str city:
        :param str state:
        :param str country_iso2:
        :param str post_code:

        Constructor for PostAddress: Instance of PostAddress.
        """
        self.street_line1 = street_line1  # type: str
        self.street_line2 = street_line2  # type: str
        self.city = city  # type: str
        self.state = state  # type: str
        self.country_iso2 = country_iso2  # type: str
        self.post_code = post_code  # type: str

    def to_dict(self):
        return {
            '_': 'PostAddress',
            'street_line1': self.street_line1,
            'street_line2': self.street_line2,
            'city': self.city,
            'state': self.state,
            'country_iso2': self.country_iso2,
            'post_code': self.post_code
        }

    def __bytes__(self):
        return b''.join((
            b'\xeb\xaa\x8c\x1e',
            self.serialize_bytes(self.street_line1),
            self.serialize_bytes(self.street_line2),
            self.serialize_bytes(self.city),
            self.serialize_bytes(self.state),
            self.serialize_bytes(self.country_iso2),
            self.serialize_bytes(self.post_code),
        ))

    @classmethod
    def from_reader(cls, reader):
        _street_line1 = reader.tgread_string()
        _street_line2 = reader.tgread_string()
        _city = reader.tgread_string()
        _state = reader.tgread_string()
        _country_iso2 = reader.tgread_string()
        _post_code = reader.tgread_string()
        return cls(street_line1=_street_line1, street_line2=_street_line2, city=_city, state=_state, country_iso2=_country_iso2, post_code=_post_code)


class PrivacyKeyChatInvite(TLObject):
    CONSTRUCTOR_ID = 0x500e6dfa
    SUBCLASS_OF_ID = 0x824651c3

    def to_dict(self):
        return {
            '_': 'PrivacyKeyChatInvite'
        }

    def __bytes__(self):
        return b''.join((
            b'\xfam\x0eP',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class PrivacyKeyPhoneCall(TLObject):
    CONSTRUCTOR_ID = 0x3d662b7b
    SUBCLASS_OF_ID = 0x824651c3

    def to_dict(self):
        return {
            '_': 'PrivacyKeyPhoneCall'
        }

    def __bytes__(self):
        return b''.join((
            b'{+f=',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class PrivacyKeyStatusTimestamp(TLObject):
    CONSTRUCTOR_ID = 0xbc2eab30
    SUBCLASS_OF_ID = 0x824651c3

    def to_dict(self):
        return {
            '_': 'PrivacyKeyStatusTimestamp'
        }

    def __bytes__(self):
        return b''.join((
            b'0\xab.\xbc',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class PrivacyValueAllowAll(TLObject):
    CONSTRUCTOR_ID = 0x65427b82
    SUBCLASS_OF_ID = 0xebb7f270

    def to_dict(self):
        return {
            '_': 'PrivacyValueAllowAll'
        }

    def __bytes__(self):
        return b''.join((
            b'\x82{Be',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class PrivacyValueAllowContacts(TLObject):
    CONSTRUCTOR_ID = 0xfffe1bac
    SUBCLASS_OF_ID = 0xebb7f270

    def to_dict(self):
        return {
            '_': 'PrivacyValueAllowContacts'
        }

    def __bytes__(self):
        return b''.join((
            b'\xac\x1b\xfe\xff',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class PrivacyValueAllowUsers(TLObject):
    CONSTRUCTOR_ID = 0x4d5bbe0c
    SUBCLASS_OF_ID = 0xebb7f270

    def __init__(self, users):
        """
        :param List[int] users:

        Constructor for PrivacyRule: Instance of either PrivacyValueAllowContacts, PrivacyValueAllowAll, PrivacyValueAllowUsers, PrivacyValueDisallowContacts, PrivacyValueDisallowAll, PrivacyValueDisallowUsers.
        """
        self.users = users  # type: List[int]

    def to_dict(self):
        return {
            '_': 'PrivacyValueAllowUsers',
            'users': [] if self.users is None else self.users[:]
        }

    def __bytes__(self):
        return b''.join((
            b'\x0c\xbe[M',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.users)),b''.join(struct.pack('<i', x) for x in self.users),
        ))

    @classmethod
    def from_reader(cls, reader):
        reader.read_int()
        _users = []
        for _ in range(reader.read_int()):
            _x = reader.read_int()
            _users.append(_x)

        return cls(users=_users)


class PrivacyValueDisallowAll(TLObject):
    CONSTRUCTOR_ID = 0x8b73e763
    SUBCLASS_OF_ID = 0xebb7f270

    def to_dict(self):
        return {
            '_': 'PrivacyValueDisallowAll'
        }

    def __bytes__(self):
        return b''.join((
            b'c\xe7s\x8b',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class PrivacyValueDisallowContacts(TLObject):
    CONSTRUCTOR_ID = 0xf888fa1a
    SUBCLASS_OF_ID = 0xebb7f270

    def to_dict(self):
        return {
            '_': 'PrivacyValueDisallowContacts'
        }

    def __bytes__(self):
        return b''.join((
            b'\x1a\xfa\x88\xf8',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class PrivacyValueDisallowUsers(TLObject):
    CONSTRUCTOR_ID = 0xc7f49b7
    SUBCLASS_OF_ID = 0xebb7f270

    def __init__(self, users):
        """
        :param List[int] users:

        Constructor for PrivacyRule: Instance of either PrivacyValueAllowContacts, PrivacyValueAllowAll, PrivacyValueAllowUsers, PrivacyValueDisallowContacts, PrivacyValueDisallowAll, PrivacyValueDisallowUsers.
        """
        self.users = users  # type: List[int]

    def to_dict(self):
        return {
            '_': 'PrivacyValueDisallowUsers',
            'users': [] if self.users is None else self.users[:]
        }

    def __bytes__(self):
        return b''.join((
            b'\xb7I\x7f\x0c',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.users)),b''.join(struct.pack('<i', x) for x in self.users),
        ))

    @classmethod
    def from_reader(cls, reader):
        reader.read_int()
        _users = []
        for _ in range(reader.read_int()):
            _x = reader.read_int()
            _users.append(_x)

        return cls(users=_users)


class ReceivedNotifyMessage(TLObject):
    CONSTRUCTOR_ID = 0xa384b779
    SUBCLASS_OF_ID = 0xa962381e

    def __init__(self, id, flags):
        """
        :param int id:
        :param int flags:

        Constructor for ReceivedNotifyMessage: Instance of ReceivedNotifyMessage.
        """
        self.id = id  # type: int
        self.flags = flags  # type: int

    def to_dict(self):
        return {
            '_': 'ReceivedNotifyMessage',
            'id': self.id,
            'flags': self.flags
        }

    def __bytes__(self):
        return b''.join((
            b'y\xb7\x84\xa3',
            struct.pack('<i', self.id),
            struct.pack('<i', self.flags),
        ))

    @classmethod
    def from_reader(cls, reader):
        _id = reader.read_int()
        _flags = reader.read_int()
        return cls(id=_id, flags=_flags)


class RecentMeUrlChat(TLObject):
    CONSTRUCTOR_ID = 0xa01b22f9
    SUBCLASS_OF_ID = 0x55a53079

    def __init__(self, url, chat_id):
        """
        :param str url:
        :param int chat_id:

        Constructor for RecentMeUrl: Instance of either RecentMeUrlUnknown, RecentMeUrlUser, RecentMeUrlChat, RecentMeUrlChatInvite, RecentMeUrlStickerSet.
        """
        self.url = url  # type: str
        self.chat_id = chat_id  # type: int

    def to_dict(self):
        return {
            '_': 'RecentMeUrlChat',
            'url': self.url,
            'chat_id': self.chat_id
        }

    def __bytes__(self):
        return b''.join((
            b'\xf9"\x1b\xa0',
            self.serialize_bytes(self.url),
            struct.pack('<i', self.chat_id),
        ))

    @classmethod
    def from_reader(cls, reader):
        _url = reader.tgread_string()
        _chat_id = reader.read_int()
        return cls(url=_url, chat_id=_chat_id)


class RecentMeUrlChatInvite(TLObject):
    CONSTRUCTOR_ID = 0xeb49081d
    SUBCLASS_OF_ID = 0x55a53079

    def __init__(self, url, chat_invite):
        """
        :param str url:
        :param TypeChatInvite chat_invite:

        Constructor for RecentMeUrl: Instance of either RecentMeUrlUnknown, RecentMeUrlUser, RecentMeUrlChat, RecentMeUrlChatInvite, RecentMeUrlStickerSet.
        """
        self.url = url  # type: str
        self.chat_invite = chat_invite  # type: TypeChatInvite

    def to_dict(self):
        return {
            '_': 'RecentMeUrlChatInvite',
            'url': self.url,
            'chat_invite': None if self.chat_invite is None else self.chat_invite.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\x1d\x08I\xeb',
            self.serialize_bytes(self.url),
            bytes(self.chat_invite),
        ))

    @classmethod
    def from_reader(cls, reader):
        _url = reader.tgread_string()
        _chat_invite = reader.tgread_object()
        return cls(url=_url, chat_invite=_chat_invite)


class RecentMeUrlStickerSet(TLObject):
    CONSTRUCTOR_ID = 0xbc0a57dc
    SUBCLASS_OF_ID = 0x55a53079

    def __init__(self, url, set):
        """
        :param str url:
        :param TypeStickerSetCovered set:

        Constructor for RecentMeUrl: Instance of either RecentMeUrlUnknown, RecentMeUrlUser, RecentMeUrlChat, RecentMeUrlChatInvite, RecentMeUrlStickerSet.
        """
        self.url = url  # type: str
        self.set = set  # type: TypeStickerSetCovered

    def to_dict(self):
        return {
            '_': 'RecentMeUrlStickerSet',
            'url': self.url,
            'set': None if self.set is None else self.set.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\xdcW\n\xbc',
            self.serialize_bytes(self.url),
            bytes(self.set),
        ))

    @classmethod
    def from_reader(cls, reader):
        _url = reader.tgread_string()
        _set = reader.tgread_object()
        return cls(url=_url, set=_set)


class RecentMeUrlUnknown(TLObject):
    CONSTRUCTOR_ID = 0x46e1d13d
    SUBCLASS_OF_ID = 0x55a53079

    def __init__(self, url):
        """
        :param str url:

        Constructor for RecentMeUrl: Instance of either RecentMeUrlUnknown, RecentMeUrlUser, RecentMeUrlChat, RecentMeUrlChatInvite, RecentMeUrlStickerSet.
        """
        self.url = url  # type: str

    def to_dict(self):
        return {
            '_': 'RecentMeUrlUnknown',
            'url': self.url
        }

    def __bytes__(self):
        return b''.join((
            b'=\xd1\xe1F',
            self.serialize_bytes(self.url),
        ))

    @classmethod
    def from_reader(cls, reader):
        _url = reader.tgread_string()
        return cls(url=_url)


class RecentMeUrlUser(TLObject):
    CONSTRUCTOR_ID = 0x8dbc3336
    SUBCLASS_OF_ID = 0x55a53079

    def __init__(self, url, user_id):
        """
        :param str url:
        :param int user_id:

        Constructor for RecentMeUrl: Instance of either RecentMeUrlUnknown, RecentMeUrlUser, RecentMeUrlChat, RecentMeUrlChatInvite, RecentMeUrlStickerSet.
        """
        self.url = url  # type: str
        self.user_id = user_id  # type: int

    def to_dict(self):
        return {
            '_': 'RecentMeUrlUser',
            'url': self.url,
            'user_id': self.user_id
        }

    def __bytes__(self):
        return b''.join((
            b'63\xbc\x8d',
            self.serialize_bytes(self.url),
            struct.pack('<i', self.user_id),
        ))

    @classmethod
    def from_reader(cls, reader):
        _url = reader.tgread_string()
        _user_id = reader.read_int()
        return cls(url=_url, user_id=_user_id)


class ReplyInlineMarkup(TLObject):
    CONSTRUCTOR_ID = 0x48a30254
    SUBCLASS_OF_ID = 0xe2e10ef2

    def __init__(self, rows):
        """
        :param List[TypeKeyboardButtonRow] rows:

        Constructor for ReplyMarkup: Instance of either ReplyKeyboardHide, ReplyKeyboardForceReply, ReplyKeyboardMarkup, ReplyInlineMarkup.
        """
        self.rows = rows  # type: List[TypeKeyboardButtonRow]

    def to_dict(self):
        return {
            '_': 'ReplyInlineMarkup',
            'rows': [] if self.rows is None else [None if x is None else x.to_dict() for x in self.rows]
        }

    def __bytes__(self):
        return b''.join((
            b'T\x02\xa3H',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.rows)),b''.join(bytes(x) for x in self.rows),
        ))

    @classmethod
    def from_reader(cls, reader):
        reader.read_int()
        _rows = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _rows.append(_x)

        return cls(rows=_rows)


class ReplyKeyboardForceReply(TLObject):
    CONSTRUCTOR_ID = 0xf4108aa0
    SUBCLASS_OF_ID = 0xe2e10ef2

    def __init__(self, single_use=None, selective=None):
        """
        :param Optional[bool] single_use:
        :param Optional[bool] selective:

        Constructor for ReplyMarkup: Instance of either ReplyKeyboardHide, ReplyKeyboardForceReply, ReplyKeyboardMarkup, ReplyInlineMarkup.
        """
        self.single_use = single_use  # type: Optional[bool]
        self.selective = selective  # type: Optional[bool]

    def to_dict(self):
        return {
            '_': 'ReplyKeyboardForceReply',
            'single_use': self.single_use,
            'selective': self.selective
        }

    def __bytes__(self):
        return b''.join((
            b'\xa0\x8a\x10\xf4',
            struct.pack('<I', (0 if self.single_use is None or self.single_use is False else 2) | (0 if self.selective is None or self.selective is False else 4)),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _single_use = bool(flags & 2)
        _selective = bool(flags & 4)
        return cls(single_use=_single_use, selective=_selective)


class ReplyKeyboardHide(TLObject):
    CONSTRUCTOR_ID = 0xa03e5b85
    SUBCLASS_OF_ID = 0xe2e10ef2

    def __init__(self, selective=None):
        """
        :param Optional[bool] selective:

        Constructor for ReplyMarkup: Instance of either ReplyKeyboardHide, ReplyKeyboardForceReply, ReplyKeyboardMarkup, ReplyInlineMarkup.
        """
        self.selective = selective  # type: Optional[bool]

    def to_dict(self):
        return {
            '_': 'ReplyKeyboardHide',
            'selective': self.selective
        }

    def __bytes__(self):
        return b''.join((
            b'\x85[>\xa0',
            struct.pack('<I', (0 if self.selective is None or self.selective is False else 4)),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _selective = bool(flags & 4)
        return cls(selective=_selective)


class ReplyKeyboardMarkup(TLObject):
    CONSTRUCTOR_ID = 0x3502758c
    SUBCLASS_OF_ID = 0xe2e10ef2

    def __init__(self, rows, resize=None, single_use=None, selective=None):
        """
        :param List[TypeKeyboardButtonRow] rows:
        :param Optional[bool] resize:
        :param Optional[bool] single_use:
        :param Optional[bool] selective:

        Constructor for ReplyMarkup: Instance of either ReplyKeyboardHide, ReplyKeyboardForceReply, ReplyKeyboardMarkup, ReplyInlineMarkup.
        """
        self.rows = rows  # type: List[TypeKeyboardButtonRow]
        self.resize = resize  # type: Optional[bool]
        self.single_use = single_use  # type: Optional[bool]
        self.selective = selective  # type: Optional[bool]

    def to_dict(self):
        return {
            '_': 'ReplyKeyboardMarkup',
            'rows': [] if self.rows is None else [None if x is None else x.to_dict() for x in self.rows],
            'resize': self.resize,
            'single_use': self.single_use,
            'selective': self.selective
        }

    def __bytes__(self):
        return b''.join((
            b'\x8cu\x025',
            struct.pack('<I', (0 if self.resize is None or self.resize is False else 1) | (0 if self.single_use is None or self.single_use is False else 2) | (0 if self.selective is None or self.selective is False else 4)),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.rows)),b''.join(bytes(x) for x in self.rows),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _resize = bool(flags & 1)
        _single_use = bool(flags & 2)
        _selective = bool(flags & 4)
        reader.read_int()
        _rows = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _rows.append(_x)

        return cls(rows=_rows, resize=_resize, single_use=_single_use, selective=_selective)


class ResPQ(TLObject):
    CONSTRUCTOR_ID = 0x5162463
    SUBCLASS_OF_ID = 0x786986b8

    def __init__(self, nonce, server_nonce, pq, server_public_key_fingerprints):
        """
        :param int nonce:
        :param int server_nonce:
        :param bytes pq:
        :param List[int] server_public_key_fingerprints:

        Constructor for ResPQ: Instance of ResPQ.
        """
        self.nonce = nonce  # type: int
        self.server_nonce = server_nonce  # type: int
        self.pq = pq  # type: bytes
        self.server_public_key_fingerprints = server_public_key_fingerprints  # type: List[int]

    def to_dict(self):
        return {
            '_': 'ResPQ',
            'nonce': self.nonce,
            'server_nonce': self.server_nonce,
            'pq': self.pq,
            'server_public_key_fingerprints': [] if self.server_public_key_fingerprints is None else self.server_public_key_fingerprints[:]
        }

    def __bytes__(self):
        return b''.join((
            b'c$\x16\x05',
            self.nonce.to_bytes(16, 'little', signed=True),
            self.server_nonce.to_bytes(16, 'little', signed=True),
            self.serialize_bytes(self.pq),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.server_public_key_fingerprints)),b''.join(struct.pack('<q', x) for x in self.server_public_key_fingerprints),
        ))

    @classmethod
    def from_reader(cls, reader):
        _nonce = reader.read_large_int(bits=128)
        _server_nonce = reader.read_large_int(bits=128)
        _pq = reader.tgread_bytes()
        reader.read_int()
        _server_public_key_fingerprints = []
        for _ in range(reader.read_int()):
            _x = reader.read_long()
            _server_public_key_fingerprints.append(_x)

        return cls(nonce=_nonce, server_nonce=_server_nonce, pq=_pq, server_public_key_fingerprints=_server_public_key_fingerprints)


class RpcAnswerDropped(TLObject):
    CONSTRUCTOR_ID = 0xa43ad8b7
    SUBCLASS_OF_ID = 0x4bca7570

    def __init__(self, msg_id, seq_no, bytes):
        """
        :param int msg_id:
        :param int seq_no:
        :param int bytes:

        Constructor for RpcDropAnswer: Instance of either RpcAnswerUnknown, RpcAnswerDroppedRunning, RpcAnswerDropped.
        """
        self.msg_id = msg_id  # type: int
        self.seq_no = seq_no  # type: int
        self.bytes = bytes  # type: int

    def to_dict(self):
        return {
            '_': 'RpcAnswerDropped',
            'msg_id': self.msg_id,
            'seq_no': self.seq_no,
            'bytes': self.bytes
        }

    def __bytes__(self):
        return b''.join((
            b'\xb7\xd8:\xa4',
            struct.pack('<q', self.msg_id),
            struct.pack('<i', self.seq_no),
            struct.pack('<i', self.bytes),
        ))

    @classmethod
    def from_reader(cls, reader):
        _msg_id = reader.read_long()
        _seq_no = reader.read_int()
        _bytes = reader.read_int()
        return cls(msg_id=_msg_id, seq_no=_seq_no, bytes=_bytes)


class RpcAnswerDroppedRunning(TLObject):
    CONSTRUCTOR_ID = 0xcd78e586
    SUBCLASS_OF_ID = 0x4bca7570

    def to_dict(self):
        return {
            '_': 'RpcAnswerDroppedRunning'
        }

    def __bytes__(self):
        return b''.join((
            b'\x86\xe5x\xcd',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class RpcAnswerUnknown(TLObject):
    CONSTRUCTOR_ID = 0x5e2ad36e
    SUBCLASS_OF_ID = 0x4bca7570

    def to_dict(self):
        return {
            '_': 'RpcAnswerUnknown'
        }

    def __bytes__(self):
        return b''.join((
            b'n\xd3*^',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class RpcError(TLObject):
    CONSTRUCTOR_ID = 0x2144ca19
    SUBCLASS_OF_ID = 0x4a17e265

    def __init__(self, error_code, error_message):
        """
        :param int error_code:
        :param str error_message:

        Constructor for RpcError: Instance of RpcError.
        """
        self.error_code = error_code  # type: int
        self.error_message = error_message  # type: str

    def to_dict(self):
        return {
            '_': 'RpcError',
            'error_code': self.error_code,
            'error_message': self.error_message
        }

    def __bytes__(self):
        return b''.join((
            b'\x19\xcaD!',
            struct.pack('<i', self.error_code),
            self.serialize_bytes(self.error_message),
        ))

    @classmethod
    def from_reader(cls, reader):
        _error_code = reader.read_int()
        _error_message = reader.tgread_string()
        return cls(error_code=_error_code, error_message=_error_message)


class RsaPublicKey(TLObject):
    CONSTRUCTOR_ID = 0x7a19cb76
    SUBCLASS_OF_ID = 0x3e61e0a2

    def __init__(self, n, e):
        """
        :param str n:
        :param bytes e:

        Constructor for RSAPublicKey: Instance of RsaPublicKey.
        """
        self.n = n  # type: str
        self.e = e  # type: bytes

    def to_dict(self):
        return {
            '_': 'RsaPublicKey',
            'n': self.n,
            'e': self.e
        }

    def __bytes__(self):
        return b''.join((
            b'v\xcb\x19z',
            self.serialize_bytes(self.n),
            self.serialize_bytes(self.e),
        ))

    @classmethod
    def from_reader(cls, reader):
        _n = reader.tgread_string()
        _e = reader.tgread_bytes()
        return cls(n=_n, e=_e)


class SavedPhoneContact(TLObject):
    CONSTRUCTOR_ID = 0x1142bd56
    SUBCLASS_OF_ID = 0x6db98c4

    def __init__(self, phone, first_name, last_name, date):
        """
        :param str phone:
        :param str first_name:
        :param str last_name:
        :param Optional[datetime] date:

        Constructor for SavedContact: Instance of SavedPhoneContact.
        """
        self.phone = phone  # type: str
        self.first_name = first_name  # type: str
        self.last_name = last_name  # type: str
        self.date = date  # type: Optional[datetime]

    def to_dict(self):
        return {
            '_': 'SavedPhoneContact',
            'phone': self.phone,
            'first_name': self.first_name,
            'last_name': self.last_name,
            'date': self.date
        }

    def __bytes__(self):
        return b''.join((
            b'V\xbdB\x11',
            self.serialize_bytes(self.phone),
            self.serialize_bytes(self.first_name),
            self.serialize_bytes(self.last_name),
            self.serialize_datetime(self.date),
        ))

    @classmethod
    def from_reader(cls, reader):
        _phone = reader.tgread_string()
        _first_name = reader.tgread_string()
        _last_name = reader.tgread_string()
        _date = reader.tgread_date()
        return cls(phone=_phone, first_name=_first_name, last_name=_last_name, date=_date)


class SecureCredentialsEncrypted(TLObject):
    CONSTRUCTOR_ID = 0x33f0ea47
    SUBCLASS_OF_ID = 0x94dc7633

    def __init__(self, data, hash, secret):
        """
        :param bytes data:
        :param bytes hash:
        :param bytes secret:

        Constructor for SecureCredentialsEncrypted: Instance of SecureCredentialsEncrypted.
        """
        self.data = data  # type: bytes
        self.hash = hash  # type: bytes
        self.secret = secret  # type: bytes

    def to_dict(self):
        return {
            '_': 'SecureCredentialsEncrypted',
            'data': self.data,
            'hash': self.hash,
            'secret': self.secret
        }

    def __bytes__(self):
        return b''.join((
            b'G\xea\xf03',
            self.serialize_bytes(self.data),
            self.serialize_bytes(self.hash),
            self.serialize_bytes(self.secret),
        ))

    @classmethod
    def from_reader(cls, reader):
        _data = reader.tgread_bytes()
        _hash = reader.tgread_bytes()
        _secret = reader.tgread_bytes()
        return cls(data=_data, hash=_hash, secret=_secret)


class SecureData(TLObject):
    CONSTRUCTOR_ID = 0x8aeabec3
    SUBCLASS_OF_ID = 0x7cd41eb4

    def __init__(self, data, data_hash, secret):
        """
        :param bytes data:
        :param bytes data_hash:
        :param bytes secret:

        Constructor for SecureData: Instance of SecureData.
        """
        self.data = data  # type: bytes
        self.data_hash = data_hash  # type: bytes
        self.secret = secret  # type: bytes

    def to_dict(self):
        return {
            '_': 'SecureData',
            'data': self.data,
            'data_hash': self.data_hash,
            'secret': self.secret
        }

    def __bytes__(self):
        return b''.join((
            b'\xc3\xbe\xea\x8a',
            self.serialize_bytes(self.data),
            self.serialize_bytes(self.data_hash),
            self.serialize_bytes(self.secret),
        ))

    @classmethod
    def from_reader(cls, reader):
        _data = reader.tgread_bytes()
        _data_hash = reader.tgread_bytes()
        _secret = reader.tgread_bytes()
        return cls(data=_data, data_hash=_data_hash, secret=_secret)


class SecureFile(TLObject):
    CONSTRUCTOR_ID = 0xe0277a62
    SUBCLASS_OF_ID = 0x5db8dbc7

    def __init__(self, id, access_hash, size, dc_id, date, file_hash, secret):
        """
        :param int id:
        :param int access_hash:
        :param int size:
        :param int dc_id:
        :param Optional[datetime] date:
        :param bytes file_hash:
        :param bytes secret:

        Constructor for SecureFile: Instance of either SecureFileEmpty, SecureFile.
        """
        self.id = id  # type: int
        self.access_hash = access_hash  # type: int
        self.size = size  # type: int
        self.dc_id = dc_id  # type: int
        self.date = date  # type: Optional[datetime]
        self.file_hash = file_hash  # type: bytes
        self.secret = secret  # type: bytes

    def to_dict(self):
        return {
            '_': 'SecureFile',
            'id': self.id,
            'access_hash': self.access_hash,
            'size': self.size,
            'dc_id': self.dc_id,
            'date': self.date,
            'file_hash': self.file_hash,
            'secret': self.secret
        }

    def __bytes__(self):
        return b''.join((
            b"bz'\xe0",
            struct.pack('<q', self.id),
            struct.pack('<q', self.access_hash),
            struct.pack('<i', self.size),
            struct.pack('<i', self.dc_id),
            self.serialize_datetime(self.date),
            self.serialize_bytes(self.file_hash),
            self.serialize_bytes(self.secret),
        ))

    @classmethod
    def from_reader(cls, reader):
        _id = reader.read_long()
        _access_hash = reader.read_long()
        _size = reader.read_int()
        _dc_id = reader.read_int()
        _date = reader.tgread_date()
        _file_hash = reader.tgread_bytes()
        _secret = reader.tgread_bytes()
        return cls(id=_id, access_hash=_access_hash, size=_size, dc_id=_dc_id, date=_date, file_hash=_file_hash, secret=_secret)


class SecureFileEmpty(TLObject):
    CONSTRUCTOR_ID = 0x64199744
    SUBCLASS_OF_ID = 0x5db8dbc7

    def to_dict(self):
        return {
            '_': 'SecureFileEmpty'
        }

    def __bytes__(self):
        return b''.join((
            b'D\x97\x19d',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class SecurePlainEmail(TLObject):
    CONSTRUCTOR_ID = 0x21ec5a5f
    SUBCLASS_OF_ID = 0x23b2afb6

    def __init__(self, email):
        """
        :param str email:

        Constructor for SecurePlainData: Instance of either SecurePlainPhone, SecurePlainEmail.
        """
        self.email = email  # type: str

    def to_dict(self):
        return {
            '_': 'SecurePlainEmail',
            'email': self.email
        }

    def __bytes__(self):
        return b''.join((
            b'_Z\xec!',
            self.serialize_bytes(self.email),
        ))

    @classmethod
    def from_reader(cls, reader):
        _email = reader.tgread_string()
        return cls(email=_email)


class SecurePlainPhone(TLObject):
    CONSTRUCTOR_ID = 0x7d6099dd
    SUBCLASS_OF_ID = 0x23b2afb6

    def __init__(self, phone):
        """
        :param str phone:

        Constructor for SecurePlainData: Instance of either SecurePlainPhone, SecurePlainEmail.
        """
        self.phone = phone  # type: str

    def to_dict(self):
        return {
            '_': 'SecurePlainPhone',
            'phone': self.phone
        }

    def __bytes__(self):
        return b''.join((
            b'\xdd\x99`}',
            self.serialize_bytes(self.phone),
        ))

    @classmethod
    def from_reader(cls, reader):
        _phone = reader.tgread_string()
        return cls(phone=_phone)


class SecureValue(TLObject):
    CONSTRUCTOR_ID = 0xb4b4b699
    SUBCLASS_OF_ID = 0x51138ae

    def __init__(self, type, hash, data=None, front_side=None, reverse_side=None, selfie=None, files=None, plain_data=None):
        """
        :param TypeSecureValueType type:
        :param bytes hash:
        :param Optional[TypeSecureData] data:
        :param Optional[TypeSecureFile] front_side:
        :param Optional[TypeSecureFile] reverse_side:
        :param Optional[TypeSecureFile] selfie:
        :param Optional[List[TypeSecureFile]] files:
        :param Optional[TypeSecurePlainData] plain_data:

        Constructor for SecureValue: Instance of SecureValue.
        """
        self.type = type  # type: TypeSecureValueType
        self.hash = hash  # type: bytes
        self.data = data  # type: Optional[TypeSecureData]
        self.front_side = front_side  # type: Optional[TypeSecureFile]
        self.reverse_side = reverse_side  # type: Optional[TypeSecureFile]
        self.selfie = selfie  # type: Optional[TypeSecureFile]
        self.files = files  # type: Optional[List[TypeSecureFile]]
        self.plain_data = plain_data  # type: Optional[TypeSecurePlainData]

    def to_dict(self):
        return {
            '_': 'SecureValue',
            'type': None if self.type is None else self.type.to_dict(),
            'hash': self.hash,
            'data': None if self.data is None else self.data.to_dict(),
            'front_side': None if self.front_side is None else self.front_side.to_dict(),
            'reverse_side': None if self.reverse_side is None else self.reverse_side.to_dict(),
            'selfie': None if self.selfie is None else self.selfie.to_dict(),
            'files': [] if self.files is None else [None if x is None else x.to_dict() for x in self.files],
            'plain_data': None if self.plain_data is None else self.plain_data.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\x99\xb6\xb4\xb4',
            struct.pack('<I', (0 if self.data is None or self.data is False else 1) | (0 if self.front_side is None or self.front_side is False else 2) | (0 if self.reverse_side is None or self.reverse_side is False else 4) | (0 if self.selfie is None or self.selfie is False else 8) | (0 if self.files is None or self.files is False else 16) | (0 if self.plain_data is None or self.plain_data is False else 32)),
            bytes(self.type),
            b'' if self.data is None or self.data is False else (bytes(self.data)),
            b'' if self.front_side is None or self.front_side is False else (bytes(self.front_side)),
            b'' if self.reverse_side is None or self.reverse_side is False else (bytes(self.reverse_side)),
            b'' if self.selfie is None or self.selfie is False else (bytes(self.selfie)),
            b'' if self.files is None or self.files is False else b''.join((b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.files)),b''.join(bytes(x) for x in self.files))),
            b'' if self.plain_data is None or self.plain_data is False else (bytes(self.plain_data)),
            self.serialize_bytes(self.hash),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _type = reader.tgread_object()
        if flags & 1:
            _data = reader.tgread_object()
        else:
            _data = None
        if flags & 2:
            _front_side = reader.tgread_object()
        else:
            _front_side = None
        if flags & 4:
            _reverse_side = reader.tgread_object()
        else:
            _reverse_side = None
        if flags & 8:
            _selfie = reader.tgread_object()
        else:
            _selfie = None
        if flags & 16:
            reader.read_int()
            _files = []
            for _ in range(reader.read_int()):
                _x = reader.tgread_object()
                _files.append(_x)

        else:
            _files = None
        if flags & 32:
            _plain_data = reader.tgread_object()
        else:
            _plain_data = None
        _hash = reader.tgread_bytes()
        return cls(type=_type, hash=_hash, data=_data, front_side=_front_side, reverse_side=_reverse_side, selfie=_selfie, files=_files, plain_data=_plain_data)


class SecureValueErrorData(TLObject):
    CONSTRUCTOR_ID = 0xe8a40bd9
    SUBCLASS_OF_ID = 0x6075fce

    def __init__(self, type, data_hash, field, text):
        """
        :param TypeSecureValueType type:
        :param bytes data_hash:
        :param str field:
        :param str text:

        Constructor for SecureValueError: Instance of either SecureValueErrorData, SecureValueErrorFrontSide, SecureValueErrorReverseSide, SecureValueErrorSelfie, SecureValueErrorFile, SecureValueErrorFiles.
        """
        self.type = type  # type: TypeSecureValueType
        self.data_hash = data_hash  # type: bytes
        self.field = field  # type: str
        self.text = text  # type: str

    def to_dict(self):
        return {
            '_': 'SecureValueErrorData',
            'type': None if self.type is None else self.type.to_dict(),
            'data_hash': self.data_hash,
            'field': self.field,
            'text': self.text
        }

    def __bytes__(self):
        return b''.join((
            b'\xd9\x0b\xa4\xe8',
            bytes(self.type),
            self.serialize_bytes(self.data_hash),
            self.serialize_bytes(self.field),
            self.serialize_bytes(self.text),
        ))

    @classmethod
    def from_reader(cls, reader):
        _type = reader.tgread_object()
        _data_hash = reader.tgread_bytes()
        _field = reader.tgread_string()
        _text = reader.tgread_string()
        return cls(type=_type, data_hash=_data_hash, field=_field, text=_text)


class SecureValueErrorFile(TLObject):
    CONSTRUCTOR_ID = 0x7a700873
    SUBCLASS_OF_ID = 0x6075fce

    def __init__(self, type, file_hash, text):
        """
        :param TypeSecureValueType type:
        :param bytes file_hash:
        :param str text:

        Constructor for SecureValueError: Instance of either SecureValueErrorData, SecureValueErrorFrontSide, SecureValueErrorReverseSide, SecureValueErrorSelfie, SecureValueErrorFile, SecureValueErrorFiles.
        """
        self.type = type  # type: TypeSecureValueType
        self.file_hash = file_hash  # type: bytes
        self.text = text  # type: str

    def to_dict(self):
        return {
            '_': 'SecureValueErrorFile',
            'type': None if self.type is None else self.type.to_dict(),
            'file_hash': self.file_hash,
            'text': self.text
        }

    def __bytes__(self):
        return b''.join((
            b's\x08pz',
            bytes(self.type),
            self.serialize_bytes(self.file_hash),
            self.serialize_bytes(self.text),
        ))

    @classmethod
    def from_reader(cls, reader):
        _type = reader.tgread_object()
        _file_hash = reader.tgread_bytes()
        _text = reader.tgread_string()
        return cls(type=_type, file_hash=_file_hash, text=_text)


class SecureValueErrorFiles(TLObject):
    CONSTRUCTOR_ID = 0x666220e9
    SUBCLASS_OF_ID = 0x6075fce

    def __init__(self, type, file_hash, text):
        """
        :param TypeSecureValueType type:
        :param List[bytes] file_hash:
        :param str text:

        Constructor for SecureValueError: Instance of either SecureValueErrorData, SecureValueErrorFrontSide, SecureValueErrorReverseSide, SecureValueErrorSelfie, SecureValueErrorFile, SecureValueErrorFiles.
        """
        self.type = type  # type: TypeSecureValueType
        self.file_hash = file_hash  # type: List[bytes]
        self.text = text  # type: str

    def to_dict(self):
        return {
            '_': 'SecureValueErrorFiles',
            'type': None if self.type is None else self.type.to_dict(),
            'file_hash': [] if self.file_hash is None else self.file_hash[:],
            'text': self.text
        }

    def __bytes__(self):
        return b''.join((
            b'\xe9 bf',
            bytes(self.type),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.file_hash)),b''.join(self.serialize_bytes(x) for x in self.file_hash),
            self.serialize_bytes(self.text),
        ))

    @classmethod
    def from_reader(cls, reader):
        _type = reader.tgread_object()
        reader.read_int()
        _file_hash = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_bytes()
            _file_hash.append(_x)

        _text = reader.tgread_string()
        return cls(type=_type, file_hash=_file_hash, text=_text)


class SecureValueErrorFrontSide(TLObject):
    CONSTRUCTOR_ID = 0xbe3dfa
    SUBCLASS_OF_ID = 0x6075fce

    def __init__(self, type, file_hash, text):
        """
        :param TypeSecureValueType type:
        :param bytes file_hash:
        :param str text:

        Constructor for SecureValueError: Instance of either SecureValueErrorData, SecureValueErrorFrontSide, SecureValueErrorReverseSide, SecureValueErrorSelfie, SecureValueErrorFile, SecureValueErrorFiles.
        """
        self.type = type  # type: TypeSecureValueType
        self.file_hash = file_hash  # type: bytes
        self.text = text  # type: str

    def to_dict(self):
        return {
            '_': 'SecureValueErrorFrontSide',
            'type': None if self.type is None else self.type.to_dict(),
            'file_hash': self.file_hash,
            'text': self.text
        }

    def __bytes__(self):
        return b''.join((
            b'\xfa=\xbe\x00',
            bytes(self.type),
            self.serialize_bytes(self.file_hash),
            self.serialize_bytes(self.text),
        ))

    @classmethod
    def from_reader(cls, reader):
        _type = reader.tgread_object()
        _file_hash = reader.tgread_bytes()
        _text = reader.tgread_string()
        return cls(type=_type, file_hash=_file_hash, text=_text)


class SecureValueErrorReverseSide(TLObject):
    CONSTRUCTOR_ID = 0x868a2aa5
    SUBCLASS_OF_ID = 0x6075fce

    def __init__(self, type, file_hash, text):
        """
        :param TypeSecureValueType type:
        :param bytes file_hash:
        :param str text:

        Constructor for SecureValueError: Instance of either SecureValueErrorData, SecureValueErrorFrontSide, SecureValueErrorReverseSide, SecureValueErrorSelfie, SecureValueErrorFile, SecureValueErrorFiles.
        """
        self.type = type  # type: TypeSecureValueType
        self.file_hash = file_hash  # type: bytes
        self.text = text  # type: str

    def to_dict(self):
        return {
            '_': 'SecureValueErrorReverseSide',
            'type': None if self.type is None else self.type.to_dict(),
            'file_hash': self.file_hash,
            'text': self.text
        }

    def __bytes__(self):
        return b''.join((
            b'\xa5*\x8a\x86',
            bytes(self.type),
            self.serialize_bytes(self.file_hash),
            self.serialize_bytes(self.text),
        ))

    @classmethod
    def from_reader(cls, reader):
        _type = reader.tgread_object()
        _file_hash = reader.tgread_bytes()
        _text = reader.tgread_string()
        return cls(type=_type, file_hash=_file_hash, text=_text)


class SecureValueErrorSelfie(TLObject):
    CONSTRUCTOR_ID = 0xe537ced6
    SUBCLASS_OF_ID = 0x6075fce

    def __init__(self, type, file_hash, text):
        """
        :param TypeSecureValueType type:
        :param bytes file_hash:
        :param str text:

        Constructor for SecureValueError: Instance of either SecureValueErrorData, SecureValueErrorFrontSide, SecureValueErrorReverseSide, SecureValueErrorSelfie, SecureValueErrorFile, SecureValueErrorFiles.
        """
        self.type = type  # type: TypeSecureValueType
        self.file_hash = file_hash  # type: bytes
        self.text = text  # type: str

    def to_dict(self):
        return {
            '_': 'SecureValueErrorSelfie',
            'type': None if self.type is None else self.type.to_dict(),
            'file_hash': self.file_hash,
            'text': self.text
        }

    def __bytes__(self):
        return b''.join((
            b'\xd6\xce7\xe5',
            bytes(self.type),
            self.serialize_bytes(self.file_hash),
            self.serialize_bytes(self.text),
        ))

    @classmethod
    def from_reader(cls, reader):
        _type = reader.tgread_object()
        _file_hash = reader.tgread_bytes()
        _text = reader.tgread_string()
        return cls(type=_type, file_hash=_file_hash, text=_text)


class SecureValueHash(TLObject):
    CONSTRUCTOR_ID = 0xed1ecdb0
    SUBCLASS_OF_ID = 0xd5f5c007

    def __init__(self, type, hash):
        """
        :param TypeSecureValueType type:
        :param bytes hash:

        Constructor for SecureValueHash: Instance of SecureValueHash.
        """
        self.type = type  # type: TypeSecureValueType
        self.hash = hash  # type: bytes

    def to_dict(self):
        return {
            '_': 'SecureValueHash',
            'type': None if self.type is None else self.type.to_dict(),
            'hash': self.hash
        }

    def __bytes__(self):
        return b''.join((
            b'\xb0\xcd\x1e\xed',
            bytes(self.type),
            self.serialize_bytes(self.hash),
        ))

    @classmethod
    def from_reader(cls, reader):
        _type = reader.tgread_object()
        _hash = reader.tgread_bytes()
        return cls(type=_type, hash=_hash)


class SecureValueTypeAddress(TLObject):
    CONSTRUCTOR_ID = 0xcbe31e26
    SUBCLASS_OF_ID = 0x8893f596

    def to_dict(self):
        return {
            '_': 'SecureValueTypeAddress'
        }

    def __bytes__(self):
        return b''.join((
            b'&\x1e\xe3\xcb',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class SecureValueTypeBankStatement(TLObject):
    CONSTRUCTOR_ID = 0x89137c0d
    SUBCLASS_OF_ID = 0x8893f596

    def to_dict(self):
        return {
            '_': 'SecureValueTypeBankStatement'
        }

    def __bytes__(self):
        return b''.join((
            b'\r|\x13\x89',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class SecureValueTypeDriverLicense(TLObject):
    CONSTRUCTOR_ID = 0x6e425c4
    SUBCLASS_OF_ID = 0x8893f596

    def to_dict(self):
        return {
            '_': 'SecureValueTypeDriverLicense'
        }

    def __bytes__(self):
        return b''.join((
            b'\xc4%\xe4\x06',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class SecureValueTypeEmail(TLObject):
    CONSTRUCTOR_ID = 0x8e3ca7ee
    SUBCLASS_OF_ID = 0x8893f596

    def to_dict(self):
        return {
            '_': 'SecureValueTypeEmail'
        }

    def __bytes__(self):
        return b''.join((
            b'\xee\xa7<\x8e',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class SecureValueTypeIdentityCard(TLObject):
    CONSTRUCTOR_ID = 0xa0d0744b
    SUBCLASS_OF_ID = 0x8893f596

    def to_dict(self):
        return {
            '_': 'SecureValueTypeIdentityCard'
        }

    def __bytes__(self):
        return b''.join((
            b'Kt\xd0\xa0',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class SecureValueTypeInternalPassport(TLObject):
    CONSTRUCTOR_ID = 0x99a48f23
    SUBCLASS_OF_ID = 0x8893f596

    def to_dict(self):
        return {
            '_': 'SecureValueTypeInternalPassport'
        }

    def __bytes__(self):
        return b''.join((
            b'#\x8f\xa4\x99',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class SecureValueTypePassport(TLObject):
    CONSTRUCTOR_ID = 0x3dac6a00
    SUBCLASS_OF_ID = 0x8893f596

    def to_dict(self):
        return {
            '_': 'SecureValueTypePassport'
        }

    def __bytes__(self):
        return b''.join((
            b'\x00j\xac=',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class SecureValueTypePassportRegistration(TLObject):
    CONSTRUCTOR_ID = 0x99e3806a
    SUBCLASS_OF_ID = 0x8893f596

    def to_dict(self):
        return {
            '_': 'SecureValueTypePassportRegistration'
        }

    def __bytes__(self):
        return b''.join((
            b'j\x80\xe3\x99',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class SecureValueTypePersonalDetails(TLObject):
    CONSTRUCTOR_ID = 0x9d2a81e3
    SUBCLASS_OF_ID = 0x8893f596

    def to_dict(self):
        return {
            '_': 'SecureValueTypePersonalDetails'
        }

    def __bytes__(self):
        return b''.join((
            b'\xe3\x81*\x9d',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class SecureValueTypePhone(TLObject):
    CONSTRUCTOR_ID = 0xb320aadb
    SUBCLASS_OF_ID = 0x8893f596

    def to_dict(self):
        return {
            '_': 'SecureValueTypePhone'
        }

    def __bytes__(self):
        return b''.join((
            b'\xdb\xaa \xb3',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class SecureValueTypeRentalAgreement(TLObject):
    CONSTRUCTOR_ID = 0x8b883488
    SUBCLASS_OF_ID = 0x8893f596

    def to_dict(self):
        return {
            '_': 'SecureValueTypeRentalAgreement'
        }

    def __bytes__(self):
        return b''.join((
            b'\x884\x88\x8b',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class SecureValueTypeTemporaryRegistration(TLObject):
    CONSTRUCTOR_ID = 0xea02ec33
    SUBCLASS_OF_ID = 0x8893f596

    def to_dict(self):
        return {
            '_': 'SecureValueTypeTemporaryRegistration'
        }

    def __bytes__(self):
        return b''.join((
            b'3\xec\x02\xea',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class SecureValueTypeUtilityBill(TLObject):
    CONSTRUCTOR_ID = 0xfc36954e
    SUBCLASS_OF_ID = 0x8893f596

    def to_dict(self):
        return {
            '_': 'SecureValueTypeUtilityBill'
        }

    def __bytes__(self):
        return b''.join((
            b'N\x956\xfc',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class SendMessageCancelAction(TLObject):
    CONSTRUCTOR_ID = 0xfd5ec8f5
    SUBCLASS_OF_ID = 0x20b2cc21

    def to_dict(self):
        return {
            '_': 'SendMessageCancelAction'
        }

    def __bytes__(self):
        return b''.join((
            b'\xf5\xc8^\xfd',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class SendMessageChooseContactAction(TLObject):
    CONSTRUCTOR_ID = 0x628cbc6f
    SUBCLASS_OF_ID = 0x20b2cc21

    def to_dict(self):
        return {
            '_': 'SendMessageChooseContactAction'
        }

    def __bytes__(self):
        return b''.join((
            b'o\xbc\x8cb',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class SendMessageGamePlayAction(TLObject):
    CONSTRUCTOR_ID = 0xdd6a8f48
    SUBCLASS_OF_ID = 0x20b2cc21

    def to_dict(self):
        return {
            '_': 'SendMessageGamePlayAction'
        }

    def __bytes__(self):
        return b''.join((
            b'H\x8fj\xdd',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class SendMessageGeoLocationAction(TLObject):
    CONSTRUCTOR_ID = 0x176f8ba1
    SUBCLASS_OF_ID = 0x20b2cc21

    def to_dict(self):
        return {
            '_': 'SendMessageGeoLocationAction'
        }

    def __bytes__(self):
        return b''.join((
            b'\xa1\x8bo\x17',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class SendMessageRecordAudioAction(TLObject):
    CONSTRUCTOR_ID = 0xd52f73f7
    SUBCLASS_OF_ID = 0x20b2cc21

    def to_dict(self):
        return {
            '_': 'SendMessageRecordAudioAction'
        }

    def __bytes__(self):
        return b''.join((
            b'\xf7s/\xd5',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class SendMessageRecordRoundAction(TLObject):
    CONSTRUCTOR_ID = 0x88f27fbc
    SUBCLASS_OF_ID = 0x20b2cc21

    def to_dict(self):
        return {
            '_': 'SendMessageRecordRoundAction'
        }

    def __bytes__(self):
        return b''.join((
            b'\xbc\x7f\xf2\x88',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class SendMessageRecordVideoAction(TLObject):
    CONSTRUCTOR_ID = 0xa187d66f
    SUBCLASS_OF_ID = 0x20b2cc21

    def to_dict(self):
        return {
            '_': 'SendMessageRecordVideoAction'
        }

    def __bytes__(self):
        return b''.join((
            b'o\xd6\x87\xa1',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class SendMessageTypingAction(TLObject):
    CONSTRUCTOR_ID = 0x16bf744e
    SUBCLASS_OF_ID = 0x20b2cc21

    def to_dict(self):
        return {
            '_': 'SendMessageTypingAction'
        }

    def __bytes__(self):
        return b''.join((
            b'Nt\xbf\x16',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class SendMessageUploadAudioAction(TLObject):
    CONSTRUCTOR_ID = 0xf351d7ab
    SUBCLASS_OF_ID = 0x20b2cc21

    def __init__(self, progress):
        """
        :param int progress:

        Constructor for SendMessageAction: Instance of either SendMessageTypingAction, SendMessageCancelAction, SendMessageRecordVideoAction, SendMessageUploadVideoAction, SendMessageRecordAudioAction, SendMessageUploadAudioAction, SendMessageUploadPhotoAction, SendMessageUploadDocumentAction, SendMessageGeoLocationAction, SendMessageChooseContactAction, SendMessageGamePlayAction, SendMessageRecordRoundAction, SendMessageUploadRoundAction.
        """
        self.progress = progress  # type: int

    def to_dict(self):
        return {
            '_': 'SendMessageUploadAudioAction',
            'progress': self.progress
        }

    def __bytes__(self):
        return b''.join((
            b'\xab\xd7Q\xf3',
            struct.pack('<i', self.progress),
        ))

    @classmethod
    def from_reader(cls, reader):
        _progress = reader.read_int()
        return cls(progress=_progress)


class SendMessageUploadDocumentAction(TLObject):
    CONSTRUCTOR_ID = 0xaa0cd9e4
    SUBCLASS_OF_ID = 0x20b2cc21

    def __init__(self, progress):
        """
        :param int progress:

        Constructor for SendMessageAction: Instance of either SendMessageTypingAction, SendMessageCancelAction, SendMessageRecordVideoAction, SendMessageUploadVideoAction, SendMessageRecordAudioAction, SendMessageUploadAudioAction, SendMessageUploadPhotoAction, SendMessageUploadDocumentAction, SendMessageGeoLocationAction, SendMessageChooseContactAction, SendMessageGamePlayAction, SendMessageRecordRoundAction, SendMessageUploadRoundAction.
        """
        self.progress = progress  # type: int

    def to_dict(self):
        return {
            '_': 'SendMessageUploadDocumentAction',
            'progress': self.progress
        }

    def __bytes__(self):
        return b''.join((
            b'\xe4\xd9\x0c\xaa',
            struct.pack('<i', self.progress),
        ))

    @classmethod
    def from_reader(cls, reader):
        _progress = reader.read_int()
        return cls(progress=_progress)


class SendMessageUploadPhotoAction(TLObject):
    CONSTRUCTOR_ID = 0xd1d34a26
    SUBCLASS_OF_ID = 0x20b2cc21

    def __init__(self, progress):
        """
        :param int progress:

        Constructor for SendMessageAction: Instance of either SendMessageTypingAction, SendMessageCancelAction, SendMessageRecordVideoAction, SendMessageUploadVideoAction, SendMessageRecordAudioAction, SendMessageUploadAudioAction, SendMessageUploadPhotoAction, SendMessageUploadDocumentAction, SendMessageGeoLocationAction, SendMessageChooseContactAction, SendMessageGamePlayAction, SendMessageRecordRoundAction, SendMessageUploadRoundAction.
        """
        self.progress = progress  # type: int

    def to_dict(self):
        return {
            '_': 'SendMessageUploadPhotoAction',
            'progress': self.progress
        }

    def __bytes__(self):
        return b''.join((
            b'&J\xd3\xd1',
            struct.pack('<i', self.progress),
        ))

    @classmethod
    def from_reader(cls, reader):
        _progress = reader.read_int()
        return cls(progress=_progress)


class SendMessageUploadRoundAction(TLObject):
    CONSTRUCTOR_ID = 0x243e1c66
    SUBCLASS_OF_ID = 0x20b2cc21

    def __init__(self, progress):
        """
        :param int progress:

        Constructor for SendMessageAction: Instance of either SendMessageTypingAction, SendMessageCancelAction, SendMessageRecordVideoAction, SendMessageUploadVideoAction, SendMessageRecordAudioAction, SendMessageUploadAudioAction, SendMessageUploadPhotoAction, SendMessageUploadDocumentAction, SendMessageGeoLocationAction, SendMessageChooseContactAction, SendMessageGamePlayAction, SendMessageRecordRoundAction, SendMessageUploadRoundAction.
        """
        self.progress = progress  # type: int

    def to_dict(self):
        return {
            '_': 'SendMessageUploadRoundAction',
            'progress': self.progress
        }

    def __bytes__(self):
        return b''.join((
            b'f\x1c>$',
            struct.pack('<i', self.progress),
        ))

    @classmethod
    def from_reader(cls, reader):
        _progress = reader.read_int()
        return cls(progress=_progress)


class SendMessageUploadVideoAction(TLObject):
    CONSTRUCTOR_ID = 0xe9763aec
    SUBCLASS_OF_ID = 0x20b2cc21

    def __init__(self, progress):
        """
        :param int progress:

        Constructor for SendMessageAction: Instance of either SendMessageTypingAction, SendMessageCancelAction, SendMessageRecordVideoAction, SendMessageUploadVideoAction, SendMessageRecordAudioAction, SendMessageUploadAudioAction, SendMessageUploadPhotoAction, SendMessageUploadDocumentAction, SendMessageGeoLocationAction, SendMessageChooseContactAction, SendMessageGamePlayAction, SendMessageRecordRoundAction, SendMessageUploadRoundAction.
        """
        self.progress = progress  # type: int

    def to_dict(self):
        return {
            '_': 'SendMessageUploadVideoAction',
            'progress': self.progress
        }

    def __bytes__(self):
        return b''.join((
            b'\xec:v\xe9',
            struct.pack('<i', self.progress),
        ))

    @classmethod
    def from_reader(cls, reader):
        _progress = reader.read_int()
        return cls(progress=_progress)


class ServerDHInnerData(TLObject):
    CONSTRUCTOR_ID = 0xb5890dba
    SUBCLASS_OF_ID = 0xc69a67bc

    def __init__(self, nonce, server_nonce, g, dh_prime, g_a, server_time):
        """
        :param int nonce:
        :param int server_nonce:
        :param int g:
        :param bytes dh_prime:
        :param bytes g_a:
        :param int server_time:

        Constructor for Server_DH_inner_data: Instance of ServerDHInnerData.
        """
        self.nonce = nonce  # type: int
        self.server_nonce = server_nonce  # type: int
        self.g = g  # type: int
        self.dh_prime = dh_prime  # type: bytes
        self.g_a = g_a  # type: bytes
        self.server_time = server_time  # type: int

    def to_dict(self):
        return {
            '_': 'ServerDHInnerData',
            'nonce': self.nonce,
            'server_nonce': self.server_nonce,
            'g': self.g,
            'dh_prime': self.dh_prime,
            'g_a': self.g_a,
            'server_time': self.server_time
        }

    def __bytes__(self):
        return b''.join((
            b'\xba\r\x89\xb5',
            self.nonce.to_bytes(16, 'little', signed=True),
            self.server_nonce.to_bytes(16, 'little', signed=True),
            struct.pack('<i', self.g),
            self.serialize_bytes(self.dh_prime),
            self.serialize_bytes(self.g_a),
            struct.pack('<i', self.server_time),
        ))

    @classmethod
    def from_reader(cls, reader):
        _nonce = reader.read_large_int(bits=128)
        _server_nonce = reader.read_large_int(bits=128)
        _g = reader.read_int()
        _dh_prime = reader.tgread_bytes()
        _g_a = reader.tgread_bytes()
        _server_time = reader.read_int()
        return cls(nonce=_nonce, server_nonce=_server_nonce, g=_g, dh_prime=_dh_prime, g_a=_g_a, server_time=_server_time)


class ServerDHParamsFail(TLObject):
    CONSTRUCTOR_ID = 0x79cb045d
    SUBCLASS_OF_ID = 0xa6188d9e

    def __init__(self, nonce, server_nonce, new_nonce_hash):
        """
        :param int nonce:
        :param int server_nonce:
        :param int new_nonce_hash:

        Constructor for Server_DH_Params: Instance of either ServerDHParamsFail, ServerDHParamsOk.
        """
        self.nonce = nonce  # type: int
        self.server_nonce = server_nonce  # type: int
        self.new_nonce_hash = new_nonce_hash  # type: int

    def to_dict(self):
        return {
            '_': 'ServerDHParamsFail',
            'nonce': self.nonce,
            'server_nonce': self.server_nonce,
            'new_nonce_hash': self.new_nonce_hash
        }

    def __bytes__(self):
        return b''.join((
            b']\x04\xcby',
            self.nonce.to_bytes(16, 'little', signed=True),
            self.server_nonce.to_bytes(16, 'little', signed=True),
            self.new_nonce_hash.to_bytes(16, 'little', signed=True),
        ))

    @classmethod
    def from_reader(cls, reader):
        _nonce = reader.read_large_int(bits=128)
        _server_nonce = reader.read_large_int(bits=128)
        _new_nonce_hash = reader.read_large_int(bits=128)
        return cls(nonce=_nonce, server_nonce=_server_nonce, new_nonce_hash=_new_nonce_hash)


class ServerDHParamsOk(TLObject):
    CONSTRUCTOR_ID = 0xd0e8075c
    SUBCLASS_OF_ID = 0xa6188d9e

    def __init__(self, nonce, server_nonce, encrypted_answer):
        """
        :param int nonce:
        :param int server_nonce:
        :param bytes encrypted_answer:

        Constructor for Server_DH_Params: Instance of either ServerDHParamsFail, ServerDHParamsOk.
        """
        self.nonce = nonce  # type: int
        self.server_nonce = server_nonce  # type: int
        self.encrypted_answer = encrypted_answer  # type: bytes

    def to_dict(self):
        return {
            '_': 'ServerDHParamsOk',
            'nonce': self.nonce,
            'server_nonce': self.server_nonce,
            'encrypted_answer': self.encrypted_answer
        }

    def __bytes__(self):
        return b''.join((
            b'\\\x07\xe8\xd0',
            self.nonce.to_bytes(16, 'little', signed=True),
            self.server_nonce.to_bytes(16, 'little', signed=True),
            self.serialize_bytes(self.encrypted_answer),
        ))

    @classmethod
    def from_reader(cls, reader):
        _nonce = reader.read_large_int(bits=128)
        _server_nonce = reader.read_large_int(bits=128)
        _encrypted_answer = reader.tgread_bytes()
        return cls(nonce=_nonce, server_nonce=_server_nonce, encrypted_answer=_encrypted_answer)


class ShippingOption(TLObject):
    CONSTRUCTOR_ID = 0xb6213cdf
    SUBCLASS_OF_ID = 0xf4e94c78

    def __init__(self, id, title, prices):
        """
        :param str id:
        :param str title:
        :param List[TypeLabeledPrice] prices:

        Constructor for ShippingOption: Instance of ShippingOption.
        """
        self.id = id  # type: str
        self.title = title  # type: str
        self.prices = prices  # type: List[TypeLabeledPrice]

    def to_dict(self):
        return {
            '_': 'ShippingOption',
            'id': self.id,
            'title': self.title,
            'prices': [] if self.prices is None else [None if x is None else x.to_dict() for x in self.prices]
        }

    def __bytes__(self):
        return b''.join((
            b'\xdf<!\xb6',
            self.serialize_bytes(self.id),
            self.serialize_bytes(self.title),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.prices)),b''.join(bytes(x) for x in self.prices),
        ))

    @classmethod
    def from_reader(cls, reader):
        _id = reader.tgread_string()
        _title = reader.tgread_string()
        reader.read_int()
        _prices = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _prices.append(_x)

        return cls(id=_id, title=_title, prices=_prices)


class StickerPack(TLObject):
    CONSTRUCTOR_ID = 0x12b299d4
    SUBCLASS_OF_ID = 0x9fefa4d4

    def __init__(self, emoticon, documents):
        """
        :param str emoticon:
        :param List[int] documents:

        Constructor for StickerPack: Instance of StickerPack.
        """
        self.emoticon = emoticon  # type: str
        self.documents = documents  # type: List[int]

    def to_dict(self):
        return {
            '_': 'StickerPack',
            'emoticon': self.emoticon,
            'documents': [] if self.documents is None else self.documents[:]
        }

    def __bytes__(self):
        return b''.join((
            b'\xd4\x99\xb2\x12',
            self.serialize_bytes(self.emoticon),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.documents)),b''.join(struct.pack('<q', x) for x in self.documents),
        ))

    @classmethod
    def from_reader(cls, reader):
        _emoticon = reader.tgread_string()
        reader.read_int()
        _documents = []
        for _ in range(reader.read_int()):
            _x = reader.read_long()
            _documents.append(_x)

        return cls(emoticon=_emoticon, documents=_documents)


class StickerSet(TLObject):
    CONSTRUCTOR_ID = 0x5585a139
    SUBCLASS_OF_ID = 0xbad3ff91

    def __init__(self, id, access_hash, title, short_name, count, hash, archived=None, official=None, masks=None, installed_date=None):
        """
        :param int id:
        :param int access_hash:
        :param str title:
        :param str short_name:
        :param int count:
        :param int hash:
        :param Optional[bool] archived:
        :param Optional[bool] official:
        :param Optional[bool] masks:
        :param Optional[datetime] installed_date:

        Constructor for StickerSet: Instance of StickerSet.
        """
        self.id = id  # type: int
        self.access_hash = access_hash  # type: int
        self.title = title  # type: str
        self.short_name = short_name  # type: str
        self.count = count  # type: int
        self.hash = hash  # type: int
        self.archived = archived  # type: Optional[bool]
        self.official = official  # type: Optional[bool]
        self.masks = masks  # type: Optional[bool]
        self.installed_date = installed_date  # type: Optional[datetime]

    def to_dict(self):
        return {
            '_': 'StickerSet',
            'id': self.id,
            'access_hash': self.access_hash,
            'title': self.title,
            'short_name': self.short_name,
            'count': self.count,
            'hash': self.hash,
            'archived': self.archived,
            'official': self.official,
            'masks': self.masks,
            'installed_date': self.installed_date
        }

    def __bytes__(self):
        return b''.join((
            b'9\xa1\x85U',
            struct.pack('<I', (0 if self.archived is None or self.archived is False else 2) | (0 if self.official is None or self.official is False else 4) | (0 if self.masks is None or self.masks is False else 8) | (0 if self.installed_date is None or self.installed_date is False else 1)),
            b'' if self.installed_date is None or self.installed_date is False else (self.serialize_datetime(self.installed_date)),
            struct.pack('<q', self.id),
            struct.pack('<q', self.access_hash),
            self.serialize_bytes(self.title),
            self.serialize_bytes(self.short_name),
            struct.pack('<i', self.count),
            struct.pack('<i', self.hash),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _archived = bool(flags & 2)
        _official = bool(flags & 4)
        _masks = bool(flags & 8)
        if flags & 1:
            _installed_date = reader.tgread_date()
        else:
            _installed_date = None
        _id = reader.read_long()
        _access_hash = reader.read_long()
        _title = reader.tgread_string()
        _short_name = reader.tgread_string()
        _count = reader.read_int()
        _hash = reader.read_int()
        return cls(id=_id, access_hash=_access_hash, title=_title, short_name=_short_name, count=_count, hash=_hash, archived=_archived, official=_official, masks=_masks, installed_date=_installed_date)


class StickerSetCovered(TLObject):
    CONSTRUCTOR_ID = 0x6410a5d2
    SUBCLASS_OF_ID = 0x7f86e4e5

    def __init__(self, set, cover):
        """
        :param TypeStickerSet set:
        :param TypeDocument cover:

        Constructor for StickerSetCovered: Instance of either StickerSetCovered, StickerSetMultiCovered.
        """
        self.set = set  # type: TypeStickerSet
        self.cover = cover  # type: TypeDocument

    def to_dict(self):
        return {
            '_': 'StickerSetCovered',
            'set': None if self.set is None else self.set.to_dict(),
            'cover': None if self.cover is None else self.cover.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\xd2\xa5\x10d',
            bytes(self.set),
            bytes(self.cover),
        ))

    @classmethod
    def from_reader(cls, reader):
        _set = reader.tgread_object()
        _cover = reader.tgread_object()
        return cls(set=_set, cover=_cover)


class StickerSetMultiCovered(TLObject):
    CONSTRUCTOR_ID = 0x3407e51b
    SUBCLASS_OF_ID = 0x7f86e4e5

    def __init__(self, set, covers):
        """
        :param TypeStickerSet set:
        :param List[TypeDocument] covers:

        Constructor for StickerSetCovered: Instance of either StickerSetCovered, StickerSetMultiCovered.
        """
        self.set = set  # type: TypeStickerSet
        self.covers = covers  # type: List[TypeDocument]

    def to_dict(self):
        return {
            '_': 'StickerSetMultiCovered',
            'set': None if self.set is None else self.set.to_dict(),
            'covers': [] if self.covers is None else [None if x is None else x.to_dict() for x in self.covers]
        }

    def __bytes__(self):
        return b''.join((
            b'\x1b\xe5\x074',
            bytes(self.set),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.covers)),b''.join(bytes(x) for x in self.covers),
        ))

    @classmethod
    def from_reader(cls, reader):
        _set = reader.tgread_object()
        reader.read_int()
        _covers = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _covers.append(_x)

        return cls(set=_set, covers=_covers)


class TextBold(TLObject):
    CONSTRUCTOR_ID = 0x6724abc4
    SUBCLASS_OF_ID = 0xf1d0b479

    def __init__(self, text):
        """
        :param TypeRichText text:

        Constructor for RichText: Instance of either TextEmpty, TextPlain, TextBold, TextItalic, TextUnderline, TextStrike, TextFixed, TextUrl, TextEmail, TextConcat.
        """
        self.text = text  # type: TypeRichText

    def to_dict(self):
        return {
            '_': 'TextBold',
            'text': None if self.text is None else self.text.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\xc4\xab$g',
            bytes(self.text),
        ))

    @classmethod
    def from_reader(cls, reader):
        _text = reader.tgread_object()
        return cls(text=_text)


class TextConcat(TLObject):
    CONSTRUCTOR_ID = 0x7e6260d7
    SUBCLASS_OF_ID = 0xf1d0b479

    def __init__(self, texts):
        """
        :param List[TypeRichText] texts:

        Constructor for RichText: Instance of either TextEmpty, TextPlain, TextBold, TextItalic, TextUnderline, TextStrike, TextFixed, TextUrl, TextEmail, TextConcat.
        """
        self.texts = texts  # type: List[TypeRichText]

    def to_dict(self):
        return {
            '_': 'TextConcat',
            'texts': [] if self.texts is None else [None if x is None else x.to_dict() for x in self.texts]
        }

    def __bytes__(self):
        return b''.join((
            b'\xd7`b~',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.texts)),b''.join(bytes(x) for x in self.texts),
        ))

    @classmethod
    def from_reader(cls, reader):
        reader.read_int()
        _texts = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _texts.append(_x)

        return cls(texts=_texts)


class TextEmail(TLObject):
    CONSTRUCTOR_ID = 0xde5a0dd6
    SUBCLASS_OF_ID = 0xf1d0b479

    def __init__(self, text, email):
        """
        :param TypeRichText text:
        :param str email:

        Constructor for RichText: Instance of either TextEmpty, TextPlain, TextBold, TextItalic, TextUnderline, TextStrike, TextFixed, TextUrl, TextEmail, TextConcat.
        """
        self.text = text  # type: TypeRichText
        self.email = email  # type: str

    def to_dict(self):
        return {
            '_': 'TextEmail',
            'text': None if self.text is None else self.text.to_dict(),
            'email': self.email
        }

    def __bytes__(self):
        return b''.join((
            b'\xd6\rZ\xde',
            bytes(self.text),
            self.serialize_bytes(self.email),
        ))

    @classmethod
    def from_reader(cls, reader):
        _text = reader.tgread_object()
        _email = reader.tgread_string()
        return cls(text=_text, email=_email)


class TextEmpty(TLObject):
    CONSTRUCTOR_ID = 0xdc3d824f
    SUBCLASS_OF_ID = 0xf1d0b479

    def to_dict(self):
        return {
            '_': 'TextEmpty'
        }

    def __bytes__(self):
        return b''.join((
            b'O\x82=\xdc',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class TextFixed(TLObject):
    CONSTRUCTOR_ID = 0x6c3f19b9
    SUBCLASS_OF_ID = 0xf1d0b479

    def __init__(self, text):
        """
        :param TypeRichText text:

        Constructor for RichText: Instance of either TextEmpty, TextPlain, TextBold, TextItalic, TextUnderline, TextStrike, TextFixed, TextUrl, TextEmail, TextConcat.
        """
        self.text = text  # type: TypeRichText

    def to_dict(self):
        return {
            '_': 'TextFixed',
            'text': None if self.text is None else self.text.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\xb9\x19?l',
            bytes(self.text),
        ))

    @classmethod
    def from_reader(cls, reader):
        _text = reader.tgread_object()
        return cls(text=_text)


class TextItalic(TLObject):
    CONSTRUCTOR_ID = 0xd912a59c
    SUBCLASS_OF_ID = 0xf1d0b479

    def __init__(self, text):
        """
        :param TypeRichText text:

        Constructor for RichText: Instance of either TextEmpty, TextPlain, TextBold, TextItalic, TextUnderline, TextStrike, TextFixed, TextUrl, TextEmail, TextConcat.
        """
        self.text = text  # type: TypeRichText

    def to_dict(self):
        return {
            '_': 'TextItalic',
            'text': None if self.text is None else self.text.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\x9c\xa5\x12\xd9',
            bytes(self.text),
        ))

    @classmethod
    def from_reader(cls, reader):
        _text = reader.tgread_object()
        return cls(text=_text)


class TextPlain(TLObject):
    CONSTRUCTOR_ID = 0x744694e0
    SUBCLASS_OF_ID = 0xf1d0b479

    def __init__(self, text):
        """
        :param str text:

        Constructor for RichText: Instance of either TextEmpty, TextPlain, TextBold, TextItalic, TextUnderline, TextStrike, TextFixed, TextUrl, TextEmail, TextConcat.
        """
        self.text = text  # type: str

    def to_dict(self):
        return {
            '_': 'TextPlain',
            'text': self.text
        }

    def __bytes__(self):
        return b''.join((
            b'\xe0\x94Ft',
            self.serialize_bytes(self.text),
        ))

    @classmethod
    def from_reader(cls, reader):
        _text = reader.tgread_string()
        return cls(text=_text)


class TextStrike(TLObject):
    CONSTRUCTOR_ID = 0x9bf8bb95
    SUBCLASS_OF_ID = 0xf1d0b479

    def __init__(self, text):
        """
        :param TypeRichText text:

        Constructor for RichText: Instance of either TextEmpty, TextPlain, TextBold, TextItalic, TextUnderline, TextStrike, TextFixed, TextUrl, TextEmail, TextConcat.
        """
        self.text = text  # type: TypeRichText

    def to_dict(self):
        return {
            '_': 'TextStrike',
            'text': None if self.text is None else self.text.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\x95\xbb\xf8\x9b',
            bytes(self.text),
        ))

    @classmethod
    def from_reader(cls, reader):
        _text = reader.tgread_object()
        return cls(text=_text)


class TextUnderline(TLObject):
    CONSTRUCTOR_ID = 0xc12622c4
    SUBCLASS_OF_ID = 0xf1d0b479

    def __init__(self, text):
        """
        :param TypeRichText text:

        Constructor for RichText: Instance of either TextEmpty, TextPlain, TextBold, TextItalic, TextUnderline, TextStrike, TextFixed, TextUrl, TextEmail, TextConcat.
        """
        self.text = text  # type: TypeRichText

    def to_dict(self):
        return {
            '_': 'TextUnderline',
            'text': None if self.text is None else self.text.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\xc4"&\xc1',
            bytes(self.text),
        ))

    @classmethod
    def from_reader(cls, reader):
        _text = reader.tgread_object()
        return cls(text=_text)


class TextUrl(TLObject):
    CONSTRUCTOR_ID = 0x3c2884c1
    SUBCLASS_OF_ID = 0xf1d0b479

    def __init__(self, text, url, webpage_id):
        """
        :param TypeRichText text:
        :param str url:
        :param int webpage_id:

        Constructor for RichText: Instance of either TextEmpty, TextPlain, TextBold, TextItalic, TextUnderline, TextStrike, TextFixed, TextUrl, TextEmail, TextConcat.
        """
        self.text = text  # type: TypeRichText
        self.url = url  # type: str
        self.webpage_id = webpage_id  # type: int

    def to_dict(self):
        return {
            '_': 'TextUrl',
            'text': None if self.text is None else self.text.to_dict(),
            'url': self.url,
            'webpage_id': self.webpage_id
        }

    def __bytes__(self):
        return b''.join((
            b'\xc1\x84(<',
            bytes(self.text),
            self.serialize_bytes(self.url),
            struct.pack('<q', self.webpage_id),
        ))

    @classmethod
    def from_reader(cls, reader):
        _text = reader.tgread_object()
        _url = reader.tgread_string()
        _webpage_id = reader.read_long()
        return cls(text=_text, url=_url, webpage_id=_webpage_id)


class TopPeer(TLObject):
    CONSTRUCTOR_ID = 0xedcdc05b
    SUBCLASS_OF_ID = 0x6916c601

    def __init__(self, peer, rating):
        """
        :param TypePeer peer:
        :param Typedouble rating:

        Constructor for TopPeer: Instance of TopPeer.
        """
        self.peer = peer  # type: TypePeer
        self.rating = rating  # type: Typedouble

    def to_dict(self):
        return {
            '_': 'TopPeer',
            'peer': None if self.peer is None else self.peer.to_dict(),
            'rating': self.rating
        }

    def __bytes__(self):
        return b''.join((
            b'[\xc0\xcd\xed',
            bytes(self.peer),
            struct.pack('<d', self.rating),
        ))

    @classmethod
    def from_reader(cls, reader):
        _peer = reader.tgread_object()
        _rating = reader.read_double()
        return cls(peer=_peer, rating=_rating)


class TopPeerCategoryBotsInline(TLObject):
    CONSTRUCTOR_ID = 0x148677e2
    SUBCLASS_OF_ID = 0xddf02502

    def to_dict(self):
        return {
            '_': 'TopPeerCategoryBotsInline'
        }

    def __bytes__(self):
        return b''.join((
            b'\xe2w\x86\x14',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class TopPeerCategoryBotsPM(TLObject):
    CONSTRUCTOR_ID = 0xab661b5b
    SUBCLASS_OF_ID = 0xddf02502

    def to_dict(self):
        return {
            '_': 'TopPeerCategoryBotsPM'
        }

    def __bytes__(self):
        return b''.join((
            b'[\x1bf\xab',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class TopPeerCategoryChannels(TLObject):
    CONSTRUCTOR_ID = 0x161d9628
    SUBCLASS_OF_ID = 0xddf02502

    def to_dict(self):
        return {
            '_': 'TopPeerCategoryChannels'
        }

    def __bytes__(self):
        return b''.join((
            b'(\x96\x1d\x16',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class TopPeerCategoryCorrespondents(TLObject):
    CONSTRUCTOR_ID = 0x637b7ed
    SUBCLASS_OF_ID = 0xddf02502

    def to_dict(self):
        return {
            '_': 'TopPeerCategoryCorrespondents'
        }

    def __bytes__(self):
        return b''.join((
            b'\xed\xb77\x06',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class TopPeerCategoryGroups(TLObject):
    CONSTRUCTOR_ID = 0xbd17a14a
    SUBCLASS_OF_ID = 0xddf02502

    def to_dict(self):
        return {
            '_': 'TopPeerCategoryGroups'
        }

    def __bytes__(self):
        return b''.join((
            b'J\xa1\x17\xbd',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class TopPeerCategoryPeers(TLObject):
    CONSTRUCTOR_ID = 0xfb834291
    SUBCLASS_OF_ID = 0x4aec930

    def __init__(self, category, count, peers):
        """
        :param TypeTopPeerCategory category:
        :param int count:
        :param List[TypeTopPeer] peers:

        Constructor for TopPeerCategoryPeers: Instance of TopPeerCategoryPeers.
        """
        self.category = category  # type: TypeTopPeerCategory
        self.count = count  # type: int
        self.peers = peers  # type: List[TypeTopPeer]

    def to_dict(self):
        return {
            '_': 'TopPeerCategoryPeers',
            'category': None if self.category is None else self.category.to_dict(),
            'count': self.count,
            'peers': [] if self.peers is None else [None if x is None else x.to_dict() for x in self.peers]
        }

    def __bytes__(self):
        return b''.join((
            b'\x91B\x83\xfb',
            bytes(self.category),
            struct.pack('<i', self.count),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.peers)),b''.join(bytes(x) for x in self.peers),
        ))

    @classmethod
    def from_reader(cls, reader):
        _category = reader.tgread_object()
        _count = reader.read_int()
        reader.read_int()
        _peers = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _peers.append(_x)

        return cls(category=_category, count=_count, peers=_peers)


class TopPeerCategoryPhoneCalls(TLObject):
    CONSTRUCTOR_ID = 0x1e76a78c
    SUBCLASS_OF_ID = 0xddf02502

    def to_dict(self):
        return {
            '_': 'TopPeerCategoryPhoneCalls'
        }

    def __bytes__(self):
        return b''.join((
            b'\x8c\xa7v\x1e',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class UpdateBotCallbackQuery(TLObject):
    CONSTRUCTOR_ID = 0xe73547e1
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, query_id, user_id, peer, msg_id, chat_instance, data=None, game_short_name=None):
        """
        :param int query_id:
        :param int user_id:
        :param TypePeer peer:
        :param int msg_id:
        :param int chat_instance:
        :param Optional[bytes] data:
        :param Optional[str] game_short_name:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages, UpdateDialogUnreadMark.
        """
        self.query_id = query_id  # type: int
        self.user_id = user_id  # type: int
        self.peer = peer  # type: TypePeer
        self.msg_id = msg_id  # type: int
        self.chat_instance = chat_instance  # type: int
        self.data = data  # type: Optional[bytes]
        self.game_short_name = game_short_name  # type: Optional[str]

    def to_dict(self):
        return {
            '_': 'UpdateBotCallbackQuery',
            'query_id': self.query_id,
            'user_id': self.user_id,
            'peer': None if self.peer is None else self.peer.to_dict(),
            'msg_id': self.msg_id,
            'chat_instance': self.chat_instance,
            'data': self.data,
            'game_short_name': self.game_short_name
        }

    def __bytes__(self):
        return b''.join((
            b'\xe1G5\xe7',
            struct.pack('<I', (0 if self.data is None or self.data is False else 1) | (0 if self.game_short_name is None or self.game_short_name is False else 2)),
            struct.pack('<q', self.query_id),
            struct.pack('<i', self.user_id),
            bytes(self.peer),
            struct.pack('<i', self.msg_id),
            struct.pack('<q', self.chat_instance),
            b'' if self.data is None or self.data is False else (self.serialize_bytes(self.data)),
            b'' if self.game_short_name is None or self.game_short_name is False else (self.serialize_bytes(self.game_short_name)),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _query_id = reader.read_long()
        _user_id = reader.read_int()
        _peer = reader.tgread_object()
        _msg_id = reader.read_int()
        _chat_instance = reader.read_long()
        if flags & 1:
            _data = reader.tgread_bytes()
        else:
            _data = None
        if flags & 2:
            _game_short_name = reader.tgread_string()
        else:
            _game_short_name = None
        return cls(query_id=_query_id, user_id=_user_id, peer=_peer, msg_id=_msg_id, chat_instance=_chat_instance, data=_data, game_short_name=_game_short_name)


class UpdateBotInlineQuery(TLObject):
    CONSTRUCTOR_ID = 0x54826690
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, query_id, user_id, query, offset, geo=None):
        """
        :param int query_id:
        :param int user_id:
        :param str query:
        :param str offset:
        :param Optional[TypeGeoPoint] geo:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages, UpdateDialogUnreadMark.
        """
        self.query_id = query_id  # type: int
        self.user_id = user_id  # type: int
        self.query = query  # type: str
        self.offset = offset  # type: str
        self.geo = geo  # type: Optional[TypeGeoPoint]

    def to_dict(self):
        return {
            '_': 'UpdateBotInlineQuery',
            'query_id': self.query_id,
            'user_id': self.user_id,
            'query': self.query,
            'offset': self.offset,
            'geo': None if self.geo is None else self.geo.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\x90f\x82T',
            struct.pack('<I', (0 if self.geo is None or self.geo is False else 1)),
            struct.pack('<q', self.query_id),
            struct.pack('<i', self.user_id),
            self.serialize_bytes(self.query),
            b'' if self.geo is None or self.geo is False else (bytes(self.geo)),
            self.serialize_bytes(self.offset),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _query_id = reader.read_long()
        _user_id = reader.read_int()
        _query = reader.tgread_string()
        if flags & 1:
            _geo = reader.tgread_object()
        else:
            _geo = None
        _offset = reader.tgread_string()
        return cls(query_id=_query_id, user_id=_user_id, query=_query, offset=_offset, geo=_geo)


class UpdateBotInlineSend(TLObject):
    CONSTRUCTOR_ID = 0xe48f964
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, user_id, query, id, geo=None, msg_id=None):
        """
        :param int user_id:
        :param str query:
        :param str id:
        :param Optional[TypeGeoPoint] geo:
        :param Optional[TypeInputBotInlineMessageID] msg_id:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages, UpdateDialogUnreadMark.
        """
        self.user_id = user_id  # type: int
        self.query = query  # type: str
        self.id = id  # type: str
        self.geo = geo  # type: Optional[TypeGeoPoint]
        self.msg_id = msg_id  # type: Optional[TypeInputBotInlineMessageID]

    def to_dict(self):
        return {
            '_': 'UpdateBotInlineSend',
            'user_id': self.user_id,
            'query': self.query,
            'id': self.id,
            'geo': None if self.geo is None else self.geo.to_dict(),
            'msg_id': None if self.msg_id is None else self.msg_id.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'd\xf9H\x0e',
            struct.pack('<I', (0 if self.geo is None or self.geo is False else 1) | (0 if self.msg_id is None or self.msg_id is False else 2)),
            struct.pack('<i', self.user_id),
            self.serialize_bytes(self.query),
            b'' if self.geo is None or self.geo is False else (bytes(self.geo)),
            self.serialize_bytes(self.id),
            b'' if self.msg_id is None or self.msg_id is False else (bytes(self.msg_id)),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _user_id = reader.read_int()
        _query = reader.tgread_string()
        if flags & 1:
            _geo = reader.tgread_object()
        else:
            _geo = None
        _id = reader.tgread_string()
        if flags & 2:
            _msg_id = reader.tgread_object()
        else:
            _msg_id = None
        return cls(user_id=_user_id, query=_query, id=_id, geo=_geo, msg_id=_msg_id)


class UpdateBotPrecheckoutQuery(TLObject):
    CONSTRUCTOR_ID = 0x5d2f3aa9
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, query_id, user_id, payload, currency, total_amount, info=None, shipping_option_id=None):
        """
        :param int query_id:
        :param int user_id:
        :param bytes payload:
        :param str currency:
        :param int total_amount:
        :param Optional[TypePaymentRequestedInfo] info:
        :param Optional[str] shipping_option_id:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages, UpdateDialogUnreadMark.
        """
        self.query_id = query_id  # type: int
        self.user_id = user_id  # type: int
        self.payload = payload  # type: bytes
        self.currency = currency  # type: str
        self.total_amount = total_amount  # type: int
        self.info = info  # type: Optional[TypePaymentRequestedInfo]
        self.shipping_option_id = shipping_option_id  # type: Optional[str]

    def to_dict(self):
        return {
            '_': 'UpdateBotPrecheckoutQuery',
            'query_id': self.query_id,
            'user_id': self.user_id,
            'payload': self.payload,
            'currency': self.currency,
            'total_amount': self.total_amount,
            'info': None if self.info is None else self.info.to_dict(),
            'shipping_option_id': self.shipping_option_id
        }

    def __bytes__(self):
        return b''.join((
            b'\xa9:/]',
            struct.pack('<I', (0 if self.info is None or self.info is False else 1) | (0 if self.shipping_option_id is None or self.shipping_option_id is False else 2)),
            struct.pack('<q', self.query_id),
            struct.pack('<i', self.user_id),
            self.serialize_bytes(self.payload),
            b'' if self.info is None or self.info is False else (bytes(self.info)),
            b'' if self.shipping_option_id is None or self.shipping_option_id is False else (self.serialize_bytes(self.shipping_option_id)),
            self.serialize_bytes(self.currency),
            struct.pack('<q', self.total_amount),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _query_id = reader.read_long()
        _user_id = reader.read_int()
        _payload = reader.tgread_bytes()
        if flags & 1:
            _info = reader.tgread_object()
        else:
            _info = None
        if flags & 2:
            _shipping_option_id = reader.tgread_string()
        else:
            _shipping_option_id = None
        _currency = reader.tgread_string()
        _total_amount = reader.read_long()
        return cls(query_id=_query_id, user_id=_user_id, payload=_payload, currency=_currency, total_amount=_total_amount, info=_info, shipping_option_id=_shipping_option_id)


class UpdateBotShippingQuery(TLObject):
    CONSTRUCTOR_ID = 0xe0cdc940
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, query_id, user_id, payload, shipping_address):
        """
        :param int query_id:
        :param int user_id:
        :param bytes payload:
        :param TypePostAddress shipping_address:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages, UpdateDialogUnreadMark.
        """
        self.query_id = query_id  # type: int
        self.user_id = user_id  # type: int
        self.payload = payload  # type: bytes
        self.shipping_address = shipping_address  # type: TypePostAddress

    def to_dict(self):
        return {
            '_': 'UpdateBotShippingQuery',
            'query_id': self.query_id,
            'user_id': self.user_id,
            'payload': self.payload,
            'shipping_address': None if self.shipping_address is None else self.shipping_address.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'@\xc9\xcd\xe0',
            struct.pack('<q', self.query_id),
            struct.pack('<i', self.user_id),
            self.serialize_bytes(self.payload),
            bytes(self.shipping_address),
        ))

    @classmethod
    def from_reader(cls, reader):
        _query_id = reader.read_long()
        _user_id = reader.read_int()
        _payload = reader.tgread_bytes()
        _shipping_address = reader.tgread_object()
        return cls(query_id=_query_id, user_id=_user_id, payload=_payload, shipping_address=_shipping_address)


class UpdateBotWebhookJSON(TLObject):
    CONSTRUCTOR_ID = 0x8317c0c3
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, data):
        """
        :param TypeDataJSON data:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages, UpdateDialogUnreadMark.
        """
        self.data = data  # type: TypeDataJSON

    def to_dict(self):
        return {
            '_': 'UpdateBotWebhookJSON',
            'data': None if self.data is None else self.data.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\xc3\xc0\x17\x83',
            bytes(self.data),
        ))

    @classmethod
    def from_reader(cls, reader):
        _data = reader.tgread_object()
        return cls(data=_data)


class UpdateBotWebhookJSONQuery(TLObject):
    CONSTRUCTOR_ID = 0x9b9240a6
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, query_id, data, timeout):
        """
        :param int query_id:
        :param TypeDataJSON data:
        :param int timeout:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages, UpdateDialogUnreadMark.
        """
        self.query_id = query_id  # type: int
        self.data = data  # type: TypeDataJSON
        self.timeout = timeout  # type: int

    def to_dict(self):
        return {
            '_': 'UpdateBotWebhookJSONQuery',
            'query_id': self.query_id,
            'data': None if self.data is None else self.data.to_dict(),
            'timeout': self.timeout
        }

    def __bytes__(self):
        return b''.join((
            b'\xa6@\x92\x9b',
            struct.pack('<q', self.query_id),
            bytes(self.data),
            struct.pack('<i', self.timeout),
        ))

    @classmethod
    def from_reader(cls, reader):
        _query_id = reader.read_long()
        _data = reader.tgread_object()
        _timeout = reader.read_int()
        return cls(query_id=_query_id, data=_data, timeout=_timeout)


class UpdateChannel(TLObject):
    CONSTRUCTOR_ID = 0xb6d45656
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, channel_id):
        """
        :param int channel_id:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages, UpdateDialogUnreadMark.
        """
        self.channel_id = channel_id  # type: int

    def to_dict(self):
        return {
            '_': 'UpdateChannel',
            'channel_id': self.channel_id
        }

    def __bytes__(self):
        return b''.join((
            b'VV\xd4\xb6',
            struct.pack('<i', self.channel_id),
        ))

    @classmethod
    def from_reader(cls, reader):
        _channel_id = reader.read_int()
        return cls(channel_id=_channel_id)


class UpdateChannelAvailableMessages(TLObject):
    CONSTRUCTOR_ID = 0x70db6837
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, channel_id, available_min_id):
        """
        :param int channel_id:
        :param int available_min_id:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages, UpdateDialogUnreadMark.
        """
        self.channel_id = channel_id  # type: int
        self.available_min_id = available_min_id  # type: int

    def to_dict(self):
        return {
            '_': 'UpdateChannelAvailableMessages',
            'channel_id': self.channel_id,
            'available_min_id': self.available_min_id
        }

    def __bytes__(self):
        return b''.join((
            b'7h\xdbp',
            struct.pack('<i', self.channel_id),
            struct.pack('<i', self.available_min_id),
        ))

    @classmethod
    def from_reader(cls, reader):
        _channel_id = reader.read_int()
        _available_min_id = reader.read_int()
        return cls(channel_id=_channel_id, available_min_id=_available_min_id)


class UpdateChannelMessageViews(TLObject):
    CONSTRUCTOR_ID = 0x98a12b4b
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, channel_id, id, views):
        """
        :param int channel_id:
        :param int id:
        :param int views:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages, UpdateDialogUnreadMark.
        """
        self.channel_id = channel_id  # type: int
        self.id = id  # type: int
        self.views = views  # type: int

    def to_dict(self):
        return {
            '_': 'UpdateChannelMessageViews',
            'channel_id': self.channel_id,
            'id': self.id,
            'views': self.views
        }

    def __bytes__(self):
        return b''.join((
            b'K+\xa1\x98',
            struct.pack('<i', self.channel_id),
            struct.pack('<i', self.id),
            struct.pack('<i', self.views),
        ))

    @classmethod
    def from_reader(cls, reader):
        _channel_id = reader.read_int()
        _id = reader.read_int()
        _views = reader.read_int()
        return cls(channel_id=_channel_id, id=_id, views=_views)


class UpdateChannelPinnedMessage(TLObject):
    CONSTRUCTOR_ID = 0x98592475
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, channel_id, id):
        """
        :param int channel_id:
        :param int id:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages, UpdateDialogUnreadMark.
        """
        self.channel_id = channel_id  # type: int
        self.id = id  # type: int

    def to_dict(self):
        return {
            '_': 'UpdateChannelPinnedMessage',
            'channel_id': self.channel_id,
            'id': self.id
        }

    def __bytes__(self):
        return b''.join((
            b'u$Y\x98',
            struct.pack('<i', self.channel_id),
            struct.pack('<i', self.id),
        ))

    @classmethod
    def from_reader(cls, reader):
        _channel_id = reader.read_int()
        _id = reader.read_int()
        return cls(channel_id=_channel_id, id=_id)


class UpdateChannelReadMessagesContents(TLObject):
    CONSTRUCTOR_ID = 0x89893b45
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, channel_id, messages):
        """
        :param int channel_id:
        :param List[int] messages:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages, UpdateDialogUnreadMark.
        """
        self.channel_id = channel_id  # type: int
        self.messages = messages  # type: List[int]

    def to_dict(self):
        return {
            '_': 'UpdateChannelReadMessagesContents',
            'channel_id': self.channel_id,
            'messages': [] if self.messages is None else self.messages[:]
        }

    def __bytes__(self):
        return b''.join((
            b'E;\x89\x89',
            struct.pack('<i', self.channel_id),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.messages)),b''.join(struct.pack('<i', x) for x in self.messages),
        ))

    @classmethod
    def from_reader(cls, reader):
        _channel_id = reader.read_int()
        reader.read_int()
        _messages = []
        for _ in range(reader.read_int()):
            _x = reader.read_int()
            _messages.append(_x)

        return cls(channel_id=_channel_id, messages=_messages)


class UpdateChannelTooLong(TLObject):
    CONSTRUCTOR_ID = 0xeb0467fb
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, channel_id, pts=None):
        """
        :param int channel_id:
        :param Optional[int] pts:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages, UpdateDialogUnreadMark.
        """
        self.channel_id = channel_id  # type: int
        self.pts = pts  # type: Optional[int]

    def to_dict(self):
        return {
            '_': 'UpdateChannelTooLong',
            'channel_id': self.channel_id,
            'pts': self.pts
        }

    def __bytes__(self):
        return b''.join((
            b'\xfbg\x04\xeb',
            struct.pack('<I', (0 if self.pts is None or self.pts is False else 1)),
            struct.pack('<i', self.channel_id),
            b'' if self.pts is None or self.pts is False else (struct.pack('<i', self.pts)),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _channel_id = reader.read_int()
        if flags & 1:
            _pts = reader.read_int()
        else:
            _pts = None
        return cls(channel_id=_channel_id, pts=_pts)


class UpdateChannelWebPage(TLObject):
    CONSTRUCTOR_ID = 0x40771900
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, channel_id, webpage, pts, pts_count):
        """
        :param int channel_id:
        :param TypeWebPage webpage:
        :param int pts:
        :param int pts_count:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages, UpdateDialogUnreadMark.
        """
        self.channel_id = channel_id  # type: int
        self.webpage = webpage  # type: TypeWebPage
        self.pts = pts  # type: int
        self.pts_count = pts_count  # type: int

    def to_dict(self):
        return {
            '_': 'UpdateChannelWebPage',
            'channel_id': self.channel_id,
            'webpage': None if self.webpage is None else self.webpage.to_dict(),
            'pts': self.pts,
            'pts_count': self.pts_count
        }

    def __bytes__(self):
        return b''.join((
            b'\x00\x19w@',
            struct.pack('<i', self.channel_id),
            bytes(self.webpage),
            struct.pack('<i', self.pts),
            struct.pack('<i', self.pts_count),
        ))

    @classmethod
    def from_reader(cls, reader):
        _channel_id = reader.read_int()
        _webpage = reader.tgread_object()
        _pts = reader.read_int()
        _pts_count = reader.read_int()
        return cls(channel_id=_channel_id, webpage=_webpage, pts=_pts, pts_count=_pts_count)


class UpdateChatAdmins(TLObject):
    CONSTRUCTOR_ID = 0x6e947941
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, chat_id, enabled, version):
        """
        :param int chat_id:
        :param TypeBool enabled:
        :param int version:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages, UpdateDialogUnreadMark.
        """
        self.chat_id = chat_id  # type: int
        self.enabled = enabled  # type: TypeBool
        self.version = version  # type: int

    def to_dict(self):
        return {
            '_': 'UpdateChatAdmins',
            'chat_id': self.chat_id,
            'enabled': self.enabled,
            'version': self.version
        }

    def __bytes__(self):
        return b''.join((
            b'Ay\x94n',
            struct.pack('<i', self.chat_id),
            b'\xb5ur\x99' if self.enabled else b'7\x97y\xbc',
            struct.pack('<i', self.version),
        ))

    @classmethod
    def from_reader(cls, reader):
        _chat_id = reader.read_int()
        _enabled = reader.tgread_bool()
        _version = reader.read_int()
        return cls(chat_id=_chat_id, enabled=_enabled, version=_version)


class UpdateChatParticipantAdd(TLObject):
    CONSTRUCTOR_ID = 0xea4b0e5c
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, chat_id, user_id, inviter_id, date, version):
        """
        :param int chat_id:
        :param int user_id:
        :param int inviter_id:
        :param Optional[datetime] date:
        :param int version:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages, UpdateDialogUnreadMark.
        """
        self.chat_id = chat_id  # type: int
        self.user_id = user_id  # type: int
        self.inviter_id = inviter_id  # type: int
        self.date = date  # type: Optional[datetime]
        self.version = version  # type: int

    def to_dict(self):
        return {
            '_': 'UpdateChatParticipantAdd',
            'chat_id': self.chat_id,
            'user_id': self.user_id,
            'inviter_id': self.inviter_id,
            'date': self.date,
            'version': self.version
        }

    def __bytes__(self):
        return b''.join((
            b'\\\x0eK\xea',
            struct.pack('<i', self.chat_id),
            struct.pack('<i', self.user_id),
            struct.pack('<i', self.inviter_id),
            self.serialize_datetime(self.date),
            struct.pack('<i', self.version),
        ))

    @classmethod
    def from_reader(cls, reader):
        _chat_id = reader.read_int()
        _user_id = reader.read_int()
        _inviter_id = reader.read_int()
        _date = reader.tgread_date()
        _version = reader.read_int()
        return cls(chat_id=_chat_id, user_id=_user_id, inviter_id=_inviter_id, date=_date, version=_version)


class UpdateChatParticipantAdmin(TLObject):
    CONSTRUCTOR_ID = 0xb6901959
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, chat_id, user_id, is_admin, version):
        """
        :param int chat_id:
        :param int user_id:
        :param TypeBool is_admin:
        :param int version:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages, UpdateDialogUnreadMark.
        """
        self.chat_id = chat_id  # type: int
        self.user_id = user_id  # type: int
        self.is_admin = is_admin  # type: TypeBool
        self.version = version  # type: int

    def to_dict(self):
        return {
            '_': 'UpdateChatParticipantAdmin',
            'chat_id': self.chat_id,
            'user_id': self.user_id,
            'is_admin': self.is_admin,
            'version': self.version
        }

    def __bytes__(self):
        return b''.join((
            b'Y\x19\x90\xb6',
            struct.pack('<i', self.chat_id),
            struct.pack('<i', self.user_id),
            b'\xb5ur\x99' if self.is_admin else b'7\x97y\xbc',
            struct.pack('<i', self.version),
        ))

    @classmethod
    def from_reader(cls, reader):
        _chat_id = reader.read_int()
        _user_id = reader.read_int()
        _is_admin = reader.tgread_bool()
        _version = reader.read_int()
        return cls(chat_id=_chat_id, user_id=_user_id, is_admin=_is_admin, version=_version)


class UpdateChatParticipantDelete(TLObject):
    CONSTRUCTOR_ID = 0x6e5f8c22
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, chat_id, user_id, version):
        """
        :param int chat_id:
        :param int user_id:
        :param int version:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages, UpdateDialogUnreadMark.
        """
        self.chat_id = chat_id  # type: int
        self.user_id = user_id  # type: int
        self.version = version  # type: int

    def to_dict(self):
        return {
            '_': 'UpdateChatParticipantDelete',
            'chat_id': self.chat_id,
            'user_id': self.user_id,
            'version': self.version
        }

    def __bytes__(self):
        return b''.join((
            b'"\x8c_n',
            struct.pack('<i', self.chat_id),
            struct.pack('<i', self.user_id),
            struct.pack('<i', self.version),
        ))

    @classmethod
    def from_reader(cls, reader):
        _chat_id = reader.read_int()
        _user_id = reader.read_int()
        _version = reader.read_int()
        return cls(chat_id=_chat_id, user_id=_user_id, version=_version)


class UpdateChatParticipants(TLObject):
    CONSTRUCTOR_ID = 0x7761198
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, participants):
        """
        :param TypeChatParticipants participants:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages, UpdateDialogUnreadMark.
        """
        self.participants = participants  # type: TypeChatParticipants

    def to_dict(self):
        return {
            '_': 'UpdateChatParticipants',
            'participants': None if self.participants is None else self.participants.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\x98\x11v\x07',
            bytes(self.participants),
        ))

    @classmethod
    def from_reader(cls, reader):
        _participants = reader.tgread_object()
        return cls(participants=_participants)


class UpdateChatUserTyping(TLObject):
    CONSTRUCTOR_ID = 0x9a65ea1f
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, chat_id, user_id, action):
        """
        :param int chat_id:
        :param int user_id:
        :param TypeSendMessageAction action:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages, UpdateDialogUnreadMark.
        """
        self.chat_id = chat_id  # type: int
        self.user_id = user_id  # type: int
        self.action = action  # type: TypeSendMessageAction

    def to_dict(self):
        return {
            '_': 'UpdateChatUserTyping',
            'chat_id': self.chat_id,
            'user_id': self.user_id,
            'action': None if self.action is None else self.action.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\x1f\xeae\x9a',
            struct.pack('<i', self.chat_id),
            struct.pack('<i', self.user_id),
            bytes(self.action),
        ))

    @classmethod
    def from_reader(cls, reader):
        _chat_id = reader.read_int()
        _user_id = reader.read_int()
        _action = reader.tgread_object()
        return cls(chat_id=_chat_id, user_id=_user_id, action=_action)


class UpdateConfig(TLObject):
    CONSTRUCTOR_ID = 0xa229dd06
    SUBCLASS_OF_ID = 0x9f89304e

    def to_dict(self):
        return {
            '_': 'UpdateConfig'
        }

    def __bytes__(self):
        return b''.join((
            b'\x06\xdd)\xa2',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class UpdateContactLink(TLObject):
    CONSTRUCTOR_ID = 0x9d2e67c5
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, user_id, my_link, foreign_link):
        """
        :param int user_id:
        :param TypeContactLink my_link:
        :param TypeContactLink foreign_link:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages, UpdateDialogUnreadMark.
        """
        self.user_id = user_id  # type: int
        self.my_link = my_link  # type: TypeContactLink
        self.foreign_link = foreign_link  # type: TypeContactLink

    def to_dict(self):
        return {
            '_': 'UpdateContactLink',
            'user_id': self.user_id,
            'my_link': None if self.my_link is None else self.my_link.to_dict(),
            'foreign_link': None if self.foreign_link is None else self.foreign_link.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\xc5g.\x9d',
            struct.pack('<i', self.user_id),
            bytes(self.my_link),
            bytes(self.foreign_link),
        ))

    @classmethod
    def from_reader(cls, reader):
        _user_id = reader.read_int()
        _my_link = reader.tgread_object()
        _foreign_link = reader.tgread_object()
        return cls(user_id=_user_id, my_link=_my_link, foreign_link=_foreign_link)


class UpdateContactRegistered(TLObject):
    CONSTRUCTOR_ID = 0x2575bbb9
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, user_id, date):
        """
        :param int user_id:
        :param Optional[datetime] date:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages, UpdateDialogUnreadMark.
        """
        self.user_id = user_id  # type: int
        self.date = date  # type: Optional[datetime]

    def to_dict(self):
        return {
            '_': 'UpdateContactRegistered',
            'user_id': self.user_id,
            'date': self.date
        }

    def __bytes__(self):
        return b''.join((
            b'\xb9\xbbu%',
            struct.pack('<i', self.user_id),
            self.serialize_datetime(self.date),
        ))

    @classmethod
    def from_reader(cls, reader):
        _user_id = reader.read_int()
        _date = reader.tgread_date()
        return cls(user_id=_user_id, date=_date)


class UpdateContactsReset(TLObject):
    CONSTRUCTOR_ID = 0x7084a7be
    SUBCLASS_OF_ID = 0x9f89304e

    def to_dict(self):
        return {
            '_': 'UpdateContactsReset'
        }

    def __bytes__(self):
        return b''.join((
            b'\xbe\xa7\x84p',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class UpdateDcOptions(TLObject):
    CONSTRUCTOR_ID = 0x8e5e9873
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, dc_options):
        """
        :param List[TypeDcOption] dc_options:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages, UpdateDialogUnreadMark.
        """
        self.dc_options = dc_options  # type: List[TypeDcOption]

    def to_dict(self):
        return {
            '_': 'UpdateDcOptions',
            'dc_options': [] if self.dc_options is None else [None if x is None else x.to_dict() for x in self.dc_options]
        }

    def __bytes__(self):
        return b''.join((
            b's\x98^\x8e',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.dc_options)),b''.join(bytes(x) for x in self.dc_options),
        ))

    @classmethod
    def from_reader(cls, reader):
        reader.read_int()
        _dc_options = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _dc_options.append(_x)

        return cls(dc_options=_dc_options)


class UpdateDeleteChannelMessages(TLObject):
    CONSTRUCTOR_ID = 0xc37521c9
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, channel_id, messages, pts, pts_count):
        """
        :param int channel_id:
        :param List[int] messages:
        :param int pts:
        :param int pts_count:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages, UpdateDialogUnreadMark.
        """
        self.channel_id = channel_id  # type: int
        self.messages = messages  # type: List[int]
        self.pts = pts  # type: int
        self.pts_count = pts_count  # type: int

    def to_dict(self):
        return {
            '_': 'UpdateDeleteChannelMessages',
            'channel_id': self.channel_id,
            'messages': [] if self.messages is None else self.messages[:],
            'pts': self.pts,
            'pts_count': self.pts_count
        }

    def __bytes__(self):
        return b''.join((
            b'\xc9!u\xc3',
            struct.pack('<i', self.channel_id),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.messages)),b''.join(struct.pack('<i', x) for x in self.messages),
            struct.pack('<i', self.pts),
            struct.pack('<i', self.pts_count),
        ))

    @classmethod
    def from_reader(cls, reader):
        _channel_id = reader.read_int()
        reader.read_int()
        _messages = []
        for _ in range(reader.read_int()):
            _x = reader.read_int()
            _messages.append(_x)

        _pts = reader.read_int()
        _pts_count = reader.read_int()
        return cls(channel_id=_channel_id, messages=_messages, pts=_pts, pts_count=_pts_count)


class UpdateDeleteMessages(TLObject):
    CONSTRUCTOR_ID = 0xa20db0e5
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, messages, pts, pts_count):
        """
        :param List[int] messages:
        :param int pts:
        :param int pts_count:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages, UpdateDialogUnreadMark.
        """
        self.messages = messages  # type: List[int]
        self.pts = pts  # type: int
        self.pts_count = pts_count  # type: int

    def to_dict(self):
        return {
            '_': 'UpdateDeleteMessages',
            'messages': [] if self.messages is None else self.messages[:],
            'pts': self.pts,
            'pts_count': self.pts_count
        }

    def __bytes__(self):
        return b''.join((
            b'\xe5\xb0\r\xa2',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.messages)),b''.join(struct.pack('<i', x) for x in self.messages),
            struct.pack('<i', self.pts),
            struct.pack('<i', self.pts_count),
        ))

    @classmethod
    def from_reader(cls, reader):
        reader.read_int()
        _messages = []
        for _ in range(reader.read_int()):
            _x = reader.read_int()
            _messages.append(_x)

        _pts = reader.read_int()
        _pts_count = reader.read_int()
        return cls(messages=_messages, pts=_pts, pts_count=_pts_count)


class UpdateDialogPinned(TLObject):
    CONSTRUCTOR_ID = 0x19d27f3c
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, peer, pinned=None):
        """
        :param TypeDialogPeer peer:
        :param Optional[bool] pinned:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages, UpdateDialogUnreadMark.
        """
        self.peer = peer  # type: TypeDialogPeer
        self.pinned = pinned  # type: Optional[bool]

    def to_dict(self):
        return {
            '_': 'UpdateDialogPinned',
            'peer': None if self.peer is None else self.peer.to_dict(),
            'pinned': self.pinned
        }

    def __bytes__(self):
        return b''.join((
            b'<\x7f\xd2\x19',
            struct.pack('<I', (0 if self.pinned is None or self.pinned is False else 1)),
            bytes(self.peer),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _pinned = bool(flags & 1)
        _peer = reader.tgread_object()
        return cls(peer=_peer, pinned=_pinned)


class UpdateDialogUnreadMark(TLObject):
    CONSTRUCTOR_ID = 0xe16459c3
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, peer, unread=None):
        """
        :param TypeDialogPeer peer:
        :param Optional[bool] unread:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages, UpdateDialogUnreadMark.
        """
        self.peer = peer  # type: TypeDialogPeer
        self.unread = unread  # type: Optional[bool]

    def to_dict(self):
        return {
            '_': 'UpdateDialogUnreadMark',
            'peer': None if self.peer is None else self.peer.to_dict(),
            'unread': self.unread
        }

    def __bytes__(self):
        return b''.join((
            b'\xc3Yd\xe1',
            struct.pack('<I', (0 if self.unread is None or self.unread is False else 1)),
            bytes(self.peer),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _unread = bool(flags & 1)
        _peer = reader.tgread_object()
        return cls(peer=_peer, unread=_unread)


class UpdateDraftMessage(TLObject):
    CONSTRUCTOR_ID = 0xee2bb969
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, peer, draft):
        """
        :param TypePeer peer:
        :param TypeDraftMessage draft:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages, UpdateDialogUnreadMark.
        """
        self.peer = peer  # type: TypePeer
        self.draft = draft  # type: TypeDraftMessage

    def to_dict(self):
        return {
            '_': 'UpdateDraftMessage',
            'peer': None if self.peer is None else self.peer.to_dict(),
            'draft': None if self.draft is None else self.draft.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'i\xb9+\xee',
            bytes(self.peer),
            bytes(self.draft),
        ))

    @classmethod
    def from_reader(cls, reader):
        _peer = reader.tgread_object()
        _draft = reader.tgread_object()
        return cls(peer=_peer, draft=_draft)


class UpdateEditChannelMessage(TLObject):
    CONSTRUCTOR_ID = 0x1b3f4df7
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, message, pts, pts_count):
        """
        :param TypeMessage message:
        :param int pts:
        :param int pts_count:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages, UpdateDialogUnreadMark.
        """
        self.message = message  # type: TypeMessage
        self.pts = pts  # type: int
        self.pts_count = pts_count  # type: int

    def to_dict(self):
        return {
            '_': 'UpdateEditChannelMessage',
            'message': None if self.message is None else self.message.to_dict(),
            'pts': self.pts,
            'pts_count': self.pts_count
        }

    def __bytes__(self):
        return b''.join((
            b'\xf7M?\x1b',
            bytes(self.message),
            struct.pack('<i', self.pts),
            struct.pack('<i', self.pts_count),
        ))

    @classmethod
    def from_reader(cls, reader):
        _message = reader.tgread_object()
        _pts = reader.read_int()
        _pts_count = reader.read_int()
        return cls(message=_message, pts=_pts, pts_count=_pts_count)


class UpdateEditMessage(TLObject):
    CONSTRUCTOR_ID = 0xe40370a3
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, message, pts, pts_count):
        """
        :param TypeMessage message:
        :param int pts:
        :param int pts_count:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages, UpdateDialogUnreadMark.
        """
        self.message = message  # type: TypeMessage
        self.pts = pts  # type: int
        self.pts_count = pts_count  # type: int

    def to_dict(self):
        return {
            '_': 'UpdateEditMessage',
            'message': None if self.message is None else self.message.to_dict(),
            'pts': self.pts,
            'pts_count': self.pts_count
        }

    def __bytes__(self):
        return b''.join((
            b'\xa3p\x03\xe4',
            bytes(self.message),
            struct.pack('<i', self.pts),
            struct.pack('<i', self.pts_count),
        ))

    @classmethod
    def from_reader(cls, reader):
        _message = reader.tgread_object()
        _pts = reader.read_int()
        _pts_count = reader.read_int()
        return cls(message=_message, pts=_pts, pts_count=_pts_count)


class UpdateEncryptedChatTyping(TLObject):
    CONSTRUCTOR_ID = 0x1710f156
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, chat_id):
        """
        :param int chat_id:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages, UpdateDialogUnreadMark.
        """
        self.chat_id = chat_id  # type: int

    def to_dict(self):
        return {
            '_': 'UpdateEncryptedChatTyping',
            'chat_id': self.chat_id
        }

    def __bytes__(self):
        return b''.join((
            b'V\xf1\x10\x17',
            struct.pack('<i', self.chat_id),
        ))

    @classmethod
    def from_reader(cls, reader):
        _chat_id = reader.read_int()
        return cls(chat_id=_chat_id)


class UpdateEncryptedMessagesRead(TLObject):
    CONSTRUCTOR_ID = 0x38fe25b7
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, chat_id, max_date, date):
        """
        :param int chat_id:
        :param Optional[datetime] max_date:
        :param Optional[datetime] date:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages, UpdateDialogUnreadMark.
        """
        self.chat_id = chat_id  # type: int
        self.max_date = max_date  # type: Optional[datetime]
        self.date = date  # type: Optional[datetime]

    def to_dict(self):
        return {
            '_': 'UpdateEncryptedMessagesRead',
            'chat_id': self.chat_id,
            'max_date': self.max_date,
            'date': self.date
        }

    def __bytes__(self):
        return b''.join((
            b'\xb7%\xfe8',
            struct.pack('<i', self.chat_id),
            self.serialize_datetime(self.max_date),
            self.serialize_datetime(self.date),
        ))

    @classmethod
    def from_reader(cls, reader):
        _chat_id = reader.read_int()
        _max_date = reader.tgread_date()
        _date = reader.tgread_date()
        return cls(chat_id=_chat_id, max_date=_max_date, date=_date)


class UpdateEncryption(TLObject):
    CONSTRUCTOR_ID = 0xb4a2e88d
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, chat, date):
        """
        :param TypeEncryptedChat chat:
        :param Optional[datetime] date:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages, UpdateDialogUnreadMark.
        """
        self.chat = chat  # type: TypeEncryptedChat
        self.date = date  # type: Optional[datetime]

    def to_dict(self):
        return {
            '_': 'UpdateEncryption',
            'chat': None if self.chat is None else self.chat.to_dict(),
            'date': self.date
        }

    def __bytes__(self):
        return b''.join((
            b'\x8d\xe8\xa2\xb4',
            bytes(self.chat),
            self.serialize_datetime(self.date),
        ))

    @classmethod
    def from_reader(cls, reader):
        _chat = reader.tgread_object()
        _date = reader.tgread_date()
        return cls(chat=_chat, date=_date)


class UpdateFavedStickers(TLObject):
    CONSTRUCTOR_ID = 0xe511996d
    SUBCLASS_OF_ID = 0x9f89304e

    def to_dict(self):
        return {
            '_': 'UpdateFavedStickers'
        }

    def __bytes__(self):
        return b''.join((
            b'm\x99\x11\xe5',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class UpdateInlineBotCallbackQuery(TLObject):
    CONSTRUCTOR_ID = 0xf9d27a5a
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, query_id, user_id, msg_id, chat_instance, data=None, game_short_name=None):
        """
        :param int query_id:
        :param int user_id:
        :param TypeInputBotInlineMessageID msg_id:
        :param int chat_instance:
        :param Optional[bytes] data:
        :param Optional[str] game_short_name:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages, UpdateDialogUnreadMark.
        """
        self.query_id = query_id  # type: int
        self.user_id = user_id  # type: int
        self.msg_id = msg_id  # type: TypeInputBotInlineMessageID
        self.chat_instance = chat_instance  # type: int
        self.data = data  # type: Optional[bytes]
        self.game_short_name = game_short_name  # type: Optional[str]

    def to_dict(self):
        return {
            '_': 'UpdateInlineBotCallbackQuery',
            'query_id': self.query_id,
            'user_id': self.user_id,
            'msg_id': None if self.msg_id is None else self.msg_id.to_dict(),
            'chat_instance': self.chat_instance,
            'data': self.data,
            'game_short_name': self.game_short_name
        }

    def __bytes__(self):
        return b''.join((
            b'Zz\xd2\xf9',
            struct.pack('<I', (0 if self.data is None or self.data is False else 1) | (0 if self.game_short_name is None or self.game_short_name is False else 2)),
            struct.pack('<q', self.query_id),
            struct.pack('<i', self.user_id),
            bytes(self.msg_id),
            struct.pack('<q', self.chat_instance),
            b'' if self.data is None or self.data is False else (self.serialize_bytes(self.data)),
            b'' if self.game_short_name is None or self.game_short_name is False else (self.serialize_bytes(self.game_short_name)),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _query_id = reader.read_long()
        _user_id = reader.read_int()
        _msg_id = reader.tgread_object()
        _chat_instance = reader.read_long()
        if flags & 1:
            _data = reader.tgread_bytes()
        else:
            _data = None
        if flags & 2:
            _game_short_name = reader.tgread_string()
        else:
            _game_short_name = None
        return cls(query_id=_query_id, user_id=_user_id, msg_id=_msg_id, chat_instance=_chat_instance, data=_data, game_short_name=_game_short_name)


class UpdateLangPack(TLObject):
    CONSTRUCTOR_ID = 0x56022f4d
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, difference):
        """
        :param TypeLangPackDifference difference:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages, UpdateDialogUnreadMark.
        """
        self.difference = difference  # type: TypeLangPackDifference

    def to_dict(self):
        return {
            '_': 'UpdateLangPack',
            'difference': None if self.difference is None else self.difference.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'M/\x02V',
            bytes(self.difference),
        ))

    @classmethod
    def from_reader(cls, reader):
        _difference = reader.tgread_object()
        return cls(difference=_difference)


class UpdateLangPackTooLong(TLObject):
    CONSTRUCTOR_ID = 0x10c2404b
    SUBCLASS_OF_ID = 0x9f89304e

    def to_dict(self):
        return {
            '_': 'UpdateLangPackTooLong'
        }

    def __bytes__(self):
        return b''.join((
            b'K@\xc2\x10',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class UpdateMessageID(TLObject):
    CONSTRUCTOR_ID = 0x4e90bfd6
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, id, random_id=None):
        """
        :param int id:
        :param int random_id:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages, UpdateDialogUnreadMark.
        """
        self.id = id  # type: int
        self.random_id = random_id if random_id is not None else int.from_bytes(os.urandom(8), 'big', signed=True)

    def to_dict(self):
        return {
            '_': 'UpdateMessageID',
            'id': self.id,
            'random_id': self.random_id
        }

    def __bytes__(self):
        return b''.join((
            b'\xd6\xbf\x90N',
            struct.pack('<i', self.id),
            struct.pack('<q', self.random_id),
        ))

    @classmethod
    def from_reader(cls, reader):
        _id = reader.read_int()
        _random_id = reader.read_long()
        return cls(id=_id, random_id=_random_id)


class UpdateNewChannelMessage(TLObject):
    CONSTRUCTOR_ID = 0x62ba04d9
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, message, pts, pts_count):
        """
        :param TypeMessage message:
        :param int pts:
        :param int pts_count:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages, UpdateDialogUnreadMark.
        """
        self.message = message  # type: TypeMessage
        self.pts = pts  # type: int
        self.pts_count = pts_count  # type: int

    def to_dict(self):
        return {
            '_': 'UpdateNewChannelMessage',
            'message': None if self.message is None else self.message.to_dict(),
            'pts': self.pts,
            'pts_count': self.pts_count
        }

    def __bytes__(self):
        return b''.join((
            b'\xd9\x04\xbab',
            bytes(self.message),
            struct.pack('<i', self.pts),
            struct.pack('<i', self.pts_count),
        ))

    @classmethod
    def from_reader(cls, reader):
        _message = reader.tgread_object()
        _pts = reader.read_int()
        _pts_count = reader.read_int()
        return cls(message=_message, pts=_pts, pts_count=_pts_count)


class UpdateNewEncryptedMessage(TLObject):
    CONSTRUCTOR_ID = 0x12bcbd9a
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, message, qts):
        """
        :param TypeEncryptedMessage message:
        :param int qts:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages, UpdateDialogUnreadMark.
        """
        self.message = message  # type: TypeEncryptedMessage
        self.qts = qts  # type: int

    def to_dict(self):
        return {
            '_': 'UpdateNewEncryptedMessage',
            'message': None if self.message is None else self.message.to_dict(),
            'qts': self.qts
        }

    def __bytes__(self):
        return b''.join((
            b'\x9a\xbd\xbc\x12',
            bytes(self.message),
            struct.pack('<i', self.qts),
        ))

    @classmethod
    def from_reader(cls, reader):
        _message = reader.tgread_object()
        _qts = reader.read_int()
        return cls(message=_message, qts=_qts)


class UpdateNewMessage(TLObject):
    CONSTRUCTOR_ID = 0x1f2b0afd
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, message, pts, pts_count):
        """
        :param TypeMessage message:
        :param int pts:
        :param int pts_count:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages, UpdateDialogUnreadMark.
        """
        self.message = message  # type: TypeMessage
        self.pts = pts  # type: int
        self.pts_count = pts_count  # type: int

    def to_dict(self):
        return {
            '_': 'UpdateNewMessage',
            'message': None if self.message is None else self.message.to_dict(),
            'pts': self.pts,
            'pts_count': self.pts_count
        }

    def __bytes__(self):
        return b''.join((
            b'\xfd\n+\x1f',
            bytes(self.message),
            struct.pack('<i', self.pts),
            struct.pack('<i', self.pts_count),
        ))

    @classmethod
    def from_reader(cls, reader):
        _message = reader.tgread_object()
        _pts = reader.read_int()
        _pts_count = reader.read_int()
        return cls(message=_message, pts=_pts, pts_count=_pts_count)


class UpdateNewStickerSet(TLObject):
    CONSTRUCTOR_ID = 0x688a30aa
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, stickerset):
        """
        :param TypeStickerSet stickerset:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages, UpdateDialogUnreadMark.
        """
        self.stickerset = stickerset  # type: TypeStickerSet

    def to_dict(self):
        return {
            '_': 'UpdateNewStickerSet',
            'stickerset': None if self.stickerset is None else self.stickerset.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\xaa0\x8ah',
            bytes(self.stickerset),
        ))

    @classmethod
    def from_reader(cls, reader):
        _stickerset = reader.tgread_object()
        return cls(stickerset=_stickerset)


class UpdateNotifySettings(TLObject):
    CONSTRUCTOR_ID = 0xbec268ef
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, peer, notify_settings):
        """
        :param TypeNotifyPeer peer:
        :param TypePeerNotifySettings notify_settings:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages, UpdateDialogUnreadMark.
        """
        self.peer = peer  # type: TypeNotifyPeer
        self.notify_settings = notify_settings  # type: TypePeerNotifySettings

    def to_dict(self):
        return {
            '_': 'UpdateNotifySettings',
            'peer': None if self.peer is None else self.peer.to_dict(),
            'notify_settings': None if self.notify_settings is None else self.notify_settings.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\xefh\xc2\xbe',
            bytes(self.peer),
            bytes(self.notify_settings),
        ))

    @classmethod
    def from_reader(cls, reader):
        _peer = reader.tgread_object()
        _notify_settings = reader.tgread_object()
        return cls(peer=_peer, notify_settings=_notify_settings)


class UpdatePhoneCall(TLObject):
    CONSTRUCTOR_ID = 0xab0f6b1e
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, phone_call):
        """
        :param TypePhoneCall phone_call:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages, UpdateDialogUnreadMark.
        """
        self.phone_call = phone_call  # type: TypePhoneCall

    def to_dict(self):
        return {
            '_': 'UpdatePhoneCall',
            'phone_call': None if self.phone_call is None else self.phone_call.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\x1ek\x0f\xab',
            bytes(self.phone_call),
        ))

    @classmethod
    def from_reader(cls, reader):
        _phone_call = reader.tgread_object()
        return cls(phone_call=_phone_call)


class UpdatePinnedDialogs(TLObject):
    CONSTRUCTOR_ID = 0xea4cb65b
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, order=None):
        """
        :param Optional[List[TypeDialogPeer]] order:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages, UpdateDialogUnreadMark.
        """
        self.order = order  # type: Optional[List[TypeDialogPeer]]

    def to_dict(self):
        return {
            '_': 'UpdatePinnedDialogs',
            'order': [] if self.order is None else [None if x is None else x.to_dict() for x in self.order]
        }

    def __bytes__(self):
        return b''.join((
            b'[\xb6L\xea',
            struct.pack('<I', (0 if self.order is None or self.order is False else 1)),
            b'' if self.order is None or self.order is False else b''.join((b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.order)),b''.join(bytes(x) for x in self.order))),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        if flags & 1:
            reader.read_int()
            _order = []
            for _ in range(reader.read_int()):
                _x = reader.tgread_object()
                _order.append(_x)

        else:
            _order = None
        return cls(order=_order)


class UpdatePrivacy(TLObject):
    CONSTRUCTOR_ID = 0xee3b272a
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, key, rules):
        """
        :param TypePrivacyKey key:
        :param List[TypePrivacyRule] rules:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages, UpdateDialogUnreadMark.
        """
        self.key = key  # type: TypePrivacyKey
        self.rules = rules  # type: List[TypePrivacyRule]

    def to_dict(self):
        return {
            '_': 'UpdatePrivacy',
            'key': None if self.key is None else self.key.to_dict(),
            'rules': [] if self.rules is None else [None if x is None else x.to_dict() for x in self.rules]
        }

    def __bytes__(self):
        return b''.join((
            b"*';\xee",
            bytes(self.key),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.rules)),b''.join(bytes(x) for x in self.rules),
        ))

    @classmethod
    def from_reader(cls, reader):
        _key = reader.tgread_object()
        reader.read_int()
        _rules = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _rules.append(_x)

        return cls(key=_key, rules=_rules)


class UpdatePtsChanged(TLObject):
    CONSTRUCTOR_ID = 0x3354678f
    SUBCLASS_OF_ID = 0x9f89304e

    def to_dict(self):
        return {
            '_': 'UpdatePtsChanged'
        }

    def __bytes__(self):
        return b''.join((
            b'\x8fgT3',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class UpdateReadChannelInbox(TLObject):
    CONSTRUCTOR_ID = 0x4214f37f
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, channel_id, max_id):
        """
        :param int channel_id:
        :param int max_id:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages, UpdateDialogUnreadMark.
        """
        self.channel_id = channel_id  # type: int
        self.max_id = max_id  # type: int

    def to_dict(self):
        return {
            '_': 'UpdateReadChannelInbox',
            'channel_id': self.channel_id,
            'max_id': self.max_id
        }

    def __bytes__(self):
        return b''.join((
            b'\x7f\xf3\x14B',
            struct.pack('<i', self.channel_id),
            struct.pack('<i', self.max_id),
        ))

    @classmethod
    def from_reader(cls, reader):
        _channel_id = reader.read_int()
        _max_id = reader.read_int()
        return cls(channel_id=_channel_id, max_id=_max_id)


class UpdateReadChannelOutbox(TLObject):
    CONSTRUCTOR_ID = 0x25d6c9c7
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, channel_id, max_id):
        """
        :param int channel_id:
        :param int max_id:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages, UpdateDialogUnreadMark.
        """
        self.channel_id = channel_id  # type: int
        self.max_id = max_id  # type: int

    def to_dict(self):
        return {
            '_': 'UpdateReadChannelOutbox',
            'channel_id': self.channel_id,
            'max_id': self.max_id
        }

    def __bytes__(self):
        return b''.join((
            b'\xc7\xc9\xd6%',
            struct.pack('<i', self.channel_id),
            struct.pack('<i', self.max_id),
        ))

    @classmethod
    def from_reader(cls, reader):
        _channel_id = reader.read_int()
        _max_id = reader.read_int()
        return cls(channel_id=_channel_id, max_id=_max_id)


class UpdateReadFeaturedStickers(TLObject):
    CONSTRUCTOR_ID = 0x571d2742
    SUBCLASS_OF_ID = 0x9f89304e

    def to_dict(self):
        return {
            '_': 'UpdateReadFeaturedStickers'
        }

    def __bytes__(self):
        return b''.join((
            b"B'\x1dW",
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class UpdateReadHistoryInbox(TLObject):
    CONSTRUCTOR_ID = 0x9961fd5c
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, peer, max_id, pts, pts_count):
        """
        :param TypePeer peer:
        :param int max_id:
        :param int pts:
        :param int pts_count:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages, UpdateDialogUnreadMark.
        """
        self.peer = peer  # type: TypePeer
        self.max_id = max_id  # type: int
        self.pts = pts  # type: int
        self.pts_count = pts_count  # type: int

    def to_dict(self):
        return {
            '_': 'UpdateReadHistoryInbox',
            'peer': None if self.peer is None else self.peer.to_dict(),
            'max_id': self.max_id,
            'pts': self.pts,
            'pts_count': self.pts_count
        }

    def __bytes__(self):
        return b''.join((
            b'\\\xfda\x99',
            bytes(self.peer),
            struct.pack('<i', self.max_id),
            struct.pack('<i', self.pts),
            struct.pack('<i', self.pts_count),
        ))

    @classmethod
    def from_reader(cls, reader):
        _peer = reader.tgread_object()
        _max_id = reader.read_int()
        _pts = reader.read_int()
        _pts_count = reader.read_int()
        return cls(peer=_peer, max_id=_max_id, pts=_pts, pts_count=_pts_count)


class UpdateReadHistoryOutbox(TLObject):
    CONSTRUCTOR_ID = 0x2f2f21bf
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, peer, max_id, pts, pts_count):
        """
        :param TypePeer peer:
        :param int max_id:
        :param int pts:
        :param int pts_count:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages, UpdateDialogUnreadMark.
        """
        self.peer = peer  # type: TypePeer
        self.max_id = max_id  # type: int
        self.pts = pts  # type: int
        self.pts_count = pts_count  # type: int

    def to_dict(self):
        return {
            '_': 'UpdateReadHistoryOutbox',
            'peer': None if self.peer is None else self.peer.to_dict(),
            'max_id': self.max_id,
            'pts': self.pts,
            'pts_count': self.pts_count
        }

    def __bytes__(self):
        return b''.join((
            b'\xbf!//',
            bytes(self.peer),
            struct.pack('<i', self.max_id),
            struct.pack('<i', self.pts),
            struct.pack('<i', self.pts_count),
        ))

    @classmethod
    def from_reader(cls, reader):
        _peer = reader.tgread_object()
        _max_id = reader.read_int()
        _pts = reader.read_int()
        _pts_count = reader.read_int()
        return cls(peer=_peer, max_id=_max_id, pts=_pts, pts_count=_pts_count)


class UpdateReadMessagesContents(TLObject):
    CONSTRUCTOR_ID = 0x68c13933
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, messages, pts, pts_count):
        """
        :param List[int] messages:
        :param int pts:
        :param int pts_count:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages, UpdateDialogUnreadMark.
        """
        self.messages = messages  # type: List[int]
        self.pts = pts  # type: int
        self.pts_count = pts_count  # type: int

    def to_dict(self):
        return {
            '_': 'UpdateReadMessagesContents',
            'messages': [] if self.messages is None else self.messages[:],
            'pts': self.pts,
            'pts_count': self.pts_count
        }

    def __bytes__(self):
        return b''.join((
            b'39\xc1h',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.messages)),b''.join(struct.pack('<i', x) for x in self.messages),
            struct.pack('<i', self.pts),
            struct.pack('<i', self.pts_count),
        ))

    @classmethod
    def from_reader(cls, reader):
        reader.read_int()
        _messages = []
        for _ in range(reader.read_int()):
            _x = reader.read_int()
            _messages.append(_x)

        _pts = reader.read_int()
        _pts_count = reader.read_int()
        return cls(messages=_messages, pts=_pts, pts_count=_pts_count)


class UpdateRecentStickers(TLObject):
    CONSTRUCTOR_ID = 0x9a422c20
    SUBCLASS_OF_ID = 0x9f89304e

    def to_dict(self):
        return {
            '_': 'UpdateRecentStickers'
        }

    def __bytes__(self):
        return b''.join((
            b' ,B\x9a',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class UpdateSavedGifs(TLObject):
    CONSTRUCTOR_ID = 0x9375341e
    SUBCLASS_OF_ID = 0x9f89304e

    def to_dict(self):
        return {
            '_': 'UpdateSavedGifs'
        }

    def __bytes__(self):
        return b''.join((
            b'\x1e4u\x93',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class UpdateServiceNotification(TLObject):
    CONSTRUCTOR_ID = 0xebe46819
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, type, message, media, entities, popup=None, inbox_date=None):
        """
        :param str type:
        :param str message:
        :param TypeMessageMedia media:
        :param List[TypeMessageEntity] entities:
        :param Optional[bool] popup:
        :param Optional[datetime] inbox_date:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages, UpdateDialogUnreadMark.
        """
        self.type = type  # type: str
        self.message = message  # type: str
        self.media = media  # type: TypeMessageMedia
        self.entities = entities  # type: List[TypeMessageEntity]
        self.popup = popup  # type: Optional[bool]
        self.inbox_date = inbox_date  # type: Optional[datetime]

    def to_dict(self):
        return {
            '_': 'UpdateServiceNotification',
            'type': self.type,
            'message': self.message,
            'media': None if self.media is None else self.media.to_dict(),
            'entities': [] if self.entities is None else [None if x is None else x.to_dict() for x in self.entities],
            'popup': self.popup,
            'inbox_date': self.inbox_date
        }

    def __bytes__(self):
        return b''.join((
            b'\x19h\xe4\xeb',
            struct.pack('<I', (0 if self.popup is None or self.popup is False else 1) | (0 if self.inbox_date is None or self.inbox_date is False else 2)),
            b'' if self.inbox_date is None or self.inbox_date is False else (self.serialize_datetime(self.inbox_date)),
            self.serialize_bytes(self.type),
            self.serialize_bytes(self.message),
            bytes(self.media),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.entities)),b''.join(bytes(x) for x in self.entities),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _popup = bool(flags & 1)
        if flags & 2:
            _inbox_date = reader.tgread_date()
        else:
            _inbox_date = None
        _type = reader.tgread_string()
        _message = reader.tgread_string()
        _media = reader.tgread_object()
        reader.read_int()
        _entities = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _entities.append(_x)

        return cls(type=_type, message=_message, media=_media, entities=_entities, popup=_popup, inbox_date=_inbox_date)


class UpdateShort(TLObject):
    CONSTRUCTOR_ID = 0x78d4dec1
    SUBCLASS_OF_ID = 0x8af52aac

    def __init__(self, update, date):
        """
        :param TypeUpdate update:
        :param Optional[datetime] date:

        Constructor for Updates: Instance of either UpdatesTooLong, UpdateShortMessage, UpdateShortChatMessage, UpdateShort, UpdatesCombined, Updates, UpdateShortSentMessage.
        """
        self.update = update  # type: TypeUpdate
        self.date = date  # type: Optional[datetime]

    def to_dict(self):
        return {
            '_': 'UpdateShort',
            'update': None if self.update is None else self.update.to_dict(),
            'date': self.date
        }

    def __bytes__(self):
        return b''.join((
            b'\xc1\xde\xd4x',
            bytes(self.update),
            self.serialize_datetime(self.date),
        ))

    @classmethod
    def from_reader(cls, reader):
        _update = reader.tgread_object()
        _date = reader.tgread_date()
        return cls(update=_update, date=_date)


class UpdateShortChatMessage(TLObject):
    CONSTRUCTOR_ID = 0x16812688
    SUBCLASS_OF_ID = 0x8af52aac

    def __init__(self, id, from_id, chat_id, message, pts, pts_count, date, out=None, mentioned=None, media_unread=None, silent=None, fwd_from=None, via_bot_id=None, reply_to_msg_id=None, entities=None):
        """
        :param int id:
        :param int from_id:
        :param int chat_id:
        :param str message:
        :param int pts:
        :param int pts_count:
        :param Optional[datetime] date:
        :param Optional[bool] out:
        :param Optional[bool] mentioned:
        :param Optional[bool] media_unread:
        :param Optional[bool] silent:
        :param Optional[TypeMessageFwdHeader] fwd_from:
        :param Optional[int] via_bot_id:
        :param Optional[int] reply_to_msg_id:
        :param Optional[List[TypeMessageEntity]] entities:

        Constructor for Updates: Instance of either UpdatesTooLong, UpdateShortMessage, UpdateShortChatMessage, UpdateShort, UpdatesCombined, Updates, UpdateShortSentMessage.
        """
        self.id = id  # type: int
        self.from_id = from_id  # type: int
        self.chat_id = chat_id  # type: int
        self.message = message  # type: str
        self.pts = pts  # type: int
        self.pts_count = pts_count  # type: int
        self.date = date  # type: Optional[datetime]
        self.out = out  # type: Optional[bool]
        self.mentioned = mentioned  # type: Optional[bool]
        self.media_unread = media_unread  # type: Optional[bool]
        self.silent = silent  # type: Optional[bool]
        self.fwd_from = fwd_from  # type: Optional[TypeMessageFwdHeader]
        self.via_bot_id = via_bot_id  # type: Optional[int]
        self.reply_to_msg_id = reply_to_msg_id  # type: Optional[int]
        self.entities = entities  # type: Optional[List[TypeMessageEntity]]

    def to_dict(self):
        return {
            '_': 'UpdateShortChatMessage',
            'id': self.id,
            'from_id': self.from_id,
            'chat_id': self.chat_id,
            'message': self.message,
            'pts': self.pts,
            'pts_count': self.pts_count,
            'date': self.date,
            'out': self.out,
            'mentioned': self.mentioned,
            'media_unread': self.media_unread,
            'silent': self.silent,
            'fwd_from': None if self.fwd_from is None else self.fwd_from.to_dict(),
            'via_bot_id': self.via_bot_id,
            'reply_to_msg_id': self.reply_to_msg_id,
            'entities': [] if self.entities is None else [None if x is None else x.to_dict() for x in self.entities]
        }

    def __bytes__(self):
        return b''.join((
            b'\x88&\x81\x16',
            struct.pack('<I', (0 if self.out is None or self.out is False else 2) | (0 if self.mentioned is None or self.mentioned is False else 16) | (0 if self.media_unread is None or self.media_unread is False else 32) | (0 if self.silent is None or self.silent is False else 8192) | (0 if self.fwd_from is None or self.fwd_from is False else 4) | (0 if self.via_bot_id is None or self.via_bot_id is False else 2048) | (0 if self.reply_to_msg_id is None or self.reply_to_msg_id is False else 8) | (0 if self.entities is None or self.entities is False else 128)),
            struct.pack('<i', self.id),
            struct.pack('<i', self.from_id),
            struct.pack('<i', self.chat_id),
            self.serialize_bytes(self.message),
            struct.pack('<i', self.pts),
            struct.pack('<i', self.pts_count),
            self.serialize_datetime(self.date),
            b'' if self.fwd_from is None or self.fwd_from is False else (bytes(self.fwd_from)),
            b'' if self.via_bot_id is None or self.via_bot_id is False else (struct.pack('<i', self.via_bot_id)),
            b'' if self.reply_to_msg_id is None or self.reply_to_msg_id is False else (struct.pack('<i', self.reply_to_msg_id)),
            b'' if self.entities is None or self.entities is False else b''.join((b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.entities)),b''.join(bytes(x) for x in self.entities))),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _out = bool(flags & 2)
        _mentioned = bool(flags & 16)
        _media_unread = bool(flags & 32)
        _silent = bool(flags & 8192)
        _id = reader.read_int()
        _from_id = reader.read_int()
        _chat_id = reader.read_int()
        _message = reader.tgread_string()
        _pts = reader.read_int()
        _pts_count = reader.read_int()
        _date = reader.tgread_date()
        if flags & 4:
            _fwd_from = reader.tgread_object()
        else:
            _fwd_from = None
        if flags & 2048:
            _via_bot_id = reader.read_int()
        else:
            _via_bot_id = None
        if flags & 8:
            _reply_to_msg_id = reader.read_int()
        else:
            _reply_to_msg_id = None
        if flags & 128:
            reader.read_int()
            _entities = []
            for _ in range(reader.read_int()):
                _x = reader.tgread_object()
                _entities.append(_x)

        else:
            _entities = None
        return cls(id=_id, from_id=_from_id, chat_id=_chat_id, message=_message, pts=_pts, pts_count=_pts_count, date=_date, out=_out, mentioned=_mentioned, media_unread=_media_unread, silent=_silent, fwd_from=_fwd_from, via_bot_id=_via_bot_id, reply_to_msg_id=_reply_to_msg_id, entities=_entities)


class UpdateShortMessage(TLObject):
    CONSTRUCTOR_ID = 0x914fbf11
    SUBCLASS_OF_ID = 0x8af52aac

    def __init__(self, id, user_id, message, pts, pts_count, date, out=None, mentioned=None, media_unread=None, silent=None, fwd_from=None, via_bot_id=None, reply_to_msg_id=None, entities=None):
        """
        :param int id:
        :param int user_id:
        :param str message:
        :param int pts:
        :param int pts_count:
        :param Optional[datetime] date:
        :param Optional[bool] out:
        :param Optional[bool] mentioned:
        :param Optional[bool] media_unread:
        :param Optional[bool] silent:
        :param Optional[TypeMessageFwdHeader] fwd_from:
        :param Optional[int] via_bot_id:
        :param Optional[int] reply_to_msg_id:
        :param Optional[List[TypeMessageEntity]] entities:

        Constructor for Updates: Instance of either UpdatesTooLong, UpdateShortMessage, UpdateShortChatMessage, UpdateShort, UpdatesCombined, Updates, UpdateShortSentMessage.
        """
        self.id = id  # type: int
        self.user_id = user_id  # type: int
        self.message = message  # type: str
        self.pts = pts  # type: int
        self.pts_count = pts_count  # type: int
        self.date = date  # type: Optional[datetime]
        self.out = out  # type: Optional[bool]
        self.mentioned = mentioned  # type: Optional[bool]
        self.media_unread = media_unread  # type: Optional[bool]
        self.silent = silent  # type: Optional[bool]
        self.fwd_from = fwd_from  # type: Optional[TypeMessageFwdHeader]
        self.via_bot_id = via_bot_id  # type: Optional[int]
        self.reply_to_msg_id = reply_to_msg_id  # type: Optional[int]
        self.entities = entities  # type: Optional[List[TypeMessageEntity]]

    def to_dict(self):
        return {
            '_': 'UpdateShortMessage',
            'id': self.id,
            'user_id': self.user_id,
            'message': self.message,
            'pts': self.pts,
            'pts_count': self.pts_count,
            'date': self.date,
            'out': self.out,
            'mentioned': self.mentioned,
            'media_unread': self.media_unread,
            'silent': self.silent,
            'fwd_from': None if self.fwd_from is None else self.fwd_from.to_dict(),
            'via_bot_id': self.via_bot_id,
            'reply_to_msg_id': self.reply_to_msg_id,
            'entities': [] if self.entities is None else [None if x is None else x.to_dict() for x in self.entities]
        }

    def __bytes__(self):
        return b''.join((
            b'\x11\xbfO\x91',
            struct.pack('<I', (0 if self.out is None or self.out is False else 2) | (0 if self.mentioned is None or self.mentioned is False else 16) | (0 if self.media_unread is None or self.media_unread is False else 32) | (0 if self.silent is None or self.silent is False else 8192) | (0 if self.fwd_from is None or self.fwd_from is False else 4) | (0 if self.via_bot_id is None or self.via_bot_id is False else 2048) | (0 if self.reply_to_msg_id is None or self.reply_to_msg_id is False else 8) | (0 if self.entities is None or self.entities is False else 128)),
            struct.pack('<i', self.id),
            struct.pack('<i', self.user_id),
            self.serialize_bytes(self.message),
            struct.pack('<i', self.pts),
            struct.pack('<i', self.pts_count),
            self.serialize_datetime(self.date),
            b'' if self.fwd_from is None or self.fwd_from is False else (bytes(self.fwd_from)),
            b'' if self.via_bot_id is None or self.via_bot_id is False else (struct.pack('<i', self.via_bot_id)),
            b'' if self.reply_to_msg_id is None or self.reply_to_msg_id is False else (struct.pack('<i', self.reply_to_msg_id)),
            b'' if self.entities is None or self.entities is False else b''.join((b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.entities)),b''.join(bytes(x) for x in self.entities))),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _out = bool(flags & 2)
        _mentioned = bool(flags & 16)
        _media_unread = bool(flags & 32)
        _silent = bool(flags & 8192)
        _id = reader.read_int()
        _user_id = reader.read_int()
        _message = reader.tgread_string()
        _pts = reader.read_int()
        _pts_count = reader.read_int()
        _date = reader.tgread_date()
        if flags & 4:
            _fwd_from = reader.tgread_object()
        else:
            _fwd_from = None
        if flags & 2048:
            _via_bot_id = reader.read_int()
        else:
            _via_bot_id = None
        if flags & 8:
            _reply_to_msg_id = reader.read_int()
        else:
            _reply_to_msg_id = None
        if flags & 128:
            reader.read_int()
            _entities = []
            for _ in range(reader.read_int()):
                _x = reader.tgread_object()
                _entities.append(_x)

        else:
            _entities = None
        return cls(id=_id, user_id=_user_id, message=_message, pts=_pts, pts_count=_pts_count, date=_date, out=_out, mentioned=_mentioned, media_unread=_media_unread, silent=_silent, fwd_from=_fwd_from, via_bot_id=_via_bot_id, reply_to_msg_id=_reply_to_msg_id, entities=_entities)


class UpdateShortSentMessage(TLObject):
    CONSTRUCTOR_ID = 0x11f1331c
    SUBCLASS_OF_ID = 0x8af52aac

    def __init__(self, id, pts, pts_count, date, out=None, media=None, entities=None):
        """
        :param int id:
        :param int pts:
        :param int pts_count:
        :param Optional[datetime] date:
        :param Optional[bool] out:
        :param Optional[TypeMessageMedia] media:
        :param Optional[List[TypeMessageEntity]] entities:

        Constructor for Updates: Instance of either UpdatesTooLong, UpdateShortMessage, UpdateShortChatMessage, UpdateShort, UpdatesCombined, Updates, UpdateShortSentMessage.
        """
        self.id = id  # type: int
        self.pts = pts  # type: int
        self.pts_count = pts_count  # type: int
        self.date = date  # type: Optional[datetime]
        self.out = out  # type: Optional[bool]
        self.media = media  # type: Optional[TypeMessageMedia]
        self.entities = entities  # type: Optional[List[TypeMessageEntity]]

    def to_dict(self):
        return {
            '_': 'UpdateShortSentMessage',
            'id': self.id,
            'pts': self.pts,
            'pts_count': self.pts_count,
            'date': self.date,
            'out': self.out,
            'media': None if self.media is None else self.media.to_dict(),
            'entities': [] if self.entities is None else [None if x is None else x.to_dict() for x in self.entities]
        }

    def __bytes__(self):
        return b''.join((
            b'\x1c3\xf1\x11',
            struct.pack('<I', (0 if self.out is None or self.out is False else 2) | (0 if self.media is None or self.media is False else 512) | (0 if self.entities is None or self.entities is False else 128)),
            struct.pack('<i', self.id),
            struct.pack('<i', self.pts),
            struct.pack('<i', self.pts_count),
            self.serialize_datetime(self.date),
            b'' if self.media is None or self.media is False else (bytes(self.media)),
            b'' if self.entities is None or self.entities is False else b''.join((b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.entities)),b''.join(bytes(x) for x in self.entities))),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _out = bool(flags & 2)
        _id = reader.read_int()
        _pts = reader.read_int()
        _pts_count = reader.read_int()
        _date = reader.tgread_date()
        if flags & 512:
            _media = reader.tgread_object()
        else:
            _media = None
        if flags & 128:
            reader.read_int()
            _entities = []
            for _ in range(reader.read_int()):
                _x = reader.tgread_object()
                _entities.append(_x)

        else:
            _entities = None
        return cls(id=_id, pts=_pts, pts_count=_pts_count, date=_date, out=_out, media=_media, entities=_entities)


class UpdateStickerSets(TLObject):
    CONSTRUCTOR_ID = 0x43ae3dec
    SUBCLASS_OF_ID = 0x9f89304e

    def to_dict(self):
        return {
            '_': 'UpdateStickerSets'
        }

    def __bytes__(self):
        return b''.join((
            b'\xec=\xaeC',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class UpdateStickerSetsOrder(TLObject):
    CONSTRUCTOR_ID = 0xbb2d201
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, order, masks=None):
        """
        :param List[int] order:
        :param Optional[bool] masks:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages, UpdateDialogUnreadMark.
        """
        self.order = order  # type: List[int]
        self.masks = masks  # type: Optional[bool]

    def to_dict(self):
        return {
            '_': 'UpdateStickerSetsOrder',
            'order': [] if self.order is None else self.order[:],
            'masks': self.masks
        }

    def __bytes__(self):
        return b''.join((
            b'\x01\xd2\xb2\x0b',
            struct.pack('<I', (0 if self.masks is None or self.masks is False else 1)),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.order)),b''.join(struct.pack('<q', x) for x in self.order),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _masks = bool(flags & 1)
        reader.read_int()
        _order = []
        for _ in range(reader.read_int()):
            _x = reader.read_long()
            _order.append(_x)

        return cls(order=_order, masks=_masks)


class UpdateUserBlocked(TLObject):
    CONSTRUCTOR_ID = 0x80ece81a
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, user_id, blocked):
        """
        :param int user_id:
        :param TypeBool blocked:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages, UpdateDialogUnreadMark.
        """
        self.user_id = user_id  # type: int
        self.blocked = blocked  # type: TypeBool

    def to_dict(self):
        return {
            '_': 'UpdateUserBlocked',
            'user_id': self.user_id,
            'blocked': self.blocked
        }

    def __bytes__(self):
        return b''.join((
            b'\x1a\xe8\xec\x80',
            struct.pack('<i', self.user_id),
            b'\xb5ur\x99' if self.blocked else b'7\x97y\xbc',
        ))

    @classmethod
    def from_reader(cls, reader):
        _user_id = reader.read_int()
        _blocked = reader.tgread_bool()
        return cls(user_id=_user_id, blocked=_blocked)


class UpdateUserName(TLObject):
    CONSTRUCTOR_ID = 0xa7332b73
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, user_id, first_name, last_name, username):
        """
        :param int user_id:
        :param str first_name:
        :param str last_name:
        :param str username:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages, UpdateDialogUnreadMark.
        """
        self.user_id = user_id  # type: int
        self.first_name = first_name  # type: str
        self.last_name = last_name  # type: str
        self.username = username  # type: str

    def to_dict(self):
        return {
            '_': 'UpdateUserName',
            'user_id': self.user_id,
            'first_name': self.first_name,
            'last_name': self.last_name,
            'username': self.username
        }

    def __bytes__(self):
        return b''.join((
            b's+3\xa7',
            struct.pack('<i', self.user_id),
            self.serialize_bytes(self.first_name),
            self.serialize_bytes(self.last_name),
            self.serialize_bytes(self.username),
        ))

    @classmethod
    def from_reader(cls, reader):
        _user_id = reader.read_int()
        _first_name = reader.tgread_string()
        _last_name = reader.tgread_string()
        _username = reader.tgread_string()
        return cls(user_id=_user_id, first_name=_first_name, last_name=_last_name, username=_username)


class UpdateUserPhone(TLObject):
    CONSTRUCTOR_ID = 0x12b9417b
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, user_id, phone):
        """
        :param int user_id:
        :param str phone:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages, UpdateDialogUnreadMark.
        """
        self.user_id = user_id  # type: int
        self.phone = phone  # type: str

    def to_dict(self):
        return {
            '_': 'UpdateUserPhone',
            'user_id': self.user_id,
            'phone': self.phone
        }

    def __bytes__(self):
        return b''.join((
            b'{A\xb9\x12',
            struct.pack('<i', self.user_id),
            self.serialize_bytes(self.phone),
        ))

    @classmethod
    def from_reader(cls, reader):
        _user_id = reader.read_int()
        _phone = reader.tgread_string()
        return cls(user_id=_user_id, phone=_phone)


class UpdateUserPhoto(TLObject):
    CONSTRUCTOR_ID = 0x95313b0c
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, user_id, date, photo, previous):
        """
        :param int user_id:
        :param Optional[datetime] date:
        :param TypeUserProfilePhoto photo:
        :param TypeBool previous:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages, UpdateDialogUnreadMark.
        """
        self.user_id = user_id  # type: int
        self.date = date  # type: Optional[datetime]
        self.photo = photo  # type: TypeUserProfilePhoto
        self.previous = previous  # type: TypeBool

    def to_dict(self):
        return {
            '_': 'UpdateUserPhoto',
            'user_id': self.user_id,
            'date': self.date,
            'photo': None if self.photo is None else self.photo.to_dict(),
            'previous': self.previous
        }

    def __bytes__(self):
        return b''.join((
            b'\x0c;1\x95',
            struct.pack('<i', self.user_id),
            self.serialize_datetime(self.date),
            bytes(self.photo),
            b'\xb5ur\x99' if self.previous else b'7\x97y\xbc',
        ))

    @classmethod
    def from_reader(cls, reader):
        _user_id = reader.read_int()
        _date = reader.tgread_date()
        _photo = reader.tgread_object()
        _previous = reader.tgread_bool()
        return cls(user_id=_user_id, date=_date, photo=_photo, previous=_previous)


class UpdateUserStatus(TLObject):
    CONSTRUCTOR_ID = 0x1bfbd823
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, user_id, status):
        """
        :param int user_id:
        :param TypeUserStatus status:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages, UpdateDialogUnreadMark.
        """
        self.user_id = user_id  # type: int
        self.status = status  # type: TypeUserStatus

    def to_dict(self):
        return {
            '_': 'UpdateUserStatus',
            'user_id': self.user_id,
            'status': None if self.status is None else self.status.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'#\xd8\xfb\x1b',
            struct.pack('<i', self.user_id),
            bytes(self.status),
        ))

    @classmethod
    def from_reader(cls, reader):
        _user_id = reader.read_int()
        _status = reader.tgread_object()
        return cls(user_id=_user_id, status=_status)


class UpdateUserTyping(TLObject):
    CONSTRUCTOR_ID = 0x5c486927
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, user_id, action):
        """
        :param int user_id:
        :param TypeSendMessageAction action:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages, UpdateDialogUnreadMark.
        """
        self.user_id = user_id  # type: int
        self.action = action  # type: TypeSendMessageAction

    def to_dict(self):
        return {
            '_': 'UpdateUserTyping',
            'user_id': self.user_id,
            'action': None if self.action is None else self.action.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b"'iH\\",
            struct.pack('<i', self.user_id),
            bytes(self.action),
        ))

    @classmethod
    def from_reader(cls, reader):
        _user_id = reader.read_int()
        _action = reader.tgread_object()
        return cls(user_id=_user_id, action=_action)


class UpdateWebPage(TLObject):
    CONSTRUCTOR_ID = 0x7f891213
    SUBCLASS_OF_ID = 0x9f89304e

    def __init__(self, webpage, pts, pts_count):
        """
        :param TypeWebPage webpage:
        :param int pts:
        :param int pts_count:

        Constructor for Update: Instance of either UpdateNewMessage, UpdateMessageID, UpdateDeleteMessages, UpdateUserTyping, UpdateChatUserTyping, UpdateChatParticipants, UpdateUserStatus, UpdateUserName, UpdateUserPhoto, UpdateContactRegistered, UpdateContactLink, UpdateNewEncryptedMessage, UpdateEncryptedChatTyping, UpdateEncryption, UpdateEncryptedMessagesRead, UpdateChatParticipantAdd, UpdateChatParticipantDelete, UpdateDcOptions, UpdateUserBlocked, UpdateNotifySettings, UpdateServiceNotification, UpdatePrivacy, UpdateUserPhone, UpdateReadHistoryInbox, UpdateReadHistoryOutbox, UpdateWebPage, UpdateReadMessagesContents, UpdateChannelTooLong, UpdateChannel, UpdateNewChannelMessage, UpdateReadChannelInbox, UpdateDeleteChannelMessages, UpdateChannelMessageViews, UpdateChatAdmins, UpdateChatParticipantAdmin, UpdateNewStickerSet, UpdateStickerSetsOrder, UpdateStickerSets, UpdateSavedGifs, UpdateBotInlineQuery, UpdateBotInlineSend, UpdateEditChannelMessage, UpdateChannelPinnedMessage, UpdateBotCallbackQuery, UpdateEditMessage, UpdateInlineBotCallbackQuery, UpdateReadChannelOutbox, UpdateDraftMessage, UpdateReadFeaturedStickers, UpdateRecentStickers, UpdateConfig, UpdatePtsChanged, UpdateChannelWebPage, UpdateDialogPinned, UpdatePinnedDialogs, UpdateBotWebhookJSON, UpdateBotWebhookJSONQuery, UpdateBotShippingQuery, UpdateBotPrecheckoutQuery, UpdatePhoneCall, UpdateLangPackTooLong, UpdateLangPack, UpdateFavedStickers, UpdateChannelReadMessagesContents, UpdateContactsReset, UpdateChannelAvailableMessages, UpdateDialogUnreadMark.
        """
        self.webpage = webpage  # type: TypeWebPage
        self.pts = pts  # type: int
        self.pts_count = pts_count  # type: int

    def to_dict(self):
        return {
            '_': 'UpdateWebPage',
            'webpage': None if self.webpage is None else self.webpage.to_dict(),
            'pts': self.pts,
            'pts_count': self.pts_count
        }

    def __bytes__(self):
        return b''.join((
            b'\x13\x12\x89\x7f',
            bytes(self.webpage),
            struct.pack('<i', self.pts),
            struct.pack('<i', self.pts_count),
        ))

    @classmethod
    def from_reader(cls, reader):
        _webpage = reader.tgread_object()
        _pts = reader.read_int()
        _pts_count = reader.read_int()
        return cls(webpage=_webpage, pts=_pts, pts_count=_pts_count)


class Updates(TLObject):
    CONSTRUCTOR_ID = 0x74ae4240
    SUBCLASS_OF_ID = 0x8af52aac

    def __init__(self, updates, users, chats, date, seq):
        """
        :param List[TypeUpdate] updates:
        :param List[TypeUser] users:
        :param List[TypeChat] chats:
        :param Optional[datetime] date:
        :param int seq:

        Constructor for Updates: Instance of either UpdatesTooLong, UpdateShortMessage, UpdateShortChatMessage, UpdateShort, UpdatesCombined, Updates, UpdateShortSentMessage.
        """
        self.updates = updates  # type: List[TypeUpdate]
        self.users = users  # type: List[TypeUser]
        self.chats = chats  # type: List[TypeChat]
        self.date = date  # type: Optional[datetime]
        self.seq = seq  # type: int

    def to_dict(self):
        return {
            '_': 'Updates',
            'updates': [] if self.updates is None else [None if x is None else x.to_dict() for x in self.updates],
            'users': [] if self.users is None else [None if x is None else x.to_dict() for x in self.users],
            'chats': [] if self.chats is None else [None if x is None else x.to_dict() for x in self.chats],
            'date': self.date,
            'seq': self.seq
        }

    def __bytes__(self):
        return b''.join((
            b'@B\xaet',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.updates)),b''.join(bytes(x) for x in self.updates),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.users)),b''.join(bytes(x) for x in self.users),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.chats)),b''.join(bytes(x) for x in self.chats),
            self.serialize_datetime(self.date),
            struct.pack('<i', self.seq),
        ))

    @classmethod
    def from_reader(cls, reader):
        reader.read_int()
        _updates = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _updates.append(_x)

        reader.read_int()
        _users = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _users.append(_x)

        reader.read_int()
        _chats = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _chats.append(_x)

        _date = reader.tgread_date()
        _seq = reader.read_int()
        return cls(updates=_updates, users=_users, chats=_chats, date=_date, seq=_seq)


class UpdatesCombined(TLObject):
    CONSTRUCTOR_ID = 0x725b04c3
    SUBCLASS_OF_ID = 0x8af52aac

    def __init__(self, updates, users, chats, date, seq_start, seq):
        """
        :param List[TypeUpdate] updates:
        :param List[TypeUser] users:
        :param List[TypeChat] chats:
        :param Optional[datetime] date:
        :param int seq_start:
        :param int seq:

        Constructor for Updates: Instance of either UpdatesTooLong, UpdateShortMessage, UpdateShortChatMessage, UpdateShort, UpdatesCombined, Updates, UpdateShortSentMessage.
        """
        self.updates = updates  # type: List[TypeUpdate]
        self.users = users  # type: List[TypeUser]
        self.chats = chats  # type: List[TypeChat]
        self.date = date  # type: Optional[datetime]
        self.seq_start = seq_start  # type: int
        self.seq = seq  # type: int

    def to_dict(self):
        return {
            '_': 'UpdatesCombined',
            'updates': [] if self.updates is None else [None if x is None else x.to_dict() for x in self.updates],
            'users': [] if self.users is None else [None if x is None else x.to_dict() for x in self.users],
            'chats': [] if self.chats is None else [None if x is None else x.to_dict() for x in self.chats],
            'date': self.date,
            'seq_start': self.seq_start,
            'seq': self.seq
        }

    def __bytes__(self):
        return b''.join((
            b'\xc3\x04[r',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.updates)),b''.join(bytes(x) for x in self.updates),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.users)),b''.join(bytes(x) for x in self.users),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.chats)),b''.join(bytes(x) for x in self.chats),
            self.serialize_datetime(self.date),
            struct.pack('<i', self.seq_start),
            struct.pack('<i', self.seq),
        ))

    @classmethod
    def from_reader(cls, reader):
        reader.read_int()
        _updates = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _updates.append(_x)

        reader.read_int()
        _users = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _users.append(_x)

        reader.read_int()
        _chats = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _chats.append(_x)

        _date = reader.tgread_date()
        _seq_start = reader.read_int()
        _seq = reader.read_int()
        return cls(updates=_updates, users=_users, chats=_chats, date=_date, seq_start=_seq_start, seq=_seq)


class UpdatesTooLong(TLObject):
    CONSTRUCTOR_ID = 0xe317af7e
    SUBCLASS_OF_ID = 0x8af52aac

    def to_dict(self):
        return {
            '_': 'UpdatesTooLong'
        }

    def __bytes__(self):
        return b''.join((
            b'~\xaf\x17\xe3',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class User(TLObject):
    CONSTRUCTOR_ID = 0x2e13f4c3
    SUBCLASS_OF_ID = 0x2da17977

    def __init__(self, id, is_self=None, contact=None, mutual_contact=None, deleted=None, bot=None, bot_chat_history=None, bot_nochats=None, verified=None, restricted=None, min=None, bot_inline_geo=None, access_hash=None, first_name=None, last_name=None, username=None, phone=None, photo=None, status=None, bot_info_version=None, restriction_reason=None, bot_inline_placeholder=None, lang_code=None):
        """
        :param int id:
        :param Optional[bool] is_self:
        :param Optional[bool] contact:
        :param Optional[bool] mutual_contact:
        :param Optional[bool] deleted:
        :param Optional[bool] bot:
        :param Optional[bool] bot_chat_history:
        :param Optional[bool] bot_nochats:
        :param Optional[bool] verified:
        :param Optional[bool] restricted:
        :param Optional[bool] min:
        :param Optional[bool] bot_inline_geo:
        :param Optional[int] access_hash:
        :param Optional[str] first_name:
        :param Optional[str] last_name:
        :param Optional[str] username:
        :param Optional[str] phone:
        :param Optional[TypeUserProfilePhoto] photo:
        :param Optional[TypeUserStatus] status:
        :param Optional[int] bot_info_version:
        :param Optional[str] restriction_reason:
        :param Optional[str] bot_inline_placeholder:
        :param Optional[str] lang_code:

        Constructor for User: Instance of either UserEmpty, User.
        """
        self.id = id  # type: int
        self.is_self = is_self  # type: Optional[bool]
        self.contact = contact  # type: Optional[bool]
        self.mutual_contact = mutual_contact  # type: Optional[bool]
        self.deleted = deleted  # type: Optional[bool]
        self.bot = bot  # type: Optional[bool]
        self.bot_chat_history = bot_chat_history  # type: Optional[bool]
        self.bot_nochats = bot_nochats  # type: Optional[bool]
        self.verified = verified  # type: Optional[bool]
        self.restricted = restricted  # type: Optional[bool]
        self.min = min  # type: Optional[bool]
        self.bot_inline_geo = bot_inline_geo  # type: Optional[bool]
        self.access_hash = access_hash  # type: Optional[int]
        self.first_name = first_name  # type: Optional[str]
        self.last_name = last_name  # type: Optional[str]
        self.username = username  # type: Optional[str]
        self.phone = phone  # type: Optional[str]
        self.photo = photo  # type: Optional[TypeUserProfilePhoto]
        self.status = status  # type: Optional[TypeUserStatus]
        self.bot_info_version = bot_info_version  # type: Optional[int]
        self.restriction_reason = restriction_reason  # type: Optional[str]
        self.bot_inline_placeholder = bot_inline_placeholder  # type: Optional[str]
        self.lang_code = lang_code  # type: Optional[str]

    def to_dict(self):
        return {
            '_': 'User',
            'id': self.id,
            'is_self': self.is_self,
            'contact': self.contact,
            'mutual_contact': self.mutual_contact,
            'deleted': self.deleted,
            'bot': self.bot,
            'bot_chat_history': self.bot_chat_history,
            'bot_nochats': self.bot_nochats,
            'verified': self.verified,
            'restricted': self.restricted,
            'min': self.min,
            'bot_inline_geo': self.bot_inline_geo,
            'access_hash': self.access_hash,
            'first_name': self.first_name,
            'last_name': self.last_name,
            'username': self.username,
            'phone': self.phone,
            'photo': None if self.photo is None else self.photo.to_dict(),
            'status': None if self.status is None else self.status.to_dict(),
            'bot_info_version': self.bot_info_version,
            'restriction_reason': self.restriction_reason,
            'bot_inline_placeholder': self.bot_inline_placeholder,
            'lang_code': self.lang_code
        }

    def __bytes__(self):
        assert ((self.bot or self.bot is not None) and (self.bot_info_version or self.bot_info_version is not None)) or ((self.bot is None or self.bot is False) and (self.bot_info_version is None or self.bot_info_version is False)), 'bot, bot_info_version parameters must all be False-y (like None) or all me True-y'
        assert ((self.restricted or self.restricted is not None) and (self.restriction_reason or self.restriction_reason is not None)) or ((self.restricted is None or self.restricted is False) and (self.restriction_reason is None or self.restriction_reason is False)), 'restricted, restriction_reason parameters must all be False-y (like None) or all me True-y'
        return b''.join((
            b'\xc3\xf4\x13.',
            struct.pack('<I', (0 if self.is_self is None or self.is_self is False else 1024) | (0 if self.contact is None or self.contact is False else 2048) | (0 if self.mutual_contact is None or self.mutual_contact is False else 4096) | (0 if self.deleted is None or self.deleted is False else 8192) | (0 if self.bot is None or self.bot is False else 16384) | (0 if self.bot_chat_history is None or self.bot_chat_history is False else 32768) | (0 if self.bot_nochats is None or self.bot_nochats is False else 65536) | (0 if self.verified is None or self.verified is False else 131072) | (0 if self.restricted is None or self.restricted is False else 262144) | (0 if self.min is None or self.min is False else 1048576) | (0 if self.bot_inline_geo is None or self.bot_inline_geo is False else 2097152) | (0 if self.access_hash is None or self.access_hash is False else 1) | (0 if self.first_name is None or self.first_name is False else 2) | (0 if self.last_name is None or self.last_name is False else 4) | (0 if self.username is None or self.username is False else 8) | (0 if self.phone is None or self.phone is False else 16) | (0 if self.photo is None or self.photo is False else 32) | (0 if self.status is None or self.status is False else 64) | (0 if self.bot_info_version is None or self.bot_info_version is False else 16384) | (0 if self.restriction_reason is None or self.restriction_reason is False else 262144) | (0 if self.bot_inline_placeholder is None or self.bot_inline_placeholder is False else 524288) | (0 if self.lang_code is None or self.lang_code is False else 4194304)),
            struct.pack('<i', self.id),
            b'' if self.access_hash is None or self.access_hash is False else (struct.pack('<q', self.access_hash)),
            b'' if self.first_name is None or self.first_name is False else (self.serialize_bytes(self.first_name)),
            b'' if self.last_name is None or self.last_name is False else (self.serialize_bytes(self.last_name)),
            b'' if self.username is None or self.username is False else (self.serialize_bytes(self.username)),
            b'' if self.phone is None or self.phone is False else (self.serialize_bytes(self.phone)),
            b'' if self.photo is None or self.photo is False else (bytes(self.photo)),
            b'' if self.status is None or self.status is False else (bytes(self.status)),
            b'' if self.bot_info_version is None or self.bot_info_version is False else (struct.pack('<i', self.bot_info_version)),
            b'' if self.restriction_reason is None or self.restriction_reason is False else (self.serialize_bytes(self.restriction_reason)),
            b'' if self.bot_inline_placeholder is None or self.bot_inline_placeholder is False else (self.serialize_bytes(self.bot_inline_placeholder)),
            b'' if self.lang_code is None or self.lang_code is False else (self.serialize_bytes(self.lang_code)),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _is_self = bool(flags & 1024)
        _contact = bool(flags & 2048)
        _mutual_contact = bool(flags & 4096)
        _deleted = bool(flags & 8192)
        _bot = bool(flags & 16384)
        _bot_chat_history = bool(flags & 32768)
        _bot_nochats = bool(flags & 65536)
        _verified = bool(flags & 131072)
        _restricted = bool(flags & 262144)
        _min = bool(flags & 1048576)
        _bot_inline_geo = bool(flags & 2097152)
        _id = reader.read_int()
        if flags & 1:
            _access_hash = reader.read_long()
        else:
            _access_hash = None
        if flags & 2:
            _first_name = reader.tgread_string()
        else:
            _first_name = None
        if flags & 4:
            _last_name = reader.tgread_string()
        else:
            _last_name = None
        if flags & 8:
            _username = reader.tgread_string()
        else:
            _username = None
        if flags & 16:
            _phone = reader.tgread_string()
        else:
            _phone = None
        if flags & 32:
            _photo = reader.tgread_object()
        else:
            _photo = None
        if flags & 64:
            _status = reader.tgread_object()
        else:
            _status = None
        if flags & 16384:
            _bot_info_version = reader.read_int()
        else:
            _bot_info_version = None
        if flags & 262144:
            _restriction_reason = reader.tgread_string()
        else:
            _restriction_reason = None
        if flags & 524288:
            _bot_inline_placeholder = reader.tgread_string()
        else:
            _bot_inline_placeholder = None
        if flags & 4194304:
            _lang_code = reader.tgread_string()
        else:
            _lang_code = None
        return cls(id=_id, is_self=_is_self, contact=_contact, mutual_contact=_mutual_contact, deleted=_deleted, bot=_bot, bot_chat_history=_bot_chat_history, bot_nochats=_bot_nochats, verified=_verified, restricted=_restricted, min=_min, bot_inline_geo=_bot_inline_geo, access_hash=_access_hash, first_name=_first_name, last_name=_last_name, username=_username, phone=_phone, photo=_photo, status=_status, bot_info_version=_bot_info_version, restriction_reason=_restriction_reason, bot_inline_placeholder=_bot_inline_placeholder, lang_code=_lang_code)


class UserEmpty(TLObject):
    CONSTRUCTOR_ID = 0x200250ba
    SUBCLASS_OF_ID = 0x2da17977

    def __init__(self, id):
        """
        :param int id:

        Constructor for User: Instance of either UserEmpty, User.
        """
        self.id = id  # type: int

    def to_dict(self):
        return {
            '_': 'UserEmpty',
            'id': self.id
        }

    def __bytes__(self):
        return b''.join((
            b'\xbaP\x02 ',
            struct.pack('<i', self.id),
        ))

    @classmethod
    def from_reader(cls, reader):
        _id = reader.read_int()
        return cls(id=_id)


class UserFull(TLObject):
    CONSTRUCTOR_ID = 0xf220f3f
    SUBCLASS_OF_ID = 0x1f4661b9

    def __init__(self, user, link, notify_settings, common_chats_count, blocked=None, phone_calls_available=None, phone_calls_private=None, about=None, profile_photo=None, bot_info=None):
        """
        :param TypeUser user:
        :param TypeLink link:
        :param TypePeerNotifySettings notify_settings:
        :param int common_chats_count:
        :param Optional[bool] blocked:
        :param Optional[bool] phone_calls_available:
        :param Optional[bool] phone_calls_private:
        :param Optional[str] about:
        :param Optional[TypePhoto] profile_photo:
        :param Optional[TypeBotInfo] bot_info:

        Constructor for UserFull: Instance of UserFull.
        """
        self.user = user  # type: TypeUser
        self.link = link  # type: TypeLink
        self.notify_settings = notify_settings  # type: TypePeerNotifySettings
        self.common_chats_count = common_chats_count  # type: int
        self.blocked = blocked  # type: Optional[bool]
        self.phone_calls_available = phone_calls_available  # type: Optional[bool]
        self.phone_calls_private = phone_calls_private  # type: Optional[bool]
        self.about = about  # type: Optional[str]
        self.profile_photo = profile_photo  # type: Optional[TypePhoto]
        self.bot_info = bot_info  # type: Optional[TypeBotInfo]

    def to_dict(self):
        return {
            '_': 'UserFull',
            'user': None if self.user is None else self.user.to_dict(),
            'link': None if self.link is None else self.link.to_dict(),
            'notify_settings': None if self.notify_settings is None else self.notify_settings.to_dict(),
            'common_chats_count': self.common_chats_count,
            'blocked': self.blocked,
            'phone_calls_available': self.phone_calls_available,
            'phone_calls_private': self.phone_calls_private,
            'about': self.about,
            'profile_photo': None if self.profile_photo is None else self.profile_photo.to_dict(),
            'bot_info': None if self.bot_info is None else self.bot_info.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'?\x0f"\x0f',
            struct.pack('<I', (0 if self.blocked is None or self.blocked is False else 1) | (0 if self.phone_calls_available is None or self.phone_calls_available is False else 16) | (0 if self.phone_calls_private is None or self.phone_calls_private is False else 32) | (0 if self.about is None or self.about is False else 2) | (0 if self.profile_photo is None or self.profile_photo is False else 4) | (0 if self.bot_info is None or self.bot_info is False else 8)),
            bytes(self.user),
            b'' if self.about is None or self.about is False else (self.serialize_bytes(self.about)),
            bytes(self.link),
            b'' if self.profile_photo is None or self.profile_photo is False else (bytes(self.profile_photo)),
            bytes(self.notify_settings),
            b'' if self.bot_info is None or self.bot_info is False else (bytes(self.bot_info)),
            struct.pack('<i', self.common_chats_count),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _blocked = bool(flags & 1)
        _phone_calls_available = bool(flags & 16)
        _phone_calls_private = bool(flags & 32)
        _user = reader.tgread_object()
        if flags & 2:
            _about = reader.tgread_string()
        else:
            _about = None
        _link = reader.tgread_object()
        if flags & 4:
            _profile_photo = reader.tgread_object()
        else:
            _profile_photo = None
        _notify_settings = reader.tgread_object()
        if flags & 8:
            _bot_info = reader.tgread_object()
        else:
            _bot_info = None
        _common_chats_count = reader.read_int()
        return cls(user=_user, link=_link, notify_settings=_notify_settings, common_chats_count=_common_chats_count, blocked=_blocked, phone_calls_available=_phone_calls_available, phone_calls_private=_phone_calls_private, about=_about, profile_photo=_profile_photo, bot_info=_bot_info)


class UserProfilePhoto(TLObject):
    CONSTRUCTOR_ID = 0xd559d8c8
    SUBCLASS_OF_ID = 0xc6338f7d

    def __init__(self, photo_id, photo_small, photo_big):
        """
        :param int photo_id:
        :param TypeFileLocation photo_small:
        :param TypeFileLocation photo_big:

        Constructor for UserProfilePhoto: Instance of either UserProfilePhotoEmpty, UserProfilePhoto.
        """
        self.photo_id = photo_id  # type: int
        self.photo_small = photo_small  # type: TypeFileLocation
        self.photo_big = photo_big  # type: TypeFileLocation

    def to_dict(self):
        return {
            '_': 'UserProfilePhoto',
            'photo_id': self.photo_id,
            'photo_small': None if self.photo_small is None else self.photo_small.to_dict(),
            'photo_big': None if self.photo_big is None else self.photo_big.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\xc8\xd8Y\xd5',
            struct.pack('<q', self.photo_id),
            bytes(self.photo_small),
            bytes(self.photo_big),
        ))

    @classmethod
    def from_reader(cls, reader):
        _photo_id = reader.read_long()
        _photo_small = reader.tgread_object()
        _photo_big = reader.tgread_object()
        return cls(photo_id=_photo_id, photo_small=_photo_small, photo_big=_photo_big)


class UserProfilePhotoEmpty(TLObject):
    CONSTRUCTOR_ID = 0x4f11bae1
    SUBCLASS_OF_ID = 0xc6338f7d

    def to_dict(self):
        return {
            '_': 'UserProfilePhotoEmpty'
        }

    def __bytes__(self):
        return b''.join((
            b'\xe1\xba\x11O',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class UserStatusEmpty(TLObject):
    CONSTRUCTOR_ID = 0x9d05049
    SUBCLASS_OF_ID = 0x5b0b743e

    def to_dict(self):
        return {
            '_': 'UserStatusEmpty'
        }

    def __bytes__(self):
        return b''.join((
            b'IP\xd0\t',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class UserStatusLastMonth(TLObject):
    CONSTRUCTOR_ID = 0x77ebc742
    SUBCLASS_OF_ID = 0x5b0b743e

    def to_dict(self):
        return {
            '_': 'UserStatusLastMonth'
        }

    def __bytes__(self):
        return b''.join((
            b'B\xc7\xebw',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class UserStatusLastWeek(TLObject):
    CONSTRUCTOR_ID = 0x7bf09fc
    SUBCLASS_OF_ID = 0x5b0b743e

    def to_dict(self):
        return {
            '_': 'UserStatusLastWeek'
        }

    def __bytes__(self):
        return b''.join((
            b'\xfc\t\xbf\x07',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class UserStatusOffline(TLObject):
    CONSTRUCTOR_ID = 0x8c703f
    SUBCLASS_OF_ID = 0x5b0b743e

    def __init__(self, was_online):
        """
        :param Optional[datetime] was_online:

        Constructor for UserStatus: Instance of either UserStatusEmpty, UserStatusOnline, UserStatusOffline, UserStatusRecently, UserStatusLastWeek, UserStatusLastMonth.
        """
        self.was_online = was_online  # type: Optional[datetime]

    def to_dict(self):
        return {
            '_': 'UserStatusOffline',
            'was_online': self.was_online
        }

    def __bytes__(self):
        return b''.join((
            b'?p\x8c\x00',
            self.serialize_datetime(self.was_online),
        ))

    @classmethod
    def from_reader(cls, reader):
        _was_online = reader.tgread_date()
        return cls(was_online=_was_online)


class UserStatusOnline(TLObject):
    CONSTRUCTOR_ID = 0xedb93949
    SUBCLASS_OF_ID = 0x5b0b743e

    def __init__(self, expires):
        """
        :param Optional[datetime] expires:

        Constructor for UserStatus: Instance of either UserStatusEmpty, UserStatusOnline, UserStatusOffline, UserStatusRecently, UserStatusLastWeek, UserStatusLastMonth.
        """
        self.expires = expires  # type: Optional[datetime]

    def to_dict(self):
        return {
            '_': 'UserStatusOnline',
            'expires': self.expires
        }

    def __bytes__(self):
        return b''.join((
            b'I9\xb9\xed',
            self.serialize_datetime(self.expires),
        ))

    @classmethod
    def from_reader(cls, reader):
        _expires = reader.tgread_date()
        return cls(expires=_expires)


class UserStatusRecently(TLObject):
    CONSTRUCTOR_ID = 0xe26f42f1
    SUBCLASS_OF_ID = 0x5b0b743e

    def to_dict(self):
        return {
            '_': 'UserStatusRecently'
        }

    def __bytes__(self):
        return b''.join((
            b'\xf1Bo\xe2',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class WallPaper(TLObject):
    CONSTRUCTOR_ID = 0xccb03657
    SUBCLASS_OF_ID = 0x96a2c98b

    def __init__(self, id, title, sizes, color):
        """
        :param int id:
        :param str title:
        :param List[TypePhotoSize] sizes:
        :param int color:

        Constructor for WallPaper: Instance of either WallPaper, WallPaperSolid.
        """
        self.id = id  # type: int
        self.title = title  # type: str
        self.sizes = sizes  # type: List[TypePhotoSize]
        self.color = color  # type: int

    def to_dict(self):
        return {
            '_': 'WallPaper',
            'id': self.id,
            'title': self.title,
            'sizes': [] if self.sizes is None else [None if x is None else x.to_dict() for x in self.sizes],
            'color': self.color
        }

    def __bytes__(self):
        return b''.join((
            b'W6\xb0\xcc',
            struct.pack('<i', self.id),
            self.serialize_bytes(self.title),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.sizes)),b''.join(bytes(x) for x in self.sizes),
            struct.pack('<i', self.color),
        ))

    @classmethod
    def from_reader(cls, reader):
        _id = reader.read_int()
        _title = reader.tgread_string()
        reader.read_int()
        _sizes = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _sizes.append(_x)

        _color = reader.read_int()
        return cls(id=_id, title=_title, sizes=_sizes, color=_color)


class WallPaperSolid(TLObject):
    CONSTRUCTOR_ID = 0x63117f24
    SUBCLASS_OF_ID = 0x96a2c98b

    def __init__(self, id, title, bg_color, color):
        """
        :param int id:
        :param str title:
        :param int bg_color:
        :param int color:

        Constructor for WallPaper: Instance of either WallPaper, WallPaperSolid.
        """
        self.id = id  # type: int
        self.title = title  # type: str
        self.bg_color = bg_color  # type: int
        self.color = color  # type: int

    def to_dict(self):
        return {
            '_': 'WallPaperSolid',
            'id': self.id,
            'title': self.title,
            'bg_color': self.bg_color,
            'color': self.color
        }

    def __bytes__(self):
        return b''.join((
            b'$\x7f\x11c',
            struct.pack('<i', self.id),
            self.serialize_bytes(self.title),
            struct.pack('<i', self.bg_color),
            struct.pack('<i', self.color),
        ))

    @classmethod
    def from_reader(cls, reader):
        _id = reader.read_int()
        _title = reader.tgread_string()
        _bg_color = reader.read_int()
        _color = reader.read_int()
        return cls(id=_id, title=_title, bg_color=_bg_color, color=_color)


class WebAuthorization(TLObject):
    CONSTRUCTOR_ID = 0xcac943f2
    SUBCLASS_OF_ID = 0x3764d30

    def __init__(self, hash, bot_id, domain, browser, platform, date_created, date_active, ip, region):
        """
        :param int hash:
        :param int bot_id:
        :param str domain:
        :param str browser:
        :param str platform:
        :param int date_created:
        :param int date_active:
        :param str ip:
        :param str region:

        Constructor for WebAuthorization: Instance of WebAuthorization.
        """
        self.hash = hash  # type: int
        self.bot_id = bot_id  # type: int
        self.domain = domain  # type: str
        self.browser = browser  # type: str
        self.platform = platform  # type: str
        self.date_created = date_created  # type: int
        self.date_active = date_active  # type: int
        self.ip = ip  # type: str
        self.region = region  # type: str

    def to_dict(self):
        return {
            '_': 'WebAuthorization',
            'hash': self.hash,
            'bot_id': self.bot_id,
            'domain': self.domain,
            'browser': self.browser,
            'platform': self.platform,
            'date_created': self.date_created,
            'date_active': self.date_active,
            'ip': self.ip,
            'region': self.region
        }

    def __bytes__(self):
        return b''.join((
            b'\xf2C\xc9\xca',
            struct.pack('<q', self.hash),
            struct.pack('<i', self.bot_id),
            self.serialize_bytes(self.domain),
            self.serialize_bytes(self.browser),
            self.serialize_bytes(self.platform),
            struct.pack('<i', self.date_created),
            struct.pack('<i', self.date_active),
            self.serialize_bytes(self.ip),
            self.serialize_bytes(self.region),
        ))

    @classmethod
    def from_reader(cls, reader):
        _hash = reader.read_long()
        _bot_id = reader.read_int()
        _domain = reader.tgread_string()
        _browser = reader.tgread_string()
        _platform = reader.tgread_string()
        _date_created = reader.read_int()
        _date_active = reader.read_int()
        _ip = reader.tgread_string()
        _region = reader.tgread_string()
        return cls(hash=_hash, bot_id=_bot_id, domain=_domain, browser=_browser, platform=_platform, date_created=_date_created, date_active=_date_active, ip=_ip, region=_region)


class WebDocument(TLObject):
    CONSTRUCTOR_ID = 0x1c570ed1
    SUBCLASS_OF_ID = 0x3b642814

    def __init__(self, url, access_hash, size, mime_type, attributes):
        """
        :param str url:
        :param int access_hash:
        :param int size:
        :param str mime_type:
        :param List[TypeDocumentAttribute] attributes:

        Constructor for WebDocument: Instance of either WebDocument, WebDocumentNoProxy.
        """
        self.url = url  # type: str
        self.access_hash = access_hash  # type: int
        self.size = size  # type: int
        self.mime_type = mime_type  # type: str
        self.attributes = attributes  # type: List[TypeDocumentAttribute]

    def to_dict(self):
        return {
            '_': 'WebDocument',
            'url': self.url,
            'access_hash': self.access_hash,
            'size': self.size,
            'mime_type': self.mime_type,
            'attributes': [] if self.attributes is None else [None if x is None else x.to_dict() for x in self.attributes]
        }

    def __bytes__(self):
        return b''.join((
            b'\xd1\x0eW\x1c',
            self.serialize_bytes(self.url),
            struct.pack('<q', self.access_hash),
            struct.pack('<i', self.size),
            self.serialize_bytes(self.mime_type),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.attributes)),b''.join(bytes(x) for x in self.attributes),
        ))

    @classmethod
    def from_reader(cls, reader):
        _url = reader.tgread_string()
        _access_hash = reader.read_long()
        _size = reader.read_int()
        _mime_type = reader.tgread_string()
        reader.read_int()
        _attributes = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _attributes.append(_x)

        return cls(url=_url, access_hash=_access_hash, size=_size, mime_type=_mime_type, attributes=_attributes)


class WebDocumentNoProxy(TLObject):
    CONSTRUCTOR_ID = 0xf9c8bcc6
    SUBCLASS_OF_ID = 0x3b642814

    def __init__(self, url, size, mime_type, attributes):
        """
        :param str url:
        :param int size:
        :param str mime_type:
        :param List[TypeDocumentAttribute] attributes:

        Constructor for WebDocument: Instance of either WebDocument, WebDocumentNoProxy.
        """
        self.url = url  # type: str
        self.size = size  # type: int
        self.mime_type = mime_type  # type: str
        self.attributes = attributes  # type: List[TypeDocumentAttribute]

    def to_dict(self):
        return {
            '_': 'WebDocumentNoProxy',
            'url': self.url,
            'size': self.size,
            'mime_type': self.mime_type,
            'attributes': [] if self.attributes is None else [None if x is None else x.to_dict() for x in self.attributes]
        }

    def __bytes__(self):
        return b''.join((
            b'\xc6\xbc\xc8\xf9',
            self.serialize_bytes(self.url),
            struct.pack('<i', self.size),
            self.serialize_bytes(self.mime_type),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.attributes)),b''.join(bytes(x) for x in self.attributes),
        ))

    @classmethod
    def from_reader(cls, reader):
        _url = reader.tgread_string()
        _size = reader.read_int()
        _mime_type = reader.tgread_string()
        reader.read_int()
        _attributes = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _attributes.append(_x)

        return cls(url=_url, size=_size, mime_type=_mime_type, attributes=_attributes)


class WebPage(TLObject):
    CONSTRUCTOR_ID = 0x5f07b4bc
    SUBCLASS_OF_ID = 0x55a97481

    def __init__(self, id, url, display_url, hash, type=None, site_name=None, title=None, description=None, photo=None, embed_url=None, embed_type=None, embed_width=None, embed_height=None, duration=None, author=None, document=None, cached_page=None):
        """
        :param int id:
        :param str url:
        :param str display_url:
        :param int hash:
        :param Optional[str] type:
        :param Optional[str] site_name:
        :param Optional[str] title:
        :param Optional[str] description:
        :param Optional[TypePhoto] photo:
        :param Optional[str] embed_url:
        :param Optional[str] embed_type:
        :param Optional[int] embed_width:
        :param Optional[int] embed_height:
        :param Optional[int] duration:
        :param Optional[str] author:
        :param Optional[TypeDocument] document:
        :param Optional[TypePage] cached_page:

        Constructor for WebPage: Instance of either WebPageEmpty, WebPagePending, WebPage, WebPageNotModified.
        """
        self.id = id  # type: int
        self.url = url  # type: str
        self.display_url = display_url  # type: str
        self.hash = hash  # type: int
        self.type = type  # type: Optional[str]
        self.site_name = site_name  # type: Optional[str]
        self.title = title  # type: Optional[str]
        self.description = description  # type: Optional[str]
        self.photo = photo  # type: Optional[TypePhoto]
        self.embed_url = embed_url  # type: Optional[str]
        self.embed_type = embed_type  # type: Optional[str]
        self.embed_width = embed_width  # type: Optional[int]
        self.embed_height = embed_height  # type: Optional[int]
        self.duration = duration  # type: Optional[int]
        self.author = author  # type: Optional[str]
        self.document = document  # type: Optional[TypeDocument]
        self.cached_page = cached_page  # type: Optional[TypePage]

    def to_dict(self):
        return {
            '_': 'WebPage',
            'id': self.id,
            'url': self.url,
            'display_url': self.display_url,
            'hash': self.hash,
            'type': self.type,
            'site_name': self.site_name,
            'title': self.title,
            'description': self.description,
            'photo': None if self.photo is None else self.photo.to_dict(),
            'embed_url': self.embed_url,
            'embed_type': self.embed_type,
            'embed_width': self.embed_width,
            'embed_height': self.embed_height,
            'duration': self.duration,
            'author': self.author,
            'document': None if self.document is None else self.document.to_dict(),
            'cached_page': None if self.cached_page is None else self.cached_page.to_dict()
        }

    def __bytes__(self):
        assert ((self.embed_url or self.embed_url is not None) and (self.embed_type or self.embed_type is not None)) or ((self.embed_url is None or self.embed_url is False) and (self.embed_type is None or self.embed_type is False)), 'embed_url, embed_type parameters must all be False-y (like None) or all me True-y'
        assert ((self.embed_width or self.embed_width is not None) and (self.embed_height or self.embed_height is not None)) or ((self.embed_width is None or self.embed_width is False) and (self.embed_height is None or self.embed_height is False)), 'embed_width, embed_height parameters must all be False-y (like None) or all me True-y'
        return b''.join((
            b'\xbc\xb4\x07_',
            struct.pack('<I', (0 if self.type is None or self.type is False else 1) | (0 if self.site_name is None or self.site_name is False else 2) | (0 if self.title is None or self.title is False else 4) | (0 if self.description is None or self.description is False else 8) | (0 if self.photo is None or self.photo is False else 16) | (0 if self.embed_url is None or self.embed_url is False else 32) | (0 if self.embed_type is None or self.embed_type is False else 32) | (0 if self.embed_width is None or self.embed_width is False else 64) | (0 if self.embed_height is None or self.embed_height is False else 64) | (0 if self.duration is None or self.duration is False else 128) | (0 if self.author is None or self.author is False else 256) | (0 if self.document is None or self.document is False else 512) | (0 if self.cached_page is None or self.cached_page is False else 1024)),
            struct.pack('<q', self.id),
            self.serialize_bytes(self.url),
            self.serialize_bytes(self.display_url),
            struct.pack('<i', self.hash),
            b'' if self.type is None or self.type is False else (self.serialize_bytes(self.type)),
            b'' if self.site_name is None or self.site_name is False else (self.serialize_bytes(self.site_name)),
            b'' if self.title is None or self.title is False else (self.serialize_bytes(self.title)),
            b'' if self.description is None or self.description is False else (self.serialize_bytes(self.description)),
            b'' if self.photo is None or self.photo is False else (bytes(self.photo)),
            b'' if self.embed_url is None or self.embed_url is False else (self.serialize_bytes(self.embed_url)),
            b'' if self.embed_type is None or self.embed_type is False else (self.serialize_bytes(self.embed_type)),
            b'' if self.embed_width is None or self.embed_width is False else (struct.pack('<i', self.embed_width)),
            b'' if self.embed_height is None or self.embed_height is False else (struct.pack('<i', self.embed_height)),
            b'' if self.duration is None or self.duration is False else (struct.pack('<i', self.duration)),
            b'' if self.author is None or self.author is False else (self.serialize_bytes(self.author)),
            b'' if self.document is None or self.document is False else (bytes(self.document)),
            b'' if self.cached_page is None or self.cached_page is False else (bytes(self.cached_page)),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _id = reader.read_long()
        _url = reader.tgread_string()
        _display_url = reader.tgread_string()
        _hash = reader.read_int()
        if flags & 1:
            _type = reader.tgread_string()
        else:
            _type = None
        if flags & 2:
            _site_name = reader.tgread_string()
        else:
            _site_name = None
        if flags & 4:
            _title = reader.tgread_string()
        else:
            _title = None
        if flags & 8:
            _description = reader.tgread_string()
        else:
            _description = None
        if flags & 16:
            _photo = reader.tgread_object()
        else:
            _photo = None
        if flags & 32:
            _embed_url = reader.tgread_string()
        else:
            _embed_url = None
        if flags & 32:
            _embed_type = reader.tgread_string()
        else:
            _embed_type = None
        if flags & 64:
            _embed_width = reader.read_int()
        else:
            _embed_width = None
        if flags & 64:
            _embed_height = reader.read_int()
        else:
            _embed_height = None
        if flags & 128:
            _duration = reader.read_int()
        else:
            _duration = None
        if flags & 256:
            _author = reader.tgread_string()
        else:
            _author = None
        if flags & 512:
            _document = reader.tgread_object()
        else:
            _document = None
        if flags & 1024:
            _cached_page = reader.tgread_object()
        else:
            _cached_page = None
        return cls(id=_id, url=_url, display_url=_display_url, hash=_hash, type=_type, site_name=_site_name, title=_title, description=_description, photo=_photo, embed_url=_embed_url, embed_type=_embed_type, embed_width=_embed_width, embed_height=_embed_height, duration=_duration, author=_author, document=_document, cached_page=_cached_page)


class WebPageEmpty(TLObject):
    CONSTRUCTOR_ID = 0xeb1477e8
    SUBCLASS_OF_ID = 0x55a97481

    def __init__(self, id):
        """
        :param int id:

        Constructor for WebPage: Instance of either WebPageEmpty, WebPagePending, WebPage, WebPageNotModified.
        """
        self.id = id  # type: int

    def to_dict(self):
        return {
            '_': 'WebPageEmpty',
            'id': self.id
        }

    def __bytes__(self):
        return b''.join((
            b'\xe8w\x14\xeb',
            struct.pack('<q', self.id),
        ))

    @classmethod
    def from_reader(cls, reader):
        _id = reader.read_long()
        return cls(id=_id)


class WebPageNotModified(TLObject):
    CONSTRUCTOR_ID = 0x85849473
    SUBCLASS_OF_ID = 0x55a97481

    def to_dict(self):
        return {
            '_': 'WebPageNotModified'
        }

    def __bytes__(self):
        return b''.join((
            b's\x94\x84\x85',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class WebPagePending(TLObject):
    CONSTRUCTOR_ID = 0xc586da1c
    SUBCLASS_OF_ID = 0x55a97481

    def __init__(self, id, date):
        """
        :param int id:
        :param Optional[datetime] date:

        Constructor for WebPage: Instance of either WebPageEmpty, WebPagePending, WebPage, WebPageNotModified.
        """
        self.id = id  # type: int
        self.date = date  # type: Optional[datetime]

    def to_dict(self):
        return {
            '_': 'WebPagePending',
            'id': self.id,
            'date': self.date
        }

    def __bytes__(self):
        return b''.join((
            b'\x1c\xda\x86\xc5',
            struct.pack('<q', self.id),
            self.serialize_datetime(self.date),
        ))

    @classmethod
    def from_reader(cls, reader):
        _id = reader.read_long()
        _date = reader.tgread_date()
        return cls(id=_id, date=_date)

TypeAccessPointRule = AccessPointRule
TypeAccountDaysTTL = AccountDaysTTL
TypeAuthorization = Authorization
TypeBadMsgNotification = Union[BadMsgNotification,BadServerSalt]
TypeBindAuthKeyInner = BindAuthKeyInner
TypeBotCommand = BotCommand
TypeBotInfo = BotInfo
TypeBotInlineResult = Union[BotInlineResult,BotInlineMediaResult]
TypeBotInlineMessage = Union[BotInlineMessageMediaAuto,BotInlineMessageText,BotInlineMessageMediaGeo,BotInlineMessageMediaVenue,BotInlineMessageMediaContact]
TypeCdnConfig = CdnConfig
TypeCdnPublicKey = CdnPublicKey
TypeChat = Union[ChatEmpty,Chat,ChatForbidden,Channel,ChannelForbidden]
TypeChannelAdminLogEvent = ChannelAdminLogEvent
TypeChannelAdminLogEventAction = Union[ChannelAdminLogEventActionChangeTitle,ChannelAdminLogEventActionChangeAbout,ChannelAdminLogEventActionChangeUsername,ChannelAdminLogEventActionChangePhoto,ChannelAdminLogEventActionToggleInvites,ChannelAdminLogEventActionToggleSignatures,ChannelAdminLogEventActionUpdatePinned,ChannelAdminLogEventActionEditMessage,ChannelAdminLogEventActionDeleteMessage,ChannelAdminLogEventActionParticipantJoin,ChannelAdminLogEventActionParticipantLeave,ChannelAdminLogEventActionParticipantInvite,ChannelAdminLogEventActionParticipantToggleBan,ChannelAdminLogEventActionParticipantToggleAdmin,ChannelAdminLogEventActionChangeStickerSet,ChannelAdminLogEventActionTogglePreHistoryHidden]
TypeChannelAdminLogEventsFilter = ChannelAdminLogEventsFilter
TypeChannelAdminRights = ChannelAdminRights
TypeChannelBannedRights = ChannelBannedRights
TypeChatFull = Union[ChatFull,ChannelFull]
TypeChannelMessagesFilter = Union[ChannelMessagesFilterEmpty,ChannelMessagesFilter]
TypeChannelParticipant = Union[ChannelParticipant,ChannelParticipantSelf,ChannelParticipantCreator,ChannelParticipantAdmin,ChannelParticipantBanned]
TypeChannelParticipantsFilter = Union[ChannelParticipantsRecent,ChannelParticipantsAdmins,ChannelParticipantsKicked,ChannelParticipantsBots,ChannelParticipantsBanned,ChannelParticipantsSearch]
TypeChatInvite = Union[ChatInviteAlready,ChatInvite]
TypeExportedChatInvite = Union[ChatInviteEmpty,ChatInviteExported]
TypeChatParticipant = Union[ChatParticipant,ChatParticipantCreator,ChatParticipantAdmin]
TypeChatParticipants = Union[ChatParticipantsForbidden,ChatParticipants]
TypeChatPhoto = Union[ChatPhotoEmpty,ChatPhoto]
TypeClient_DH_Inner_Data = ClientDHInnerData
TypeConfig = Config
TypeContact = Contact
TypeContactBlocked = ContactBlocked
TypeContactLink = Union[ContactLinkUnknown,ContactLinkNone,ContactLinkHasPhone,ContactLinkContact]
TypeContactStatus = ContactStatus
TypeDataJSON = DataJSON
TypeDcOption = DcOption
TypeDestroySessionRes = Union[DestroySessionOk,DestroySessionNone]
TypeSet_client_DH_params_answer = Union[DhGenOk,DhGenRetry,DhGenFail]
TypeDialog = Dialog
TypeDialogPeer = DialogPeer
TypeDocument = Union[DocumentEmpty,Document]
TypeDocumentAttribute = Union[DocumentAttributeImageSize,DocumentAttributeAnimated,DocumentAttributeSticker,DocumentAttributeVideo,DocumentAttributeAudio,DocumentAttributeFilename,DocumentAttributeHasStickers]
TypeDraftMessage = Union[DraftMessageEmpty,DraftMessage]
TypeHttpWait = DummyHttpWait
TypeEncryptedChat = Union[EncryptedChatEmpty,EncryptedChatWaiting,EncryptedChatRequested,EncryptedChat,EncryptedChatDiscarded]
TypeEncryptedFile = Union[EncryptedFileEmpty,EncryptedFile]
TypeEncryptedMessage = Union[EncryptedMessage,EncryptedMessageService]
TypeError = Error
TypeExportedMessageLink = ExportedMessageLink
TypeFileHash = FileHash
TypeFileLocation = Union[FileLocationUnavailable,FileLocation]
TypeFoundGif = Union[FoundGif,FoundGifCached]
TypeFutureSalt = FutureSalt
TypeFutureSalts = FutureSalts
TypeGame = Game
TypeGeoPoint = Union[GeoPointEmpty,GeoPoint]
TypeHighScore = HighScore
TypeImportedContact = ImportedContact
TypeInlineBotSwitchPM = InlineBotSwitchPM
TypeInputAppEvent = InputAppEvent
TypeInputBotInlineMessage = Union[InputBotInlineMessageMediaAuto,InputBotInlineMessageText,InputBotInlineMessageMediaGeo,InputBotInlineMessageMediaVenue,InputBotInlineMessageMediaContact,InputBotInlineMessageGame]
TypeInputBotInlineMessageID = InputBotInlineMessageID
TypeInputBotInlineResult = Union[InputBotInlineResult,InputBotInlineResultPhoto,InputBotInlineResultDocument,InputBotInlineResultGame]
TypeInputChannel = Union[InputChannelEmpty,InputChannel]
TypeInputChatPhoto = Union[InputChatPhotoEmpty,InputChatUploadedPhoto,InputChatPhoto]
TypeInputClientProxy = InputClientProxy
TypeInputDialogPeer = InputDialogPeer
TypeInputDocument = Union[InputDocumentEmpty,InputDocument]
TypeInputFileLocation = Union[InputFileLocation,InputEncryptedFileLocation,InputDocumentFileLocation,InputSecureFileLocation,InputTakeoutFileLocation]
TypeInputEncryptedChat = InputEncryptedChat
TypeInputEncryptedFile = Union[InputEncryptedFileEmpty,InputEncryptedFileUploaded,InputEncryptedFile,InputEncryptedFileBigUploaded]
TypeInputFile = Union[InputFile,InputFileBig]
TypeInputGame = Union[InputGameID,InputGameShortName]
TypeInputGeoPoint = Union[InputGeoPointEmpty,InputGeoPoint]
TypeInputMedia = Union[InputMediaEmpty,InputMediaUploadedPhoto,InputMediaPhoto,InputMediaGeoPoint,InputMediaContact,InputMediaUploadedDocument,InputMediaDocument,InputMediaVenue,InputMediaGifExternal,InputMediaPhotoExternal,InputMediaDocumentExternal,InputMediaGame,InputMediaInvoice,InputMediaGeoLive]
TypeMessageEntity = Union[MessageEntityUnknown,MessageEntityMention,MessageEntityHashtag,MessageEntityBotCommand,MessageEntityUrl,MessageEntityEmail,MessageEntityBold,MessageEntityItalic,MessageEntityCode,MessageEntityPre,MessageEntityTextUrl,MessageEntityMentionName,InputMessageEntityMentionName,MessageEntityPhone,MessageEntityCashtag]
TypeInputMessage = Union[InputMessageID,InputMessageReplyTo,InputMessagePinned]
TypeMessagesFilter = Union[InputMessagesFilterEmpty,InputMessagesFilterPhotos,InputMessagesFilterVideo,InputMessagesFilterPhotoVideo,InputMessagesFilterDocument,InputMessagesFilterUrl,InputMessagesFilterGif,InputMessagesFilterVoice,InputMessagesFilterMusic,InputMessagesFilterChatPhotos,InputMessagesFilterPhoneCalls,InputMessagesFilterRoundVoice,InputMessagesFilterRoundVideo,InputMessagesFilterMyMentions,InputMessagesFilterGeo,InputMessagesFilterContacts]
TypeInputNotifyPeer = Union[InputNotifyPeer,InputNotifyUsers,InputNotifyChats]
TypeInputPaymentCredentials = Union[InputPaymentCredentialsSaved,InputPaymentCredentials,InputPaymentCredentialsApplePay,InputPaymentCredentialsAndroidPay]
TypeInputPeer = Union[InputPeerEmpty,InputPeerSelf,InputPeerChat,InputPeerUser,InputPeerChannel]
TypeInputPeerNotifySettings = InputPeerNotifySettings
TypeInputPhoneCall = InputPhoneCall
TypeInputContact = InputPhoneContact
TypeInputPhoto = Union[InputPhotoEmpty,InputPhoto]
TypeInputPrivacyKey = Union[InputPrivacyKeyStatusTimestamp,InputPrivacyKeyChatInvite,InputPrivacyKeyPhoneCall]
TypeInputPrivacyRule = Union[InputPrivacyValueAllowContacts,InputPrivacyValueAllowAll,InputPrivacyValueAllowUsers,InputPrivacyValueDisallowContacts,InputPrivacyValueDisallowAll,InputPrivacyValueDisallowUsers]
TypeReportReason = Union[InputReportReasonSpam,InputReportReasonViolence,InputReportReasonPornography,InputReportReasonOther]
TypeInputSecureFile = Union[InputSecureFileUploaded,InputSecureFile]
TypeInputSecureValue = InputSecureValue
TypeInputSingleMedia = InputSingleMedia
TypeInputStickerSet = Union[InputStickerSetEmpty,InputStickerSetID,InputStickerSetShortName]
TypeInputStickerSetItem = InputStickerSetItem
TypeInputStickeredMedia = Union[InputStickeredMediaPhoto,InputStickeredMediaDocument]
TypeInputUser = Union[InputUserEmpty,InputUserSelf,InputUser]
TypeInputWebDocument = InputWebDocument
TypeInputWebFileLocation = Union[InputWebFileLocation,InputWebFileGeoPointLocation]
TypeInvoice = Invoice
TypeIpPort = Union[IpPort,IpPortSecret]
TypeKeyboardButton = Union[KeyboardButton,KeyboardButtonUrl,KeyboardButtonCallback,KeyboardButtonRequestPhone,KeyboardButtonRequestGeoLocation,KeyboardButtonSwitchInline,KeyboardButtonGame,KeyboardButtonBuy]
TypeKeyboardButtonRow = KeyboardButtonRow
TypeLabeledPrice = LabeledPrice
TypeLangPackDifference = LangPackDifference
TypeLangPackLanguage = LangPackLanguage
TypeLangPackString = Union[LangPackString,LangPackStringPluralized,LangPackStringDeleted]
TypeMaskCoords = MaskCoords
TypeMessage = Union[MessageEmpty,Message,MessageService]
TypeMessageAction = Union[MessageActionEmpty,MessageActionChatCreate,MessageActionChatEditTitle,MessageActionChatEditPhoto,MessageActionChatDeletePhoto,MessageActionChatAddUser,MessageActionChatDeleteUser,MessageActionChatJoinedByLink,MessageActionChannelCreate,MessageActionChatMigrateTo,MessageActionChannelMigrateFrom,MessageActionPinMessage,MessageActionHistoryClear,MessageActionGameScore,MessageActionPaymentSentMe,MessageActionPaymentSent,MessageActionPhoneCall,MessageActionScreenshotTaken,MessageActionCustomAction,MessageActionBotAllowed,MessageActionSecureValuesSentMe,MessageActionSecureValuesSent]
TypeMessageFwdHeader = MessageFwdHeader
TypeMessageMedia = Union[MessageMediaEmpty,MessageMediaPhoto,MessageMediaGeo,MessageMediaContact,MessageMediaUnsupported,MessageMediaDocument,MessageMediaWebPage,MessageMediaVenue,MessageMediaGame,MessageMediaInvoice,MessageMediaGeoLive]
TypeMessageRange = MessageRange
TypeMsgDetailedInfo = Union[MsgDetailedInfo,MsgNewDetailedInfo]
TypeMsgResendReq = MsgResendReq
TypeMsgsAck = MsgsAck
TypeMsgsAllInfo = MsgsAllInfo
TypeMsgsStateInfo = MsgsStateInfo
TypeMsgsStateReq = MsgsStateReq
TypeNearestDc = NearestDc
TypeNewSession = NewSessionCreated
TypeNotifyPeer = Union[NotifyPeer,NotifyUsers,NotifyChats]
TypeP_Q_inner_data = Union[PQInnerData,PQInnerDataTemp]
TypePageBlock = Union[PageBlockUnsupported,PageBlockTitle,PageBlockSubtitle,PageBlockAuthorDate,PageBlockHeader,PageBlockSubheader,PageBlockParagraph,PageBlockPreformatted,PageBlockFooter,PageBlockDivider,PageBlockAnchor,PageBlockList,PageBlockBlockquote,PageBlockPullquote,PageBlockPhoto,PageBlockVideo,PageBlockCover,PageBlockEmbed,PageBlockEmbedPost,PageBlockCollage,PageBlockSlideshow,PageBlockChannel,PageBlockAudio]
TypePage = Union[PagePart,PageFull]
TypePaymentCharge = PaymentCharge
TypePaymentRequestedInfo = PaymentRequestedInfo
TypePaymentSavedCredentials = PaymentSavedCredentialsCard
TypePeer = Union[PeerUser,PeerChat,PeerChannel]
TypePeerNotifySettings = PeerNotifySettings
TypePeerSettings = PeerSettings
TypePhoneCall = Union[PhoneCallEmpty,PhoneCallWaiting,PhoneCallRequested,PhoneCallAccepted,PhoneCall,PhoneCallDiscarded]
TypePhoneCallDiscardReason = Union[PhoneCallDiscardReasonMissed,PhoneCallDiscardReasonDisconnect,PhoneCallDiscardReasonHangup,PhoneCallDiscardReasonBusy]
TypePhoneCallProtocol = PhoneCallProtocol
TypePhoneConnection = PhoneConnection
TypePhoto = Union[PhotoEmpty,Photo]
TypePhotoSize = Union[PhotoSizeEmpty,PhotoSize,PhotoCachedSize]
TypePong = Pong
TypePopularContact = PopularContact
TypePostAddress = PostAddress
TypePrivacyKey = Union[PrivacyKeyStatusTimestamp,PrivacyKeyChatInvite,PrivacyKeyPhoneCall]
TypePrivacyRule = Union[PrivacyValueAllowContacts,PrivacyValueAllowAll,PrivacyValueAllowUsers,PrivacyValueDisallowContacts,PrivacyValueDisallowAll,PrivacyValueDisallowUsers]
TypeReceivedNotifyMessage = ReceivedNotifyMessage
TypeRecentMeUrl = Union[RecentMeUrlUnknown,RecentMeUrlUser,RecentMeUrlChat,RecentMeUrlChatInvite,RecentMeUrlStickerSet]
TypeReplyMarkup = Union[ReplyKeyboardHide,ReplyKeyboardForceReply,ReplyKeyboardMarkup,ReplyInlineMarkup]
TypeResPQ = ResPQ
TypeRpcDropAnswer = Union[RpcAnswerUnknown,RpcAnswerDroppedRunning,RpcAnswerDropped]
TypeRpcError = RpcError
TypeRSAPublicKey = RsaPublicKey
TypeSavedContact = SavedPhoneContact
TypeSecureCredentialsEncrypted = SecureCredentialsEncrypted
TypeSecureData = SecureData
TypeSecureFile = Union[SecureFileEmpty,SecureFile]
TypeSecurePlainData = Union[SecurePlainPhone,SecurePlainEmail]
TypeSecureValue = SecureValue
TypeSecureValueError = Union[SecureValueErrorData,SecureValueErrorFrontSide,SecureValueErrorReverseSide,SecureValueErrorSelfie,SecureValueErrorFile,SecureValueErrorFiles]
TypeSecureValueHash = SecureValueHash
TypeSecureValueType = Union[SecureValueTypePersonalDetails,SecureValueTypePassport,SecureValueTypeDriverLicense,SecureValueTypeIdentityCard,SecureValueTypeInternalPassport,SecureValueTypeAddress,SecureValueTypeUtilityBill,SecureValueTypeBankStatement,SecureValueTypeRentalAgreement,SecureValueTypePassportRegistration,SecureValueTypeTemporaryRegistration,SecureValueTypePhone,SecureValueTypeEmail]
TypeSendMessageAction = Union[SendMessageTypingAction,SendMessageCancelAction,SendMessageRecordVideoAction,SendMessageUploadVideoAction,SendMessageRecordAudioAction,SendMessageUploadAudioAction,SendMessageUploadPhotoAction,SendMessageUploadDocumentAction,SendMessageGeoLocationAction,SendMessageChooseContactAction,SendMessageGamePlayAction,SendMessageRecordRoundAction,SendMessageUploadRoundAction]
TypeServer_DH_inner_data = ServerDHInnerData
TypeServer_DH_Params = Union[ServerDHParamsFail,ServerDHParamsOk]
TypeShippingOption = ShippingOption
TypeStickerPack = StickerPack
TypeStickerSet = StickerSet
TypeStickerSetCovered = Union[StickerSetCovered,StickerSetMultiCovered]
TypeRichText = Union[TextEmpty,TextPlain,TextBold,TextItalic,TextUnderline,TextStrike,TextFixed,TextUrl,TextEmail,TextConcat]
TypeTopPeer = TopPeer
TypeTopPeerCategory = Union[TopPeerCategoryBotsPM,TopPeerCategoryBotsInline,TopPeerCategoryCorrespondents,TopPeerCategoryGroups,TopPeerCategoryChannels,TopPeerCategoryPhoneCalls]
TypeTopPeerCategoryPeers = TopPeerCategoryPeers
TypeUpdate = Union[UpdateNewMessage,UpdateMessageID,UpdateDeleteMessages,UpdateUserTyping,UpdateChatUserTyping,UpdateChatParticipants,UpdateUserStatus,UpdateUserName,UpdateUserPhoto,UpdateContactRegistered,UpdateContactLink,UpdateNewEncryptedMessage,UpdateEncryptedChatTyping,UpdateEncryption,UpdateEncryptedMessagesRead,UpdateChatParticipantAdd,UpdateChatParticipantDelete,UpdateDcOptions,UpdateUserBlocked,UpdateNotifySettings,UpdateServiceNotification,UpdatePrivacy,UpdateUserPhone,UpdateReadHistoryInbox,UpdateReadHistoryOutbox,UpdateWebPage,UpdateReadMessagesContents,UpdateChannelTooLong,UpdateChannel,UpdateNewChannelMessage,UpdateReadChannelInbox,UpdateDeleteChannelMessages,UpdateChannelMessageViews,UpdateChatAdmins,UpdateChatParticipantAdmin,UpdateNewStickerSet,UpdateStickerSetsOrder,UpdateStickerSets,UpdateSavedGifs,UpdateBotInlineQuery,UpdateBotInlineSend,UpdateEditChannelMessage,UpdateChannelPinnedMessage,UpdateBotCallbackQuery,UpdateEditMessage,UpdateInlineBotCallbackQuery,UpdateReadChannelOutbox,UpdateDraftMessage,UpdateReadFeaturedStickers,UpdateRecentStickers,UpdateConfig,UpdatePtsChanged,UpdateChannelWebPage,UpdateDialogPinned,UpdatePinnedDialogs,UpdateBotWebhookJSON,UpdateBotWebhookJSONQuery,UpdateBotShippingQuery,UpdateBotPrecheckoutQuery,UpdatePhoneCall,UpdateLangPackTooLong,UpdateLangPack,UpdateFavedStickers,UpdateChannelReadMessagesContents,UpdateContactsReset,UpdateChannelAvailableMessages,UpdateDialogUnreadMark]
TypeUpdates = Union[UpdatesTooLong,UpdateShortMessage,UpdateShortChatMessage,UpdateShort,UpdatesCombined,Updates,UpdateShortSentMessage]
TypeUser = Union[UserEmpty,User]
TypeUserFull = UserFull
TypeUserProfilePhoto = Union[UserProfilePhotoEmpty,UserProfilePhoto]
TypeUserStatus = Union[UserStatusEmpty,UserStatusOnline,UserStatusOffline,UserStatusRecently,UserStatusLastWeek,UserStatusLastMonth]
TypeWallPaper = Union[WallPaper,WallPaperSolid]
TypeWebAuthorization = WebAuthorization
TypeWebDocument = Union[WebDocument,WebDocumentNoProxy]
TypeWebPage = Union[WebPageEmpty,WebPagePending,WebPage,WebPageNotModified]
