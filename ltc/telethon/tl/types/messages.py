"""File generated by TLObjects' generator. All changes will be ERASED"""
from ...tl.tlobject import TLObject
from typing import Optional, List, Union, TYPE_CHECKING
import os
import struct
if TYPE_CHECKING:
    from ...tl.types import TypeEncryptedFile, TypeChat, TypeStickerPack, TypeBotInlineResult, TypeFoundGif, TypeDocument, TypeInlineBotSwitchPM, TypeUser, TypeStickerSetCovered, TypeChatFull, TypeDialog, TypeStickerSet, TypeHighScore, TypeMessage
    from ...tl.types.updates import TypeState



class AffectedHistory(TLObject):
    CONSTRUCTOR_ID = 0xb45c69d1
    SUBCLASS_OF_ID = 0x2c49c116

    def __init__(self, pts, pts_count, offset):
        """
        :param int pts:
        :param int pts_count:
        :param int offset:

        Constructor for messages.AffectedHistory: Instance of AffectedHistory.
        """
        self.pts = pts  # type: int
        self.pts_count = pts_count  # type: int
        self.offset = offset  # type: int

    def to_dict(self):
        return {
            '_': 'AffectedHistory',
            'pts': self.pts,
            'pts_count': self.pts_count,
            'offset': self.offset
        }

    def __bytes__(self):
        return b''.join((
            b'\xd1i\\\xb4',
            struct.pack('<i', self.pts),
            struct.pack('<i', self.pts_count),
            struct.pack('<i', self.offset),
        ))

    @classmethod
    def from_reader(cls, reader):
        _pts = reader.read_int()
        _pts_count = reader.read_int()
        _offset = reader.read_int()
        return cls(pts=_pts, pts_count=_pts_count, offset=_offset)


class AffectedMessages(TLObject):
    CONSTRUCTOR_ID = 0x84d19185
    SUBCLASS_OF_ID = 0xced3c06e

    def __init__(self, pts, pts_count):
        """
        :param int pts:
        :param int pts_count:

        Constructor for messages.AffectedMessages: Instance of AffectedMessages.
        """
        self.pts = pts  # type: int
        self.pts_count = pts_count  # type: int

    def to_dict(self):
        return {
            '_': 'AffectedMessages',
            'pts': self.pts,
            'pts_count': self.pts_count
        }

    def __bytes__(self):
        return b''.join((
            b'\x85\x91\xd1\x84',
            struct.pack('<i', self.pts),
            struct.pack('<i', self.pts_count),
        ))

    @classmethod
    def from_reader(cls, reader):
        _pts = reader.read_int()
        _pts_count = reader.read_int()
        return cls(pts=_pts, pts_count=_pts_count)


class AllStickers(TLObject):
    CONSTRUCTOR_ID = 0xedfd405f
    SUBCLASS_OF_ID = 0x45834829

    def __init__(self, hash, sets):
        """
        :param int hash:
        :param List[TypeStickerSet] sets:

        Constructor for messages.AllStickers: Instance of either AllStickersNotModified, AllStickers.
        """
        self.hash = hash  # type: int
        self.sets = sets  # type: List[TypeStickerSet]

    def to_dict(self):
        return {
            '_': 'AllStickers',
            'hash': self.hash,
            'sets': [] if self.sets is None else [None if x is None else x.to_dict() for x in self.sets]
        }

    def __bytes__(self):
        return b''.join((
            b'_@\xfd\xed',
            struct.pack('<i', self.hash),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.sets)),b''.join(bytes(x) for x in self.sets),
        ))

    @classmethod
    def from_reader(cls, reader):
        _hash = reader.read_int()
        reader.read_int()
        _sets = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _sets.append(_x)

        return cls(hash=_hash, sets=_sets)


class AllStickersNotModified(TLObject):
    CONSTRUCTOR_ID = 0xe86602c3
    SUBCLASS_OF_ID = 0x45834829

    def to_dict(self):
        return {
            '_': 'AllStickersNotModified'
        }

    def __bytes__(self):
        return b''.join((
            b'\xc3\x02f\xe8',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class ArchivedStickers(TLObject):
    CONSTRUCTOR_ID = 0x4fcba9c8
    SUBCLASS_OF_ID = 0x7296d771

    def __init__(self, count, sets):
        """
        :param int count:
        :param List[TypeStickerSetCovered] sets:

        Constructor for messages.ArchivedStickers: Instance of ArchivedStickers.
        """
        self.count = count  # type: int
        self.sets = sets  # type: List[TypeStickerSetCovered]

    def to_dict(self):
        return {
            '_': 'ArchivedStickers',
            'count': self.count,
            'sets': [] if self.sets is None else [None if x is None else x.to_dict() for x in self.sets]
        }

    def __bytes__(self):
        return b''.join((
            b'\xc8\xa9\xcbO',
            struct.pack('<i', self.count),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.sets)),b''.join(bytes(x) for x in self.sets),
        ))

    @classmethod
    def from_reader(cls, reader):
        _count = reader.read_int()
        reader.read_int()
        _sets = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _sets.append(_x)

        return cls(count=_count, sets=_sets)


class BotCallbackAnswer(TLObject):
    CONSTRUCTOR_ID = 0x36585ea4
    SUBCLASS_OF_ID = 0x6c4dd18c

    def __init__(self, cache_time, alert=None, has_url=None, native_ui=None, message=None, url=None):
        """
        :param int cache_time:
        :param Optional[bool] alert:
        :param Optional[bool] has_url:
        :param Optional[bool] native_ui:
        :param Optional[str] message:
        :param Optional[str] url:

        Constructor for messages.BotCallbackAnswer: Instance of BotCallbackAnswer.
        """
        self.cache_time = cache_time  # type: int
        self.alert = alert  # type: Optional[bool]
        self.has_url = has_url  # type: Optional[bool]
        self.native_ui = native_ui  # type: Optional[bool]
        self.message = message  # type: Optional[str]
        self.url = url  # type: Optional[str]

    def to_dict(self):
        return {
            '_': 'BotCallbackAnswer',
            'cache_time': self.cache_time,
            'alert': self.alert,
            'has_url': self.has_url,
            'native_ui': self.native_ui,
            'message': self.message,
            'url': self.url
        }

    def __bytes__(self):
        return b''.join((
            b'\xa4^X6',
            struct.pack('<I', (0 if self.alert is None or self.alert is False else 2) | (0 if self.has_url is None or self.has_url is False else 8) | (0 if self.native_ui is None or self.native_ui is False else 16) | (0 if self.message is None or self.message is False else 1) | (0 if self.url is None or self.url is False else 4)),
            b'' if self.message is None or self.message is False else (self.serialize_bytes(self.message)),
            b'' if self.url is None or self.url is False else (self.serialize_bytes(self.url)),
            struct.pack('<i', self.cache_time),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _alert = bool(flags & 2)
        _has_url = bool(flags & 8)
        _native_ui = bool(flags & 16)
        if flags & 1:
            _message = reader.tgread_string()
        else:
            _message = None
        if flags & 4:
            _url = reader.tgread_string()
        else:
            _url = None
        _cache_time = reader.read_int()
        return cls(cache_time=_cache_time, alert=_alert, has_url=_has_url, native_ui=_native_ui, message=_message, url=_url)


class BotResults(TLObject):
    CONSTRUCTOR_ID = 0x947ca848
    SUBCLASS_OF_ID = 0x3ed4d9c9

    def __init__(self, query_id, results, cache_time, users, gallery=None, next_offset=None, switch_pm=None):
        """
        :param int query_id:
        :param List[TypeBotInlineResult] results:
        :param int cache_time:
        :param List[TypeUser] users:
        :param Optional[bool] gallery:
        :param Optional[str] next_offset:
        :param Optional[TypeInlineBotSwitchPM] switch_pm:

        Constructor for messages.BotResults: Instance of BotResults.
        """
        self.query_id = query_id  # type: int
        self.results = results  # type: List[TypeBotInlineResult]
        self.cache_time = cache_time  # type: int
        self.users = users  # type: List[TypeUser]
        self.gallery = gallery  # type: Optional[bool]
        self.next_offset = next_offset  # type: Optional[str]
        self.switch_pm = switch_pm  # type: Optional[TypeInlineBotSwitchPM]

    def to_dict(self):
        return {
            '_': 'BotResults',
            'query_id': self.query_id,
            'results': [] if self.results is None else [None if x is None else x.to_dict() for x in self.results],
            'cache_time': self.cache_time,
            'users': [] if self.users is None else [None if x is None else x.to_dict() for x in self.users],
            'gallery': self.gallery,
            'next_offset': self.next_offset,
            'switch_pm': None if self.switch_pm is None else self.switch_pm.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'H\xa8|\x94',
            struct.pack('<I', (0 if self.gallery is None or self.gallery is False else 1) | (0 if self.next_offset is None or self.next_offset is False else 2) | (0 if self.switch_pm is None or self.switch_pm is False else 4)),
            struct.pack('<q', self.query_id),
            b'' if self.next_offset is None or self.next_offset is False else (self.serialize_bytes(self.next_offset)),
            b'' if self.switch_pm is None or self.switch_pm is False else (bytes(self.switch_pm)),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.results)),b''.join(bytes(x) for x in self.results),
            struct.pack('<i', self.cache_time),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.users)),b''.join(bytes(x) for x in self.users),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _gallery = bool(flags & 1)
        _query_id = reader.read_long()
        if flags & 2:
            _next_offset = reader.tgread_string()
        else:
            _next_offset = None
        if flags & 4:
            _switch_pm = reader.tgread_object()
        else:
            _switch_pm = None
        reader.read_int()
        _results = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _results.append(_x)

        _cache_time = reader.read_int()
        reader.read_int()
        _users = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _users.append(_x)

        return cls(query_id=_query_id, results=_results, cache_time=_cache_time, users=_users, gallery=_gallery, next_offset=_next_offset, switch_pm=_switch_pm)


class ChannelMessages(TLObject):
    CONSTRUCTOR_ID = 0x99262e37
    SUBCLASS_OF_ID = 0xd4b40b5e

    def __init__(self, pts, count, messages, chats, users):
        """
        :param int pts:
        :param int count:
        :param List[TypeMessage] messages:
        :param List[TypeChat] chats:
        :param List[TypeUser] users:

        Constructor for messages.Messages: Instance of either Messages, MessagesSlice, ChannelMessages, MessagesNotModified.
        """
        self.pts = pts  # type: int
        self.count = count  # type: int
        self.messages = messages  # type: List[TypeMessage]
        self.chats = chats  # type: List[TypeChat]
        self.users = users  # type: List[TypeUser]

    def to_dict(self):
        return {
            '_': 'ChannelMessages',
            'pts': self.pts,
            'count': self.count,
            'messages': [] if self.messages is None else [None if x is None else x.to_dict() for x in self.messages],
            'chats': [] if self.chats is None else [None if x is None else x.to_dict() for x in self.chats],
            'users': [] if self.users is None else [None if x is None else x.to_dict() for x in self.users]
        }

    def __bytes__(self):
        return b''.join((
            b'7.&\x99',
            b'\0\0\0\0',
            struct.pack('<i', self.pts),
            struct.pack('<i', self.count),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.messages)),b''.join(bytes(x) for x in self.messages),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.chats)),b''.join(bytes(x) for x in self.chats),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.users)),b''.join(bytes(x) for x in self.users),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _pts = reader.read_int()
        _count = reader.read_int()
        reader.read_int()
        _messages = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _messages.append(_x)

        reader.read_int()
        _chats = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _chats.append(_x)

        reader.read_int()
        _users = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _users.append(_x)

        return cls(pts=_pts, count=_count, messages=_messages, chats=_chats, users=_users)


class ChatFull(TLObject):
    CONSTRUCTOR_ID = 0xe5d7d19c
    SUBCLASS_OF_ID = 0x225a5109

    def __init__(self, full_chat, chats, users):
        """
        :param TypeChatFull full_chat:
        :param List[TypeChat] chats:
        :param List[TypeUser] users:

        Constructor for messages.ChatFull: Instance of ChatFull.
        """
        self.full_chat = full_chat  # type: TypeChatFull
        self.chats = chats  # type: List[TypeChat]
        self.users = users  # type: List[TypeUser]

    def to_dict(self):
        return {
            '_': 'ChatFull',
            'full_chat': None if self.full_chat is None else self.full_chat.to_dict(),
            'chats': [] if self.chats is None else [None if x is None else x.to_dict() for x in self.chats],
            'users': [] if self.users is None else [None if x is None else x.to_dict() for x in self.users]
        }

    def __bytes__(self):
        return b''.join((
            b'\x9c\xd1\xd7\xe5',
            bytes(self.full_chat),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.chats)),b''.join(bytes(x) for x in self.chats),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.users)),b''.join(bytes(x) for x in self.users),
        ))

    @classmethod
    def from_reader(cls, reader):
        _full_chat = reader.tgread_object()
        reader.read_int()
        _chats = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _chats.append(_x)

        reader.read_int()
        _users = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _users.append(_x)

        return cls(full_chat=_full_chat, chats=_chats, users=_users)


class Chats(TLObject):
    CONSTRUCTOR_ID = 0x64ff9fd5
    SUBCLASS_OF_ID = 0x99d5cb14

    def __init__(self, chats):
        """
        :param List[TypeChat] chats:

        Constructor for messages.Chats: Instance of either Chats, ChatsSlice.
        """
        self.chats = chats  # type: List[TypeChat]

    def to_dict(self):
        return {
            '_': 'Chats',
            'chats': [] if self.chats is None else [None if x is None else x.to_dict() for x in self.chats]
        }

    def __bytes__(self):
        return b''.join((
            b'\xd5\x9f\xffd',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.chats)),b''.join(bytes(x) for x in self.chats),
        ))

    @classmethod
    def from_reader(cls, reader):
        reader.read_int()
        _chats = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _chats.append(_x)

        return cls(chats=_chats)


class ChatsSlice(TLObject):
    CONSTRUCTOR_ID = 0x9cd81144
    SUBCLASS_OF_ID = 0x99d5cb14

    def __init__(self, count, chats):
        """
        :param int count:
        :param List[TypeChat] chats:

        Constructor for messages.Chats: Instance of either Chats, ChatsSlice.
        """
        self.count = count  # type: int
        self.chats = chats  # type: List[TypeChat]

    def to_dict(self):
        return {
            '_': 'ChatsSlice',
            'count': self.count,
            'chats': [] if self.chats is None else [None if x is None else x.to_dict() for x in self.chats]
        }

    def __bytes__(self):
        return b''.join((
            b'D\x11\xd8\x9c',
            struct.pack('<i', self.count),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.chats)),b''.join(bytes(x) for x in self.chats),
        ))

    @classmethod
    def from_reader(cls, reader):
        _count = reader.read_int()
        reader.read_int()
        _chats = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _chats.append(_x)

        return cls(count=_count, chats=_chats)


class DhConfig(TLObject):
    CONSTRUCTOR_ID = 0x2c221edd
    SUBCLASS_OF_ID = 0xe488ed8b

    def __init__(self, g, p, version, random):
        """
        :param int g:
        :param bytes p:
        :param int version:
        :param bytes random:

        Constructor for messages.DhConfig: Instance of either DhConfigNotModified, DhConfig.
        """
        self.g = g  # type: int
        self.p = p  # type: bytes
        self.version = version  # type: int
        self.random = random  # type: bytes

    def to_dict(self):
        return {
            '_': 'DhConfig',
            'g': self.g,
            'p': self.p,
            'version': self.version,
            'random': self.random
        }

    def __bytes__(self):
        return b''.join((
            b'\xdd\x1e",',
            struct.pack('<i', self.g),
            self.serialize_bytes(self.p),
            struct.pack('<i', self.version),
            self.serialize_bytes(self.random),
        ))

    @classmethod
    def from_reader(cls, reader):
        _g = reader.read_int()
        _p = reader.tgread_bytes()
        _version = reader.read_int()
        _random = reader.tgread_bytes()
        return cls(g=_g, p=_p, version=_version, random=_random)


class DhConfigNotModified(TLObject):
    CONSTRUCTOR_ID = 0xc0e24635
    SUBCLASS_OF_ID = 0xe488ed8b

    def __init__(self, random):
        """
        :param bytes random:

        Constructor for messages.DhConfig: Instance of either DhConfigNotModified, DhConfig.
        """
        self.random = random  # type: bytes

    def to_dict(self):
        return {
            '_': 'DhConfigNotModified',
            'random': self.random
        }

    def __bytes__(self):
        return b''.join((
            b'5F\xe2\xc0',
            self.serialize_bytes(self.random),
        ))

    @classmethod
    def from_reader(cls, reader):
        _random = reader.tgread_bytes()
        return cls(random=_random)


class Dialogs(TLObject):
    CONSTRUCTOR_ID = 0x15ba6c40
    SUBCLASS_OF_ID = 0xe1b52ee

    def __init__(self, dialogs, messages, chats, users):
        """
        :param List[TypeDialog] dialogs:
        :param List[TypeMessage] messages:
        :param List[TypeChat] chats:
        :param List[TypeUser] users:

        Constructor for messages.Dialogs: Instance of either Dialogs, DialogsSlice, DialogsNotModified.
        """
        self.dialogs = dialogs  # type: List[TypeDialog]
        self.messages = messages  # type: List[TypeMessage]
        self.chats = chats  # type: List[TypeChat]
        self.users = users  # type: List[TypeUser]

    def to_dict(self):
        return {
            '_': 'Dialogs',
            'dialogs': [] if self.dialogs is None else [None if x is None else x.to_dict() for x in self.dialogs],
            'messages': [] if self.messages is None else [None if x is None else x.to_dict() for x in self.messages],
            'chats': [] if self.chats is None else [None if x is None else x.to_dict() for x in self.chats],
            'users': [] if self.users is None else [None if x is None else x.to_dict() for x in self.users]
        }

    def __bytes__(self):
        return b''.join((
            b'@l\xba\x15',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.dialogs)),b''.join(bytes(x) for x in self.dialogs),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.messages)),b''.join(bytes(x) for x in self.messages),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.chats)),b''.join(bytes(x) for x in self.chats),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.users)),b''.join(bytes(x) for x in self.users),
        ))

    @classmethod
    def from_reader(cls, reader):
        reader.read_int()
        _dialogs = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _dialogs.append(_x)

        reader.read_int()
        _messages = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _messages.append(_x)

        reader.read_int()
        _chats = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _chats.append(_x)

        reader.read_int()
        _users = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _users.append(_x)

        return cls(dialogs=_dialogs, messages=_messages, chats=_chats, users=_users)


class DialogsNotModified(TLObject):
    CONSTRUCTOR_ID = 0xf0e3e596
    SUBCLASS_OF_ID = 0xe1b52ee

    def __init__(self, count):
        """
        :param int count:

        Constructor for messages.Dialogs: Instance of either Dialogs, DialogsSlice, DialogsNotModified.
        """
        self.count = count  # type: int

    def to_dict(self):
        return {
            '_': 'DialogsNotModified',
            'count': self.count
        }

    def __bytes__(self):
        return b''.join((
            b'\x96\xe5\xe3\xf0',
            struct.pack('<i', self.count),
        ))

    @classmethod
    def from_reader(cls, reader):
        _count = reader.read_int()
        return cls(count=_count)


class DialogsSlice(TLObject):
    CONSTRUCTOR_ID = 0x71e094f3
    SUBCLASS_OF_ID = 0xe1b52ee

    def __init__(self, count, dialogs, messages, chats, users):
        """
        :param int count:
        :param List[TypeDialog] dialogs:
        :param List[TypeMessage] messages:
        :param List[TypeChat] chats:
        :param List[TypeUser] users:

        Constructor for messages.Dialogs: Instance of either Dialogs, DialogsSlice, DialogsNotModified.
        """
        self.count = count  # type: int
        self.dialogs = dialogs  # type: List[TypeDialog]
        self.messages = messages  # type: List[TypeMessage]
        self.chats = chats  # type: List[TypeChat]
        self.users = users  # type: List[TypeUser]

    def to_dict(self):
        return {
            '_': 'DialogsSlice',
            'count': self.count,
            'dialogs': [] if self.dialogs is None else [None if x is None else x.to_dict() for x in self.dialogs],
            'messages': [] if self.messages is None else [None if x is None else x.to_dict() for x in self.messages],
            'chats': [] if self.chats is None else [None if x is None else x.to_dict() for x in self.chats],
            'users': [] if self.users is None else [None if x is None else x.to_dict() for x in self.users]
        }

    def __bytes__(self):
        return b''.join((
            b'\xf3\x94\xe0q',
            struct.pack('<i', self.count),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.dialogs)),b''.join(bytes(x) for x in self.dialogs),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.messages)),b''.join(bytes(x) for x in self.messages),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.chats)),b''.join(bytes(x) for x in self.chats),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.users)),b''.join(bytes(x) for x in self.users),
        ))

    @classmethod
    def from_reader(cls, reader):
        _count = reader.read_int()
        reader.read_int()
        _dialogs = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _dialogs.append(_x)

        reader.read_int()
        _messages = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _messages.append(_x)

        reader.read_int()
        _chats = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _chats.append(_x)

        reader.read_int()
        _users = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _users.append(_x)

        return cls(count=_count, dialogs=_dialogs, messages=_messages, chats=_chats, users=_users)


class FavedStickers(TLObject):
    CONSTRUCTOR_ID = 0xf37f2f16
    SUBCLASS_OF_ID = 0x8e736fb9

    def __init__(self, hash, packs, stickers):
        """
        :param int hash:
        :param List[TypeStickerPack] packs:
        :param List[TypeDocument] stickers:

        Constructor for messages.FavedStickers: Instance of either FavedStickersNotModified, FavedStickers.
        """
        self.hash = hash  # type: int
        self.packs = packs  # type: List[TypeStickerPack]
        self.stickers = stickers  # type: List[TypeDocument]

    def to_dict(self):
        return {
            '_': 'FavedStickers',
            'hash': self.hash,
            'packs': [] if self.packs is None else [None if x is None else x.to_dict() for x in self.packs],
            'stickers': [] if self.stickers is None else [None if x is None else x.to_dict() for x in self.stickers]
        }

    def __bytes__(self):
        return b''.join((
            b'\x16/\x7f\xf3',
            struct.pack('<i', self.hash),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.packs)),b''.join(bytes(x) for x in self.packs),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.stickers)),b''.join(bytes(x) for x in self.stickers),
        ))

    @classmethod
    def from_reader(cls, reader):
        _hash = reader.read_int()
        reader.read_int()
        _packs = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _packs.append(_x)

        reader.read_int()
        _stickers = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _stickers.append(_x)

        return cls(hash=_hash, packs=_packs, stickers=_stickers)


class FavedStickersNotModified(TLObject):
    CONSTRUCTOR_ID = 0x9e8fa6d3
    SUBCLASS_OF_ID = 0x8e736fb9

    def to_dict(self):
        return {
            '_': 'FavedStickersNotModified'
        }

    def __bytes__(self):
        return b''.join((
            b'\xd3\xa6\x8f\x9e',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class FeaturedStickers(TLObject):
    CONSTRUCTOR_ID = 0xf89d88e5
    SUBCLASS_OF_ID = 0x2614b722

    def __init__(self, hash, sets, unread):
        """
        :param int hash:
        :param List[TypeStickerSetCovered] sets:
        :param List[int] unread:

        Constructor for messages.FeaturedStickers: Instance of either FeaturedStickersNotModified, FeaturedStickers.
        """
        self.hash = hash  # type: int
        self.sets = sets  # type: List[TypeStickerSetCovered]
        self.unread = unread  # type: List[int]

    def to_dict(self):
        return {
            '_': 'FeaturedStickers',
            'hash': self.hash,
            'sets': [] if self.sets is None else [None if x is None else x.to_dict() for x in self.sets],
            'unread': [] if self.unread is None else self.unread[:]
        }

    def __bytes__(self):
        return b''.join((
            b'\xe5\x88\x9d\xf8',
            struct.pack('<i', self.hash),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.sets)),b''.join(bytes(x) for x in self.sets),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.unread)),b''.join(struct.pack('<q', x) for x in self.unread),
        ))

    @classmethod
    def from_reader(cls, reader):
        _hash = reader.read_int()
        reader.read_int()
        _sets = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _sets.append(_x)

        reader.read_int()
        _unread = []
        for _ in range(reader.read_int()):
            _x = reader.read_long()
            _unread.append(_x)

        return cls(hash=_hash, sets=_sets, unread=_unread)


class FeaturedStickersNotModified(TLObject):
    CONSTRUCTOR_ID = 0x4ede3cf
    SUBCLASS_OF_ID = 0x2614b722

    def to_dict(self):
        return {
            '_': 'FeaturedStickersNotModified'
        }

    def __bytes__(self):
        return b''.join((
            b'\xcf\xe3\xed\x04',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class FoundGifs(TLObject):
    CONSTRUCTOR_ID = 0x450a1c0a
    SUBCLASS_OF_ID = 0xe799ea7

    def __init__(self, next_offset, results):
        """
        :param int next_offset:
        :param List[TypeFoundGif] results:

        Constructor for messages.FoundGifs: Instance of FoundGifs.
        """
        self.next_offset = next_offset  # type: int
        self.results = results  # type: List[TypeFoundGif]

    def to_dict(self):
        return {
            '_': 'FoundGifs',
            'next_offset': self.next_offset,
            'results': [] if self.results is None else [None if x is None else x.to_dict() for x in self.results]
        }

    def __bytes__(self):
        return b''.join((
            b'\n\x1c\nE',
            struct.pack('<i', self.next_offset),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.results)),b''.join(bytes(x) for x in self.results),
        ))

    @classmethod
    def from_reader(cls, reader):
        _next_offset = reader.read_int()
        reader.read_int()
        _results = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _results.append(_x)

        return cls(next_offset=_next_offset, results=_results)


class FoundStickerSets(TLObject):
    CONSTRUCTOR_ID = 0x5108d648
    SUBCLASS_OF_ID = 0x40df361

    def __init__(self, hash, sets):
        """
        :param int hash:
        :param List[TypeStickerSetCovered] sets:

        Constructor for messages.FoundStickerSets: Instance of either FoundStickerSetsNotModified, FoundStickerSets.
        """
        self.hash = hash  # type: int
        self.sets = sets  # type: List[TypeStickerSetCovered]

    def to_dict(self):
        return {
            '_': 'FoundStickerSets',
            'hash': self.hash,
            'sets': [] if self.sets is None else [None if x is None else x.to_dict() for x in self.sets]
        }

    def __bytes__(self):
        return b''.join((
            b'H\xd6\x08Q',
            struct.pack('<i', self.hash),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.sets)),b''.join(bytes(x) for x in self.sets),
        ))

    @classmethod
    def from_reader(cls, reader):
        _hash = reader.read_int()
        reader.read_int()
        _sets = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _sets.append(_x)

        return cls(hash=_hash, sets=_sets)


class FoundStickerSetsNotModified(TLObject):
    CONSTRUCTOR_ID = 0xd54b65d
    SUBCLASS_OF_ID = 0x40df361

    def to_dict(self):
        return {
            '_': 'FoundStickerSetsNotModified'
        }

    def __bytes__(self):
        return b''.join((
            b']\xb6T\r',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class HighScores(TLObject):
    CONSTRUCTOR_ID = 0x9a3bfd99
    SUBCLASS_OF_ID = 0x6ccd95fd

    def __init__(self, scores, users):
        """
        :param List[TypeHighScore] scores:
        :param List[TypeUser] users:

        Constructor for messages.HighScores: Instance of HighScores.
        """
        self.scores = scores  # type: List[TypeHighScore]
        self.users = users  # type: List[TypeUser]

    def to_dict(self):
        return {
            '_': 'HighScores',
            'scores': [] if self.scores is None else [None if x is None else x.to_dict() for x in self.scores],
            'users': [] if self.users is None else [None if x is None else x.to_dict() for x in self.users]
        }

    def __bytes__(self):
        return b''.join((
            b'\x99\xfd;\x9a',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.scores)),b''.join(bytes(x) for x in self.scores),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.users)),b''.join(bytes(x) for x in self.users),
        ))

    @classmethod
    def from_reader(cls, reader):
        reader.read_int()
        _scores = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _scores.append(_x)

        reader.read_int()
        _users = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _users.append(_x)

        return cls(scores=_scores, users=_users)


class MessageEditData(TLObject):
    CONSTRUCTOR_ID = 0x26b5dde6
    SUBCLASS_OF_ID = 0xfb47949d

    def __init__(self, caption=None):
        """
        :param Optional[bool] caption:

        Constructor for messages.MessageEditData: Instance of MessageEditData.
        """
        self.caption = caption  # type: Optional[bool]

    def to_dict(self):
        return {
            '_': 'MessageEditData',
            'caption': self.caption
        }

    def __bytes__(self):
        return b''.join((
            b'\xe6\xdd\xb5&',
            struct.pack('<I', (0 if self.caption is None or self.caption is False else 1)),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _caption = bool(flags & 1)
        return cls(caption=_caption)


class Messages(TLObject):
    CONSTRUCTOR_ID = 0x8c718e87
    SUBCLASS_OF_ID = 0xd4b40b5e

    def __init__(self, messages, chats, users):
        """
        :param List[TypeMessage] messages:
        :param List[TypeChat] chats:
        :param List[TypeUser] users:

        Constructor for messages.Messages: Instance of either Messages, MessagesSlice, ChannelMessages, MessagesNotModified.
        """
        self.messages = messages  # type: List[TypeMessage]
        self.chats = chats  # type: List[TypeChat]
        self.users = users  # type: List[TypeUser]

    def to_dict(self):
        return {
            '_': 'Messages',
            'messages': [] if self.messages is None else [None if x is None else x.to_dict() for x in self.messages],
            'chats': [] if self.chats is None else [None if x is None else x.to_dict() for x in self.chats],
            'users': [] if self.users is None else [None if x is None else x.to_dict() for x in self.users]
        }

    def __bytes__(self):
        return b''.join((
            b'\x87\x8eq\x8c',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.messages)),b''.join(bytes(x) for x in self.messages),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.chats)),b''.join(bytes(x) for x in self.chats),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.users)),b''.join(bytes(x) for x in self.users),
        ))

    @classmethod
    def from_reader(cls, reader):
        reader.read_int()
        _messages = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _messages.append(_x)

        reader.read_int()
        _chats = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _chats.append(_x)

        reader.read_int()
        _users = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _users.append(_x)

        return cls(messages=_messages, chats=_chats, users=_users)


class MessagesNotModified(TLObject):
    CONSTRUCTOR_ID = 0x74535f21
    SUBCLASS_OF_ID = 0xd4b40b5e

    def __init__(self, count):
        """
        :param int count:

        Constructor for messages.Messages: Instance of either Messages, MessagesSlice, ChannelMessages, MessagesNotModified.
        """
        self.count = count  # type: int

    def to_dict(self):
        return {
            '_': 'MessagesNotModified',
            'count': self.count
        }

    def __bytes__(self):
        return b''.join((
            b'!_St',
            struct.pack('<i', self.count),
        ))

    @classmethod
    def from_reader(cls, reader):
        _count = reader.read_int()
        return cls(count=_count)


class MessagesSlice(TLObject):
    CONSTRUCTOR_ID = 0xb446ae3
    SUBCLASS_OF_ID = 0xd4b40b5e

    def __init__(self, count, messages, chats, users):
        """
        :param int count:
        :param List[TypeMessage] messages:
        :param List[TypeChat] chats:
        :param List[TypeUser] users:

        Constructor for messages.Messages: Instance of either Messages, MessagesSlice, ChannelMessages, MessagesNotModified.
        """
        self.count = count  # type: int
        self.messages = messages  # type: List[TypeMessage]
        self.chats = chats  # type: List[TypeChat]
        self.users = users  # type: List[TypeUser]

    def to_dict(self):
        return {
            '_': 'MessagesSlice',
            'count': self.count,
            'messages': [] if self.messages is None else [None if x is None else x.to_dict() for x in self.messages],
            'chats': [] if self.chats is None else [None if x is None else x.to_dict() for x in self.chats],
            'users': [] if self.users is None else [None if x is None else x.to_dict() for x in self.users]
        }

    def __bytes__(self):
        return b''.join((
            b'\xe3jD\x0b',
            struct.pack('<i', self.count),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.messages)),b''.join(bytes(x) for x in self.messages),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.chats)),b''.join(bytes(x) for x in self.chats),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.users)),b''.join(bytes(x) for x in self.users),
        ))

    @classmethod
    def from_reader(cls, reader):
        _count = reader.read_int()
        reader.read_int()
        _messages = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _messages.append(_x)

        reader.read_int()
        _chats = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _chats.append(_x)

        reader.read_int()
        _users = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _users.append(_x)

        return cls(count=_count, messages=_messages, chats=_chats, users=_users)


class PeerDialogs(TLObject):
    CONSTRUCTOR_ID = 0x3371c354
    SUBCLASS_OF_ID = 0x3ac70132

    def __init__(self, dialogs, messages, chats, users, state):
        """
        :param List[TypeDialog] dialogs:
        :param List[TypeMessage] messages:
        :param List[TypeChat] chats:
        :param List[TypeUser] users:
        :param TypeState state:

        Constructor for messages.PeerDialogs: Instance of PeerDialogs.
        """
        self.dialogs = dialogs  # type: List[TypeDialog]
        self.messages = messages  # type: List[TypeMessage]
        self.chats = chats  # type: List[TypeChat]
        self.users = users  # type: List[TypeUser]
        self.state = state  # type: TypeState

    def to_dict(self):
        return {
            '_': 'PeerDialogs',
            'dialogs': [] if self.dialogs is None else [None if x is None else x.to_dict() for x in self.dialogs],
            'messages': [] if self.messages is None else [None if x is None else x.to_dict() for x in self.messages],
            'chats': [] if self.chats is None else [None if x is None else x.to_dict() for x in self.chats],
            'users': [] if self.users is None else [None if x is None else x.to_dict() for x in self.users],
            'state': None if self.state is None else self.state.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'T\xc3q3',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.dialogs)),b''.join(bytes(x) for x in self.dialogs),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.messages)),b''.join(bytes(x) for x in self.messages),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.chats)),b''.join(bytes(x) for x in self.chats),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.users)),b''.join(bytes(x) for x in self.users),
            bytes(self.state),
        ))

    @classmethod
    def from_reader(cls, reader):
        reader.read_int()
        _dialogs = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _dialogs.append(_x)

        reader.read_int()
        _messages = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _messages.append(_x)

        reader.read_int()
        _chats = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _chats.append(_x)

        reader.read_int()
        _users = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _users.append(_x)

        _state = reader.tgread_object()
        return cls(dialogs=_dialogs, messages=_messages, chats=_chats, users=_users, state=_state)


class RecentStickers(TLObject):
    CONSTRUCTOR_ID = 0x22f3afb3
    SUBCLASS_OF_ID = 0xf76f8683

    def __init__(self, hash, packs, stickers, dates):
        """
        :param int hash:
        :param List[TypeStickerPack] packs:
        :param List[TypeDocument] stickers:
        :param List[int] dates:

        Constructor for messages.RecentStickers: Instance of either RecentStickersNotModified, RecentStickers.
        """
        self.hash = hash  # type: int
        self.packs = packs  # type: List[TypeStickerPack]
        self.stickers = stickers  # type: List[TypeDocument]
        self.dates = dates  # type: List[int]

    def to_dict(self):
        return {
            '_': 'RecentStickers',
            'hash': self.hash,
            'packs': [] if self.packs is None else [None if x is None else x.to_dict() for x in self.packs],
            'stickers': [] if self.stickers is None else [None if x is None else x.to_dict() for x in self.stickers],
            'dates': [] if self.dates is None else self.dates[:]
        }

    def __bytes__(self):
        return b''.join((
            b'\xb3\xaf\xf3"',
            struct.pack('<i', self.hash),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.packs)),b''.join(bytes(x) for x in self.packs),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.stickers)),b''.join(bytes(x) for x in self.stickers),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.dates)),b''.join(struct.pack('<i', x) for x in self.dates),
        ))

    @classmethod
    def from_reader(cls, reader):
        _hash = reader.read_int()
        reader.read_int()
        _packs = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _packs.append(_x)

        reader.read_int()
        _stickers = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _stickers.append(_x)

        reader.read_int()
        _dates = []
        for _ in range(reader.read_int()):
            _x = reader.read_int()
            _dates.append(_x)

        return cls(hash=_hash, packs=_packs, stickers=_stickers, dates=_dates)


class RecentStickersNotModified(TLObject):
    CONSTRUCTOR_ID = 0xb17f890
    SUBCLASS_OF_ID = 0xf76f8683

    def to_dict(self):
        return {
            '_': 'RecentStickersNotModified'
        }

    def __bytes__(self):
        return b''.join((
            b'\x90\xf8\x17\x0b',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class SavedGifs(TLObject):
    CONSTRUCTOR_ID = 0x2e0709a5
    SUBCLASS_OF_ID = 0xa68b61f5

    def __init__(self, hash, gifs):
        """
        :param int hash:
        :param List[TypeDocument] gifs:

        Constructor for messages.SavedGifs: Instance of either SavedGifsNotModified, SavedGifs.
        """
        self.hash = hash  # type: int
        self.gifs = gifs  # type: List[TypeDocument]

    def to_dict(self):
        return {
            '_': 'SavedGifs',
            'hash': self.hash,
            'gifs': [] if self.gifs is None else [None if x is None else x.to_dict() for x in self.gifs]
        }

    def __bytes__(self):
        return b''.join((
            b'\xa5\t\x07.',
            struct.pack('<i', self.hash),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.gifs)),b''.join(bytes(x) for x in self.gifs),
        ))

    @classmethod
    def from_reader(cls, reader):
        _hash = reader.read_int()
        reader.read_int()
        _gifs = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _gifs.append(_x)

        return cls(hash=_hash, gifs=_gifs)


class SavedGifsNotModified(TLObject):
    CONSTRUCTOR_ID = 0xe8025ca2
    SUBCLASS_OF_ID = 0xa68b61f5

    def to_dict(self):
        return {
            '_': 'SavedGifsNotModified'
        }

    def __bytes__(self):
        return b''.join((
            b'\xa2\\\x02\xe8',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class SentEncryptedFile(TLObject):
    CONSTRUCTOR_ID = 0x9493ff32
    SUBCLASS_OF_ID = 0xc99e3e50

    def __init__(self, date, file):
        """
        :param Optional[datetime] date:
        :param TypeEncryptedFile file:

        Constructor for messages.SentEncryptedMessage: Instance of either SentEncryptedMessage, SentEncryptedFile.
        """
        self.date = date  # type: Optional[datetime]
        self.file = file  # type: TypeEncryptedFile

    def to_dict(self):
        return {
            '_': 'SentEncryptedFile',
            'date': self.date,
            'file': None if self.file is None else self.file.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'2\xff\x93\x94',
            self.serialize_datetime(self.date),
            bytes(self.file),
        ))

    @classmethod
    def from_reader(cls, reader):
        _date = reader.tgread_date()
        _file = reader.tgread_object()
        return cls(date=_date, file=_file)


class SentEncryptedMessage(TLObject):
    CONSTRUCTOR_ID = 0x560f8935
    SUBCLASS_OF_ID = 0xc99e3e50

    def __init__(self, date):
        """
        :param Optional[datetime] date:

        Constructor for messages.SentEncryptedMessage: Instance of either SentEncryptedMessage, SentEncryptedFile.
        """
        self.date = date  # type: Optional[datetime]

    def to_dict(self):
        return {
            '_': 'SentEncryptedMessage',
            'date': self.date
        }

    def __bytes__(self):
        return b''.join((
            b'5\x89\x0fV',
            self.serialize_datetime(self.date),
        ))

    @classmethod
    def from_reader(cls, reader):
        _date = reader.tgread_date()
        return cls(date=_date)


class StickerSet(TLObject):
    CONSTRUCTOR_ID = 0xb60a24a6
    SUBCLASS_OF_ID = 0x9b704a5a

    def __init__(self, set, packs, documents):
        """
        :param TypeStickerSet set:
        :param List[TypeStickerPack] packs:
        :param List[TypeDocument] documents:

        Constructor for messages.StickerSet: Instance of StickerSet.
        """
        self.set = set  # type: TypeStickerSet
        self.packs = packs  # type: List[TypeStickerPack]
        self.documents = documents  # type: List[TypeDocument]

    def to_dict(self):
        return {
            '_': 'StickerSet',
            'set': None if self.set is None else self.set.to_dict(),
            'packs': [] if self.packs is None else [None if x is None else x.to_dict() for x in self.packs],
            'documents': [] if self.documents is None else [None if x is None else x.to_dict() for x in self.documents]
        }

    def __bytes__(self):
        return b''.join((
            b'\xa6$\n\xb6',
            bytes(self.set),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.packs)),b''.join(bytes(x) for x in self.packs),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.documents)),b''.join(bytes(x) for x in self.documents),
        ))

    @classmethod
    def from_reader(cls, reader):
        _set = reader.tgread_object()
        reader.read_int()
        _packs = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _packs.append(_x)

        reader.read_int()
        _documents = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _documents.append(_x)

        return cls(set=_set, packs=_packs, documents=_documents)


class StickerSetInstallResultArchive(TLObject):
    CONSTRUCTOR_ID = 0x35e410a8
    SUBCLASS_OF_ID = 0x67cb3fe8

    def __init__(self, sets):
        """
        :param List[TypeStickerSetCovered] sets:

        Constructor for messages.StickerSetInstallResult: Instance of either StickerSetInstallResultSuccess, StickerSetInstallResultArchive.
        """
        self.sets = sets  # type: List[TypeStickerSetCovered]

    def to_dict(self):
        return {
            '_': 'StickerSetInstallResultArchive',
            'sets': [] if self.sets is None else [None if x is None else x.to_dict() for x in self.sets]
        }

    def __bytes__(self):
        return b''.join((
            b'\xa8\x10\xe45',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.sets)),b''.join(bytes(x) for x in self.sets),
        ))

    @classmethod
    def from_reader(cls, reader):
        reader.read_int()
        _sets = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _sets.append(_x)

        return cls(sets=_sets)


class StickerSetInstallResultSuccess(TLObject):
    CONSTRUCTOR_ID = 0x38641628
    SUBCLASS_OF_ID = 0x67cb3fe8

    def to_dict(self):
        return {
            '_': 'StickerSetInstallResultSuccess'
        }

    def __bytes__(self):
        return b''.join((
            b'(\x16d8',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class Stickers(TLObject):
    CONSTRUCTOR_ID = 0xe4599bbd
    SUBCLASS_OF_ID = 0xd73bb9de

    def __init__(self, hash, stickers):
        """
        :param int hash:
        :param List[TypeDocument] stickers:

        Constructor for messages.Stickers: Instance of either StickersNotModified, Stickers.
        """
        self.hash = hash  # type: int
        self.stickers = stickers  # type: List[TypeDocument]

    def to_dict(self):
        return {
            '_': 'Stickers',
            'hash': self.hash,
            'stickers': [] if self.stickers is None else [None if x is None else x.to_dict() for x in self.stickers]
        }

    def __bytes__(self):
        return b''.join((
            b'\xbd\x9bY\xe4',
            struct.pack('<i', self.hash),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.stickers)),b''.join(bytes(x) for x in self.stickers),
        ))

    @classmethod
    def from_reader(cls, reader):
        _hash = reader.read_int()
        reader.read_int()
        _stickers = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _stickers.append(_x)

        return cls(hash=_hash, stickers=_stickers)


class StickersNotModified(TLObject):
    CONSTRUCTOR_ID = 0xf1749a22
    SUBCLASS_OF_ID = 0xd73bb9de

    def to_dict(self):
        return {
            '_': 'StickersNotModified'
        }

    def __bytes__(self):
        return b''.join((
            b'"\x9at\xf1',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()

