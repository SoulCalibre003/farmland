"""File generated by TLObjects' generator. All changes will be ERASED"""
from ...tl.tlobject import TLObject
from typing import Optional, List, Union, TYPE_CHECKING
import os
import struct
if TYPE_CHECKING:
    from ...tl.types import TypeMessageEntity, TypeRecentMeUrl, TypeChat, TypePeer, TypeBool, TypeUser, TypeDataJSON, TypeAccessPointRule
    from ...tl.types.help import TypeTermsOfService



class AppUpdate(TLObject):
    CONSTRUCTOR_ID = 0x8987f311
    SUBCLASS_OF_ID = 0x5897069e

    def __init__(self, id, critical, url, text):
        """
        :param int id:
        :param TypeBool critical:
        :param str url:
        :param str text:

        Constructor for help.AppUpdate: Instance of either AppUpdate, NoAppUpdate.
        """
        self.id = id  # type: int
        self.critical = critical  # type: TypeBool
        self.url = url  # type: str
        self.text = text  # type: str

    def to_dict(self):
        return {
            '_': 'AppUpdate',
            'id': self.id,
            'critical': self.critical,
            'url': self.url,
            'text': self.text
        }

    def __bytes__(self):
        return b''.join((
            b'\x11\xf3\x87\x89',
            struct.pack('<i', self.id),
            b'\xb5ur\x99' if self.critical else b'7\x97y\xbc',
            self.serialize_bytes(self.url),
            self.serialize_bytes(self.text),
        ))

    @classmethod
    def from_reader(cls, reader):
        _id = reader.read_int()
        _critical = reader.tgread_bool()
        _url = reader.tgread_string()
        _text = reader.tgread_string()
        return cls(id=_id, critical=_critical, url=_url, text=_text)


class ConfigSimple(TLObject):
    CONSTRUCTOR_ID = 0x5a592a6c
    SUBCLASS_OF_ID = 0x29183ac4

    def __init__(self, date, expires, rules):
        """
        :param Optional[datetime] date:
        :param Optional[datetime] expires:
        :param List[TypeAccessPointRule] rules:

        Constructor for help.ConfigSimple: Instance of ConfigSimple.
        """
        self.date = date  # type: Optional[datetime]
        self.expires = expires  # type: Optional[datetime]
        self.rules = rules  # type: List[TypeAccessPointRule]

    def to_dict(self):
        return {
            '_': 'ConfigSimple',
            'date': self.date,
            'expires': self.expires,
            'rules': [] if self.rules is None else [None if x is None else x.to_dict() for x in self.rules]
        }

    def __bytes__(self):
        return b''.join((
            b'l*YZ',
            self.serialize_datetime(self.date),
            self.serialize_datetime(self.expires),
            struct.pack('<i', len(self.rules)),b''.join(bytes(x) for x in self.rules),
        ))

    @classmethod
    def from_reader(cls, reader):
        _date = reader.tgread_date()
        _expires = reader.tgread_date()
        _rules = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _rules.append(_x)

        return cls(date=_date, expires=_expires, rules=_rules)


class DeepLinkInfo(TLObject):
    CONSTRUCTOR_ID = 0x6a4ee832
    SUBCLASS_OF_ID = 0x984aac38

    def __init__(self, message, update_app=None, entities=None):
        """
        :param str message:
        :param Optional[bool] update_app:
        :param Optional[List[TypeMessageEntity]] entities:

        Constructor for help.DeepLinkInfo: Instance of either DeepLinkInfoEmpty, DeepLinkInfo.
        """
        self.message = message  # type: str
        self.update_app = update_app  # type: Optional[bool]
        self.entities = entities  # type: Optional[List[TypeMessageEntity]]

    def to_dict(self):
        return {
            '_': 'DeepLinkInfo',
            'message': self.message,
            'update_app': self.update_app,
            'entities': [] if self.entities is None else [None if x is None else x.to_dict() for x in self.entities]
        }

    def __bytes__(self):
        return b''.join((
            b'2\xe8Nj',
            struct.pack('<I', (0 if self.update_app is None or self.update_app is False else 1) | (0 if self.entities is None or self.entities is False else 2)),
            self.serialize_bytes(self.message),
            b'' if self.entities is None or self.entities is False else b''.join((b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.entities)),b''.join(bytes(x) for x in self.entities))),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _update_app = bool(flags & 1)
        _message = reader.tgread_string()
        if flags & 2:
            reader.read_int()
            _entities = []
            for _ in range(reader.read_int()):
                _x = reader.tgread_object()
                _entities.append(_x)

        else:
            _entities = None
        return cls(message=_message, update_app=_update_app, entities=_entities)


class DeepLinkInfoEmpty(TLObject):
    CONSTRUCTOR_ID = 0x66afa166
    SUBCLASS_OF_ID = 0x984aac38

    def to_dict(self):
        return {
            '_': 'DeepLinkInfoEmpty'
        }

    def __bytes__(self):
        return b''.join((
            b'f\xa1\xaff',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class InviteText(TLObject):
    CONSTRUCTOR_ID = 0x18cb9f78
    SUBCLASS_OF_ID = 0xcf70aa35

    def __init__(self, message):
        """
        :param str message:

        Constructor for help.InviteText: Instance of InviteText.
        """
        self.message = message  # type: str

    def to_dict(self):
        return {
            '_': 'InviteText',
            'message': self.message
        }

    def __bytes__(self):
        return b''.join((
            b'x\x9f\xcb\x18',
            self.serialize_bytes(self.message),
        ))

    @classmethod
    def from_reader(cls, reader):
        _message = reader.tgread_string()
        return cls(message=_message)


class NoAppUpdate(TLObject):
    CONSTRUCTOR_ID = 0xc45a6536
    SUBCLASS_OF_ID = 0x5897069e

    def to_dict(self):
        return {
            '_': 'NoAppUpdate'
        }

    def __bytes__(self):
        return b''.join((
            b'6eZ\xc4',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class ProxyDataEmpty(TLObject):
    CONSTRUCTOR_ID = 0xe09e1fb8
    SUBCLASS_OF_ID = 0x21e2a448

    def __init__(self, expires):
        """
        :param Optional[datetime] expires:

        Constructor for help.ProxyData: Instance of either ProxyDataEmpty, ProxyDataPromo.
        """
        self.expires = expires  # type: Optional[datetime]

    def to_dict(self):
        return {
            '_': 'ProxyDataEmpty',
            'expires': self.expires
        }

    def __bytes__(self):
        return b''.join((
            b'\xb8\x1f\x9e\xe0',
            self.serialize_datetime(self.expires),
        ))

    @classmethod
    def from_reader(cls, reader):
        _expires = reader.tgread_date()
        return cls(expires=_expires)


class ProxyDataPromo(TLObject):
    CONSTRUCTOR_ID = 0x2bf7ee23
    SUBCLASS_OF_ID = 0x21e2a448

    def __init__(self, expires, peer, chats, users):
        """
        :param Optional[datetime] expires:
        :param TypePeer peer:
        :param List[TypeChat] chats:
        :param List[TypeUser] users:

        Constructor for help.ProxyData: Instance of either ProxyDataEmpty, ProxyDataPromo.
        """
        self.expires = expires  # type: Optional[datetime]
        self.peer = peer  # type: TypePeer
        self.chats = chats  # type: List[TypeChat]
        self.users = users  # type: List[TypeUser]

    def to_dict(self):
        return {
            '_': 'ProxyDataPromo',
            'expires': self.expires,
            'peer': None if self.peer is None else self.peer.to_dict(),
            'chats': [] if self.chats is None else [None if x is None else x.to_dict() for x in self.chats],
            'users': [] if self.users is None else [None if x is None else x.to_dict() for x in self.users]
        }

    def __bytes__(self):
        return b''.join((
            b'#\xee\xf7+',
            self.serialize_datetime(self.expires),
            bytes(self.peer),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.chats)),b''.join(bytes(x) for x in self.chats),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.users)),b''.join(bytes(x) for x in self.users),
        ))

    @classmethod
    def from_reader(cls, reader):
        _expires = reader.tgread_date()
        _peer = reader.tgread_object()
        reader.read_int()
        _chats = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _chats.append(_x)

        reader.read_int()
        _users = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _users.append(_x)

        return cls(expires=_expires, peer=_peer, chats=_chats, users=_users)


class RecentMeUrls(TLObject):
    CONSTRUCTOR_ID = 0xe0310d7
    SUBCLASS_OF_ID = 0xf269c477

    def __init__(self, urls, chats, users):
        """
        :param List[TypeRecentMeUrl] urls:
        :param List[TypeChat] chats:
        :param List[TypeUser] users:

        Constructor for help.RecentMeUrls: Instance of RecentMeUrls.
        """
        self.urls = urls  # type: List[TypeRecentMeUrl]
        self.chats = chats  # type: List[TypeChat]
        self.users = users  # type: List[TypeUser]

    def to_dict(self):
        return {
            '_': 'RecentMeUrls',
            'urls': [] if self.urls is None else [None if x is None else x.to_dict() for x in self.urls],
            'chats': [] if self.chats is None else [None if x is None else x.to_dict() for x in self.chats],
            'users': [] if self.users is None else [None if x is None else x.to_dict() for x in self.users]
        }

    def __bytes__(self):
        return b''.join((
            b'\xd7\x10\x03\x0e',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.urls)),b''.join(bytes(x) for x in self.urls),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.chats)),b''.join(bytes(x) for x in self.chats),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.users)),b''.join(bytes(x) for x in self.users),
        ))

    @classmethod
    def from_reader(cls, reader):
        reader.read_int()
        _urls = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _urls.append(_x)

        reader.read_int()
        _chats = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _chats.append(_x)

        reader.read_int()
        _users = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _users.append(_x)

        return cls(urls=_urls, chats=_chats, users=_users)


class Support(TLObject):
    CONSTRUCTOR_ID = 0x17c6b5f6
    SUBCLASS_OF_ID = 0x7159bceb

    def __init__(self, phone_number, user):
        """
        :param str phone_number:
        :param TypeUser user:

        Constructor for help.Support: Instance of Support.
        """
        self.phone_number = phone_number  # type: str
        self.user = user  # type: TypeUser

    def to_dict(self):
        return {
            '_': 'Support',
            'phone_number': self.phone_number,
            'user': None if self.user is None else self.user.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\xf6\xb5\xc6\x17',
            self.serialize_bytes(self.phone_number),
            bytes(self.user),
        ))

    @classmethod
    def from_reader(cls, reader):
        _phone_number = reader.tgread_string()
        _user = reader.tgread_object()
        return cls(phone_number=_phone_number, user=_user)


class TermsOfService(TLObject):
    CONSTRUCTOR_ID = 0x780a0310
    SUBCLASS_OF_ID = 0x20ee8312

    def __init__(self, id, text, entities, popup=None, min_age_confirm=None):
        """
        :param TypeDataJSON id:
        :param str text:
        :param List[TypeMessageEntity] entities:
        :param Optional[bool] popup:
        :param Optional[int] min_age_confirm:

        Constructor for help.TermsOfService: Instance of TermsOfService.
        """
        self.id = id  # type: TypeDataJSON
        self.text = text  # type: str
        self.entities = entities  # type: List[TypeMessageEntity]
        self.popup = popup  # type: Optional[bool]
        self.min_age_confirm = min_age_confirm  # type: Optional[int]

    def to_dict(self):
        return {
            '_': 'TermsOfService',
            'id': None if self.id is None else self.id.to_dict(),
            'text': self.text,
            'entities': [] if self.entities is None else [None if x is None else x.to_dict() for x in self.entities],
            'popup': self.popup,
            'min_age_confirm': self.min_age_confirm
        }

    def __bytes__(self):
        return b''.join((
            b'\x10\x03\nx',
            struct.pack('<I', (0 if self.popup is None or self.popup is False else 1) | (0 if self.min_age_confirm is None or self.min_age_confirm is False else 2)),
            bytes(self.id),
            self.serialize_bytes(self.text),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.entities)),b''.join(bytes(x) for x in self.entities),
            b'' if self.min_age_confirm is None or self.min_age_confirm is False else (struct.pack('<i', self.min_age_confirm)),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _popup = bool(flags & 1)
        _id = reader.tgread_object()
        _text = reader.tgread_string()
        reader.read_int()
        _entities = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _entities.append(_x)

        if flags & 2:
            _min_age_confirm = reader.read_int()
        else:
            _min_age_confirm = None
        return cls(id=_id, text=_text, entities=_entities, popup=_popup, min_age_confirm=_min_age_confirm)


class TermsOfServiceUpdate(TLObject):
    CONSTRUCTOR_ID = 0x28ecf961
    SUBCLASS_OF_ID = 0x293c2977

    def __init__(self, expires, terms_of_service):
        """
        :param Optional[datetime] expires:
        :param TypeTermsOfService terms_of_service:

        Constructor for help.TermsOfServiceUpdate: Instance of either TermsOfServiceUpdateEmpty, TermsOfServiceUpdate.
        """
        self.expires = expires  # type: Optional[datetime]
        self.terms_of_service = terms_of_service  # type: TypeTermsOfService

    def to_dict(self):
        return {
            '_': 'TermsOfServiceUpdate',
            'expires': self.expires,
            'terms_of_service': None if self.terms_of_service is None else self.terms_of_service.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'a\xf9\xec(',
            self.serialize_datetime(self.expires),
            bytes(self.terms_of_service),
        ))

    @classmethod
    def from_reader(cls, reader):
        _expires = reader.tgread_date()
        _terms_of_service = reader.tgread_object()
        return cls(expires=_expires, terms_of_service=_terms_of_service)


class TermsOfServiceUpdateEmpty(TLObject):
    CONSTRUCTOR_ID = 0xe3309f7f
    SUBCLASS_OF_ID = 0x293c2977

    def __init__(self, expires):
        """
        :param Optional[datetime] expires:

        Constructor for help.TermsOfServiceUpdate: Instance of either TermsOfServiceUpdateEmpty, TermsOfServiceUpdate.
        """
        self.expires = expires  # type: Optional[datetime]

    def to_dict(self):
        return {
            '_': 'TermsOfServiceUpdateEmpty',
            'expires': self.expires
        }

    def __bytes__(self):
        return b''.join((
            b'\x7f\x9f0\xe3',
            self.serialize_datetime(self.expires),
        ))

    @classmethod
    def from_reader(cls, reader):
        _expires = reader.tgread_date()
        return cls(expires=_expires)

