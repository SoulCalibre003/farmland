"""File generated by TLObjects' generator. All changes will be ERASED"""
from ...tl.tlobject import TLObject
from typing import Optional, List, Union, TYPE_CHECKING
import os
import struct
if TYPE_CHECKING:
    from ...tl.types import TypeSecureValueType, TypeWebAuthorization, TypeSecureValue, TypeSecureValueError, TypeUser, TypePrivacyRule, TypeAuthorization



class AuthorizationForm(TLObject):
    CONSTRUCTOR_ID = 0xcb976d53
    SUBCLASS_OF_ID = 0x78049a94

    def __init__(self, required_types, values, errors, users, selfie_required=None, privacy_policy_url=None):
        """
        :param List[TypeSecureValueType] required_types:
        :param List[TypeSecureValue] values:
        :param List[TypeSecureValueError] errors:
        :param List[TypeUser] users:
        :param Optional[bool] selfie_required:
        :param Optional[str] privacy_policy_url:

        Constructor for account.AuthorizationForm: Instance of AuthorizationForm.
        """
        self.required_types = required_types  # type: List[TypeSecureValueType]
        self.values = values  # type: List[TypeSecureValue]
        self.errors = errors  # type: List[TypeSecureValueError]
        self.users = users  # type: List[TypeUser]
        self.selfie_required = selfie_required  # type: Optional[bool]
        self.privacy_policy_url = privacy_policy_url  # type: Optional[str]

    def to_dict(self):
        return {
            '_': 'AuthorizationForm',
            'required_types': [] if self.required_types is None else [None if x is None else x.to_dict() for x in self.required_types],
            'values': [] if self.values is None else [None if x is None else x.to_dict() for x in self.values],
            'errors': [] if self.errors is None else [None if x is None else x.to_dict() for x in self.errors],
            'users': [] if self.users is None else [None if x is None else x.to_dict() for x in self.users],
            'selfie_required': self.selfie_required,
            'privacy_policy_url': self.privacy_policy_url
        }

    def __bytes__(self):
        return b''.join((
            b'Sm\x97\xcb',
            struct.pack('<I', (0 if self.selfie_required is None or self.selfie_required is False else 2) | (0 if self.privacy_policy_url is None or self.privacy_policy_url is False else 1)),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.required_types)),b''.join(bytes(x) for x in self.required_types),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.values)),b''.join(bytes(x) for x in self.values),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.errors)),b''.join(bytes(x) for x in self.errors),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.users)),b''.join(bytes(x) for x in self.users),
            b'' if self.privacy_policy_url is None or self.privacy_policy_url is False else (self.serialize_bytes(self.privacy_policy_url)),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _selfie_required = bool(flags & 2)
        reader.read_int()
        _required_types = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _required_types.append(_x)

        reader.read_int()
        _values = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _values.append(_x)

        reader.read_int()
        _errors = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _errors.append(_x)

        reader.read_int()
        _users = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _users.append(_x)

        if flags & 1:
            _privacy_policy_url = reader.tgread_string()
        else:
            _privacy_policy_url = None
        return cls(required_types=_required_types, values=_values, errors=_errors, users=_users, selfie_required=_selfie_required, privacy_policy_url=_privacy_policy_url)


class Authorizations(TLObject):
    CONSTRUCTOR_ID = 0x1250abde
    SUBCLASS_OF_ID = 0xbf5e0ff

    def __init__(self, authorizations):
        """
        :param List[TypeAuthorization] authorizations:

        Constructor for account.Authorizations: Instance of Authorizations.
        """
        self.authorizations = authorizations  # type: List[TypeAuthorization]

    def to_dict(self):
        return {
            '_': 'Authorizations',
            'authorizations': [] if self.authorizations is None else [None if x is None else x.to_dict() for x in self.authorizations]
        }

    def __bytes__(self):
        return b''.join((
            b'\xde\xabP\x12',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.authorizations)),b''.join(bytes(x) for x in self.authorizations),
        ))

    @classmethod
    def from_reader(cls, reader):
        reader.read_int()
        _authorizations = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _authorizations.append(_x)

        return cls(authorizations=_authorizations)


class NoPassword(TLObject):
    CONSTRUCTOR_ID = 0x5ea182f6
    SUBCLASS_OF_ID = 0x53a211a3

    def __init__(self, new_salt, new_secure_salt, secure_random, email_unconfirmed_pattern):
        """
        :param bytes new_salt:
        :param bytes new_secure_salt:
        :param bytes secure_random:
        :param str email_unconfirmed_pattern:

        Constructor for account.Password: Instance of either NoPassword, Password.
        """
        self.new_salt = new_salt  # type: bytes
        self.new_secure_salt = new_secure_salt  # type: bytes
        self.secure_random = secure_random  # type: bytes
        self.email_unconfirmed_pattern = email_unconfirmed_pattern  # type: str

    def to_dict(self):
        return {
            '_': 'NoPassword',
            'new_salt': self.new_salt,
            'new_secure_salt': self.new_secure_salt,
            'secure_random': self.secure_random,
            'email_unconfirmed_pattern': self.email_unconfirmed_pattern
        }

    def __bytes__(self):
        return b''.join((
            b'\xf6\x82\xa1^',
            self.serialize_bytes(self.new_salt),
            self.serialize_bytes(self.new_secure_salt),
            self.serialize_bytes(self.secure_random),
            self.serialize_bytes(self.email_unconfirmed_pattern),
        ))

    @classmethod
    def from_reader(cls, reader):
        _new_salt = reader.tgread_bytes()
        _new_secure_salt = reader.tgread_bytes()
        _secure_random = reader.tgread_bytes()
        _email_unconfirmed_pattern = reader.tgread_string()
        return cls(new_salt=_new_salt, new_secure_salt=_new_secure_salt, secure_random=_secure_random, email_unconfirmed_pattern=_email_unconfirmed_pattern)


class Password(TLObject):
    CONSTRUCTOR_ID = 0xca39b447
    SUBCLASS_OF_ID = 0x53a211a3

    def __init__(self, current_salt, new_salt, new_secure_salt, secure_random, hint, email_unconfirmed_pattern, has_recovery=None, has_secure_values=None):
        """
        :param bytes current_salt:
        :param bytes new_salt:
        :param bytes new_secure_salt:
        :param bytes secure_random:
        :param str hint:
        :param str email_unconfirmed_pattern:
        :param Optional[bool] has_recovery:
        :param Optional[bool] has_secure_values:

        Constructor for account.Password: Instance of either NoPassword, Password.
        """
        self.current_salt = current_salt  # type: bytes
        self.new_salt = new_salt  # type: bytes
        self.new_secure_salt = new_secure_salt  # type: bytes
        self.secure_random = secure_random  # type: bytes
        self.hint = hint  # type: str
        self.email_unconfirmed_pattern = email_unconfirmed_pattern  # type: str
        self.has_recovery = has_recovery  # type: Optional[bool]
        self.has_secure_values = has_secure_values  # type: Optional[bool]

    def to_dict(self):
        return {
            '_': 'Password',
            'current_salt': self.current_salt,
            'new_salt': self.new_salt,
            'new_secure_salt': self.new_secure_salt,
            'secure_random': self.secure_random,
            'hint': self.hint,
            'email_unconfirmed_pattern': self.email_unconfirmed_pattern,
            'has_recovery': self.has_recovery,
            'has_secure_values': self.has_secure_values
        }

    def __bytes__(self):
        return b''.join((
            b'G\xb49\xca',
            struct.pack('<I', (0 if self.has_recovery is None or self.has_recovery is False else 1) | (0 if self.has_secure_values is None or self.has_secure_values is False else 2)),
            self.serialize_bytes(self.current_salt),
            self.serialize_bytes(self.new_salt),
            self.serialize_bytes(self.new_secure_salt),
            self.serialize_bytes(self.secure_random),
            self.serialize_bytes(self.hint),
            self.serialize_bytes(self.email_unconfirmed_pattern),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _has_recovery = bool(flags & 1)
        _has_secure_values = bool(flags & 2)
        _current_salt = reader.tgread_bytes()
        _new_salt = reader.tgread_bytes()
        _new_secure_salt = reader.tgread_bytes()
        _secure_random = reader.tgread_bytes()
        _hint = reader.tgread_string()
        _email_unconfirmed_pattern = reader.tgread_string()
        return cls(current_salt=_current_salt, new_salt=_new_salt, new_secure_salt=_new_secure_salt, secure_random=_secure_random, hint=_hint, email_unconfirmed_pattern=_email_unconfirmed_pattern, has_recovery=_has_recovery, has_secure_values=_has_secure_values)


class PasswordInputSettings(TLObject):
    CONSTRUCTOR_ID = 0x21ffa60d
    SUBCLASS_OF_ID = 0xc426ca6

    def __init__(self, new_salt=None, new_password_hash=None, hint=None, email=None, new_secure_salt=None, new_secure_secret=None, new_secure_secret_id=None):
        """
        :param Optional[bytes] new_salt:
        :param Optional[bytes] new_password_hash:
        :param Optional[str] hint:
        :param Optional[str] email:
        :param Optional[bytes] new_secure_salt:
        :param Optional[bytes] new_secure_secret:
        :param Optional[int] new_secure_secret_id:

        Constructor for account.PasswordInputSettings: Instance of PasswordInputSettings.
        """
        self.new_salt = new_salt  # type: Optional[bytes]
        self.new_password_hash = new_password_hash  # type: Optional[bytes]
        self.hint = hint  # type: Optional[str]
        self.email = email  # type: Optional[str]
        self.new_secure_salt = new_secure_salt  # type: Optional[bytes]
        self.new_secure_secret = new_secure_secret  # type: Optional[bytes]
        self.new_secure_secret_id = new_secure_secret_id  # type: Optional[int]

    def to_dict(self):
        return {
            '_': 'PasswordInputSettings',
            'new_salt': self.new_salt,
            'new_password_hash': self.new_password_hash,
            'hint': self.hint,
            'email': self.email,
            'new_secure_salt': self.new_secure_salt,
            'new_secure_secret': self.new_secure_secret,
            'new_secure_secret_id': self.new_secure_secret_id
        }

    def __bytes__(self):
        assert ((self.new_salt or self.new_salt is not None) and (self.new_password_hash or self.new_password_hash is not None) and (self.hint or self.hint is not None)) or ((self.new_salt is None or self.new_salt is False) and (self.new_password_hash is None or self.new_password_hash is False) and (self.hint is None or self.hint is False)), 'new_salt, new_password_hash, hint parameters must all be False-y (like None) or all me True-y'
        assert ((self.new_secure_salt or self.new_secure_salt is not None) and (self.new_secure_secret or self.new_secure_secret is not None) and (self.new_secure_secret_id or self.new_secure_secret_id is not None)) or ((self.new_secure_salt is None or self.new_secure_salt is False) and (self.new_secure_secret is None or self.new_secure_secret is False) and (self.new_secure_secret_id is None or self.new_secure_secret_id is False)), 'new_secure_salt, new_secure_secret, new_secure_secret_id parameters must all be False-y (like None) or all me True-y'
        return b''.join((
            b'\r\xa6\xff!',
            struct.pack('<I', (0 if self.new_salt is None or self.new_salt is False else 1) | (0 if self.new_password_hash is None or self.new_password_hash is False else 1) | (0 if self.hint is None or self.hint is False else 1) | (0 if self.email is None or self.email is False else 2) | (0 if self.new_secure_salt is None or self.new_secure_salt is False else 4) | (0 if self.new_secure_secret is None or self.new_secure_secret is False else 4) | (0 if self.new_secure_secret_id is None or self.new_secure_secret_id is False else 4)),
            b'' if self.new_salt is None or self.new_salt is False else (self.serialize_bytes(self.new_salt)),
            b'' if self.new_password_hash is None or self.new_password_hash is False else (self.serialize_bytes(self.new_password_hash)),
            b'' if self.hint is None or self.hint is False else (self.serialize_bytes(self.hint)),
            b'' if self.email is None or self.email is False else (self.serialize_bytes(self.email)),
            b'' if self.new_secure_salt is None or self.new_secure_salt is False else (self.serialize_bytes(self.new_secure_salt)),
            b'' if self.new_secure_secret is None or self.new_secure_secret is False else (self.serialize_bytes(self.new_secure_secret)),
            b'' if self.new_secure_secret_id is None or self.new_secure_secret_id is False else (struct.pack('<q', self.new_secure_secret_id)),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        if flags & 1:
            _new_salt = reader.tgread_bytes()
        else:
            _new_salt = None
        if flags & 1:
            _new_password_hash = reader.tgread_bytes()
        else:
            _new_password_hash = None
        if flags & 1:
            _hint = reader.tgread_string()
        else:
            _hint = None
        if flags & 2:
            _email = reader.tgread_string()
        else:
            _email = None
        if flags & 4:
            _new_secure_salt = reader.tgread_bytes()
        else:
            _new_secure_salt = None
        if flags & 4:
            _new_secure_secret = reader.tgread_bytes()
        else:
            _new_secure_secret = None
        if flags & 4:
            _new_secure_secret_id = reader.read_long()
        else:
            _new_secure_secret_id = None
        return cls(new_salt=_new_salt, new_password_hash=_new_password_hash, hint=_hint, email=_email, new_secure_salt=_new_secure_salt, new_secure_secret=_new_secure_secret, new_secure_secret_id=_new_secure_secret_id)


class PasswordSettings(TLObject):
    CONSTRUCTOR_ID = 0x7bd9c3f1
    SUBCLASS_OF_ID = 0xd23fb078

    def __init__(self, email, secure_salt, secure_secret, secure_secret_id):
        """
        :param str email:
        :param bytes secure_salt:
        :param bytes secure_secret:
        :param int secure_secret_id:

        Constructor for account.PasswordSettings: Instance of PasswordSettings.
        """
        self.email = email  # type: str
        self.secure_salt = secure_salt  # type: bytes
        self.secure_secret = secure_secret  # type: bytes
        self.secure_secret_id = secure_secret_id  # type: int

    def to_dict(self):
        return {
            '_': 'PasswordSettings',
            'email': self.email,
            'secure_salt': self.secure_salt,
            'secure_secret': self.secure_secret,
            'secure_secret_id': self.secure_secret_id
        }

    def __bytes__(self):
        return b''.join((
            b'\xf1\xc3\xd9{',
            self.serialize_bytes(self.email),
            self.serialize_bytes(self.secure_salt),
            self.serialize_bytes(self.secure_secret),
            struct.pack('<q', self.secure_secret_id),
        ))

    @classmethod
    def from_reader(cls, reader):
        _email = reader.tgread_string()
        _secure_salt = reader.tgread_bytes()
        _secure_secret = reader.tgread_bytes()
        _secure_secret_id = reader.read_long()
        return cls(email=_email, secure_salt=_secure_salt, secure_secret=_secure_secret, secure_secret_id=_secure_secret_id)


class PrivacyRules(TLObject):
    CONSTRUCTOR_ID = 0x554abb6f
    SUBCLASS_OF_ID = 0xb55aba82

    def __init__(self, rules, users):
        """
        :param List[TypePrivacyRule] rules:
        :param List[TypeUser] users:

        Constructor for account.PrivacyRules: Instance of PrivacyRules.
        """
        self.rules = rules  # type: List[TypePrivacyRule]
        self.users = users  # type: List[TypeUser]

    def to_dict(self):
        return {
            '_': 'PrivacyRules',
            'rules': [] if self.rules is None else [None if x is None else x.to_dict() for x in self.rules],
            'users': [] if self.users is None else [None if x is None else x.to_dict() for x in self.users]
        }

    def __bytes__(self):
        return b''.join((
            b'o\xbbJU',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.rules)),b''.join(bytes(x) for x in self.rules),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.users)),b''.join(bytes(x) for x in self.users),
        ))

    @classmethod
    def from_reader(cls, reader):
        reader.read_int()
        _rules = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _rules.append(_x)

        reader.read_int()
        _users = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _users.append(_x)

        return cls(rules=_rules, users=_users)


class SentEmailCode(TLObject):
    CONSTRUCTOR_ID = 0x811f854f
    SUBCLASS_OF_ID = 0x69f3c06e

    def __init__(self, email_pattern, length):
        """
        :param str email_pattern:
        :param int length:

        Constructor for account.SentEmailCode: Instance of SentEmailCode.
        """
        self.email_pattern = email_pattern  # type: str
        self.length = length  # type: int

    def to_dict(self):
        return {
            '_': 'SentEmailCode',
            'email_pattern': self.email_pattern,
            'length': self.length
        }

    def __bytes__(self):
        return b''.join((
            b'O\x85\x1f\x81',
            self.serialize_bytes(self.email_pattern),
            struct.pack('<i', self.length),
        ))

    @classmethod
    def from_reader(cls, reader):
        _email_pattern = reader.tgread_string()
        _length = reader.read_int()
        return cls(email_pattern=_email_pattern, length=_length)


class Takeout(TLObject):
    CONSTRUCTOR_ID = 0x4dba4501
    SUBCLASS_OF_ID = 0x843ebe85

    def __init__(self, id):
        """
        :param int id:

        Constructor for account.Takeout: Instance of Takeout.
        """
        self.id = id  # type: int

    def to_dict(self):
        return {
            '_': 'Takeout',
            'id': self.id
        }

    def __bytes__(self):
        return b''.join((
            b'\x01E\xbaM',
            struct.pack('<q', self.id),
        ))

    @classmethod
    def from_reader(cls, reader):
        _id = reader.read_long()
        return cls(id=_id)


class TmpPassword(TLObject):
    CONSTRUCTOR_ID = 0xdb64fd34
    SUBCLASS_OF_ID = 0xb064992d

    def __init__(self, tmp_password, valid_until):
        """
        :param bytes tmp_password:
        :param int valid_until:

        Constructor for account.TmpPassword: Instance of TmpPassword.
        """
        self.tmp_password = tmp_password  # type: bytes
        self.valid_until = valid_until  # type: int

    def to_dict(self):
        return {
            '_': 'TmpPassword',
            'tmp_password': self.tmp_password,
            'valid_until': self.valid_until
        }

    def __bytes__(self):
        return b''.join((
            b'4\xfdd\xdb',
            self.serialize_bytes(self.tmp_password),
            struct.pack('<i', self.valid_until),
        ))

    @classmethod
    def from_reader(cls, reader):
        _tmp_password = reader.tgread_bytes()
        _valid_until = reader.read_int()
        return cls(tmp_password=_tmp_password, valid_until=_valid_until)


class WebAuthorizations(TLObject):
    CONSTRUCTOR_ID = 0xed56c9fc
    SUBCLASS_OF_ID = 0x9a365b32

    def __init__(self, authorizations, users):
        """
        :param List[TypeWebAuthorization] authorizations:
        :param List[TypeUser] users:

        Constructor for account.WebAuthorizations: Instance of WebAuthorizations.
        """
        self.authorizations = authorizations  # type: List[TypeWebAuthorization]
        self.users = users  # type: List[TypeUser]

    def to_dict(self):
        return {
            '_': 'WebAuthorizations',
            'authorizations': [] if self.authorizations is None else [None if x is None else x.to_dict() for x in self.authorizations],
            'users': [] if self.users is None else [None if x is None else x.to_dict() for x in self.users]
        }

    def __bytes__(self):
        return b''.join((
            b'\xfc\xc9V\xed',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.authorizations)),b''.join(bytes(x) for x in self.authorizations),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.users)),b''.join(bytes(x) for x in self.users),
        ))

    @classmethod
    def from_reader(cls, reader):
        reader.read_int()
        _authorizations = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _authorizations.append(_x)

        reader.read_int()
        _users = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _users.append(_x)

        return cls(authorizations=_authorizations, users=_users)

