"""File generated by TLObjects' generator. All changes will be ERASED"""
from ...tl.tlobject import TLRequest
from typing import Optional, List, Union, TYPE_CHECKING
import os
import struct
if TYPE_CHECKING:
    from ...tl.types import TypeInputPrivacyKey, TypeInputPeer, TypeSecureValueType, TypeInputPrivacyRule, TypeBool, TypeReportReason, TypeSecureValueHash, TypeInputPeerNotifySettings, TypeSecureCredentialsEncrypted, TypeInputSecureValue, TypeInputNotifyPeer, TypeAccountDaysTTL
    from ...tl.types.account import TypePasswordInputSettings



class AcceptAuthorizationRequest(TLRequest):
    CONSTRUCTOR_ID = 0xe7027c94
    SUBCLASS_OF_ID = 0xf5b399ac

    def __init__(self, bot_id, scope, public_key, value_hashes, credentials):
        """
        :param int bot_id:
        :param str scope:
        :param str public_key:
        :param List[TypeSecureValueHash] value_hashes:
        :param TypeSecureCredentialsEncrypted credentials:

        :returns Bool: This type has no constructors.
        """
        self.bot_id = bot_id  # type: int
        self.scope = scope  # type: str
        self.public_key = public_key  # type: str
        self.value_hashes = value_hashes  # type: List[TypeSecureValueHash]
        self.credentials = credentials  # type: TypeSecureCredentialsEncrypted

    def to_dict(self):
        return {
            '_': 'AcceptAuthorizationRequest',
            'bot_id': self.bot_id,
            'scope': self.scope,
            'public_key': self.public_key,
            'value_hashes': [] if self.value_hashes is None else [None if x is None else x.to_dict() for x in self.value_hashes],
            'credentials': None if self.credentials is None else self.credentials.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\x94|\x02\xe7',
            struct.pack('<i', self.bot_id),
            self.serialize_bytes(self.scope),
            self.serialize_bytes(self.public_key),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.value_hashes)),b''.join(bytes(x) for x in self.value_hashes),
            bytes(self.credentials),
        ))

    @classmethod
    def from_reader(cls, reader):
        _bot_id = reader.read_int()
        _scope = reader.tgread_string()
        _public_key = reader.tgread_string()
        reader.read_int()
        _value_hashes = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _value_hashes.append(_x)

        _credentials = reader.tgread_object()
        return cls(bot_id=_bot_id, scope=_scope, public_key=_public_key, value_hashes=_value_hashes, credentials=_credentials)


class ChangePhoneRequest(TLRequest):
    CONSTRUCTOR_ID = 0x70c32edb
    SUBCLASS_OF_ID = 0x2da17977

    def __init__(self, phone_number, phone_code_hash, phone_code):
        """
        :param str phone_number:
        :param str phone_code_hash:
        :param str phone_code:

        :returns User: Instance of either UserEmpty, User.
        """
        self.phone_number = phone_number  # type: str
        self.phone_code_hash = phone_code_hash  # type: str
        self.phone_code = phone_code  # type: str

    def to_dict(self):
        return {
            '_': 'ChangePhoneRequest',
            'phone_number': self.phone_number,
            'phone_code_hash': self.phone_code_hash,
            'phone_code': self.phone_code
        }

    def __bytes__(self):
        return b''.join((
            b'\xdb.\xc3p',
            self.serialize_bytes(self.phone_number),
            self.serialize_bytes(self.phone_code_hash),
            self.serialize_bytes(self.phone_code),
        ))

    @classmethod
    def from_reader(cls, reader):
        _phone_number = reader.tgread_string()
        _phone_code_hash = reader.tgread_string()
        _phone_code = reader.tgread_string()
        return cls(phone_number=_phone_number, phone_code_hash=_phone_code_hash, phone_code=_phone_code)


class CheckUsernameRequest(TLRequest):
    CONSTRUCTOR_ID = 0x2714d86c
    SUBCLASS_OF_ID = 0xf5b399ac

    def __init__(self, username):
        """
        :param str username:

        :returns Bool: This type has no constructors.
        """
        self.username = username  # type: str

    def to_dict(self):
        return {
            '_': 'CheckUsernameRequest',
            'username': self.username
        }

    def __bytes__(self):
        return b''.join((
            b"l\xd8\x14'",
            self.serialize_bytes(self.username),
        ))

    @classmethod
    def from_reader(cls, reader):
        _username = reader.tgread_string()
        return cls(username=_username)


class ConfirmPhoneRequest(TLRequest):
    CONSTRUCTOR_ID = 0x5f2178c3
    SUBCLASS_OF_ID = 0xf5b399ac

    def __init__(self, phone_code_hash, phone_code):
        """
        :param str phone_code_hash:
        :param str phone_code:

        :returns Bool: This type has no constructors.
        """
        self.phone_code_hash = phone_code_hash  # type: str
        self.phone_code = phone_code  # type: str

    def to_dict(self):
        return {
            '_': 'ConfirmPhoneRequest',
            'phone_code_hash': self.phone_code_hash,
            'phone_code': self.phone_code
        }

    def __bytes__(self):
        return b''.join((
            b'\xc3x!_',
            self.serialize_bytes(self.phone_code_hash),
            self.serialize_bytes(self.phone_code),
        ))

    @classmethod
    def from_reader(cls, reader):
        _phone_code_hash = reader.tgread_string()
        _phone_code = reader.tgread_string()
        return cls(phone_code_hash=_phone_code_hash, phone_code=_phone_code)


class DeleteAccountRequest(TLRequest):
    CONSTRUCTOR_ID = 0x418d4e0b
    SUBCLASS_OF_ID = 0xf5b399ac

    def __init__(self, reason):
        """
        :param str reason:

        :returns Bool: This type has no constructors.
        """
        self.reason = reason  # type: str

    def to_dict(self):
        return {
            '_': 'DeleteAccountRequest',
            'reason': self.reason
        }

    def __bytes__(self):
        return b''.join((
            b'\x0bN\x8dA',
            self.serialize_bytes(self.reason),
        ))

    @classmethod
    def from_reader(cls, reader):
        _reason = reader.tgread_string()
        return cls(reason=_reason)


class DeleteSecureValueRequest(TLRequest):
    CONSTRUCTOR_ID = 0xb880bc4b
    SUBCLASS_OF_ID = 0xf5b399ac

    def __init__(self, types):
        """
        :param List[TypeSecureValueType] types:

        :returns Bool: This type has no constructors.
        """
        self.types = types  # type: List[TypeSecureValueType]

    def to_dict(self):
        return {
            '_': 'DeleteSecureValueRequest',
            'types': [] if self.types is None else [None if x is None else x.to_dict() for x in self.types]
        }

    def __bytes__(self):
        return b''.join((
            b'K\xbc\x80\xb8',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.types)),b''.join(bytes(x) for x in self.types),
        ))

    @classmethod
    def from_reader(cls, reader):
        reader.read_int()
        _types = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _types.append(_x)

        return cls(types=_types)


class FinishTakeoutSessionRequest(TLRequest):
    CONSTRUCTOR_ID = 0x1d2652ee
    SUBCLASS_OF_ID = 0xf5b399ac

    def __init__(self, success=None):
        """
        :param Optional[bool] success:

        :returns Bool: This type has no constructors.
        """
        self.success = success  # type: Optional[bool]

    def to_dict(self):
        return {
            '_': 'FinishTakeoutSessionRequest',
            'success': self.success
        }

    def __bytes__(self):
        return b''.join((
            b'\xeeR&\x1d',
            struct.pack('<I', (0 if self.success is None or self.success is False else 1)),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _success = bool(flags & 1)
        return cls(success=_success)


class GetAccountTTLRequest(TLRequest):
    CONSTRUCTOR_ID = 0x8fc711d
    SUBCLASS_OF_ID = 0xbaa39d88

    def to_dict(self):
        return {
            '_': 'GetAccountTTLRequest'
        }

    def __bytes__(self):
        return b''.join((
            b'\x1dq\xfc\x08',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class GetAllSecureValuesRequest(TLRequest):
    CONSTRUCTOR_ID = 0xb288bc7d
    SUBCLASS_OF_ID = 0xe82e4121

    def to_dict(self):
        return {
            '_': 'GetAllSecureValuesRequest'
        }

    def __bytes__(self):
        return b''.join((
            b'}\xbc\x88\xb2',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class GetAuthorizationFormRequest(TLRequest):
    CONSTRUCTOR_ID = 0xb86ba8e1
    SUBCLASS_OF_ID = 0x78049a94

    def __init__(self, bot_id, scope, public_key):
        """
        :param int bot_id:
        :param str scope:
        :param str public_key:

        :returns account.AuthorizationForm: Instance of AuthorizationForm.
        """
        self.bot_id = bot_id  # type: int
        self.scope = scope  # type: str
        self.public_key = public_key  # type: str

    def to_dict(self):
        return {
            '_': 'GetAuthorizationFormRequest',
            'bot_id': self.bot_id,
            'scope': self.scope,
            'public_key': self.public_key
        }

    def __bytes__(self):
        return b''.join((
            b'\xe1\xa8k\xb8',
            struct.pack('<i', self.bot_id),
            self.serialize_bytes(self.scope),
            self.serialize_bytes(self.public_key),
        ))

    @classmethod
    def from_reader(cls, reader):
        _bot_id = reader.read_int()
        _scope = reader.tgread_string()
        _public_key = reader.tgread_string()
        return cls(bot_id=_bot_id, scope=_scope, public_key=_public_key)


class GetAuthorizationsRequest(TLRequest):
    CONSTRUCTOR_ID = 0xe320c158
    SUBCLASS_OF_ID = 0xbf5e0ff

    def to_dict(self):
        return {
            '_': 'GetAuthorizationsRequest'
        }

    def __bytes__(self):
        return b''.join((
            b'X\xc1 \xe3',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class GetNotifySettingsRequest(TLRequest):
    CONSTRUCTOR_ID = 0x12b3ad31
    SUBCLASS_OF_ID = 0xcf20c074

    def __init__(self, peer):
        """
        :param TypeInputNotifyPeer peer:

        :returns PeerNotifySettings: Instance of PeerNotifySettings.
        """
        self.peer = peer  # type: TypeInputNotifyPeer

    async def resolve(self, client, utils):
        self.peer = await client._get_input_notify(self.peer)

    def to_dict(self):
        return {
            '_': 'GetNotifySettingsRequest',
            'peer': None if self.peer is None else self.peer.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'1\xad\xb3\x12',
            bytes(self.peer),
        ))

    @classmethod
    def from_reader(cls, reader):
        _peer = reader.tgread_object()
        return cls(peer=_peer)


class GetPasswordRequest(TLRequest):
    CONSTRUCTOR_ID = 0x548a30f5
    SUBCLASS_OF_ID = 0x53a211a3

    def to_dict(self):
        return {
            '_': 'GetPasswordRequest'
        }

    def __bytes__(self):
        return b''.join((
            b'\xf50\x8aT',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class GetPasswordSettingsRequest(TLRequest):
    CONSTRUCTOR_ID = 0xbc8d11bb
    SUBCLASS_OF_ID = 0xd23fb078

    def __init__(self, current_password_hash):
        """
        :param bytes current_password_hash:

        :returns account.PasswordSettings: Instance of PasswordSettings.
        """
        self.current_password_hash = current_password_hash  # type: bytes

    def to_dict(self):
        return {
            '_': 'GetPasswordSettingsRequest',
            'current_password_hash': self.current_password_hash
        }

    def __bytes__(self):
        return b''.join((
            b'\xbb\x11\x8d\xbc',
            self.serialize_bytes(self.current_password_hash),
        ))

    @classmethod
    def from_reader(cls, reader):
        _current_password_hash = reader.tgread_bytes()
        return cls(current_password_hash=_current_password_hash)


class GetPrivacyRequest(TLRequest):
    CONSTRUCTOR_ID = 0xdadbc950
    SUBCLASS_OF_ID = 0xb55aba82

    def __init__(self, key):
        """
        :param TypeInputPrivacyKey key:

        :returns account.PrivacyRules: Instance of PrivacyRules.
        """
        self.key = key  # type: TypeInputPrivacyKey

    def to_dict(self):
        return {
            '_': 'GetPrivacyRequest',
            'key': None if self.key is None else self.key.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'P\xc9\xdb\xda',
            bytes(self.key),
        ))

    @classmethod
    def from_reader(cls, reader):
        _key = reader.tgread_object()
        return cls(key=_key)


class GetSecureValueRequest(TLRequest):
    CONSTRUCTOR_ID = 0x73665bc2
    SUBCLASS_OF_ID = 0xe82e4121

    def __init__(self, types):
        """
        :param List[TypeSecureValueType] types:

        :returns Vector<SecureValue>: This type has no constructors.
        """
        self.types = types  # type: List[TypeSecureValueType]

    def to_dict(self):
        return {
            '_': 'GetSecureValueRequest',
            'types': [] if self.types is None else [None if x is None else x.to_dict() for x in self.types]
        }

    def __bytes__(self):
        return b''.join((
            b'\xc2[fs',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.types)),b''.join(bytes(x) for x in self.types),
        ))

    @classmethod
    def from_reader(cls, reader):
        reader.read_int()
        _types = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _types.append(_x)

        return cls(types=_types)


class GetTmpPasswordRequest(TLRequest):
    CONSTRUCTOR_ID = 0x4a82327e
    SUBCLASS_OF_ID = 0xb064992d

    def __init__(self, password_hash, period):
        """
        :param bytes password_hash:
        :param int period:

        :returns account.TmpPassword: Instance of TmpPassword.
        """
        self.password_hash = password_hash  # type: bytes
        self.period = period  # type: int

    def to_dict(self):
        return {
            '_': 'GetTmpPasswordRequest',
            'password_hash': self.password_hash,
            'period': self.period
        }

    def __bytes__(self):
        return b''.join((
            b'~2\x82J',
            self.serialize_bytes(self.password_hash),
            struct.pack('<i', self.period),
        ))

    @classmethod
    def from_reader(cls, reader):
        _password_hash = reader.tgread_bytes()
        _period = reader.read_int()
        return cls(password_hash=_password_hash, period=_period)


class GetWallPapersRequest(TLRequest):
    CONSTRUCTOR_ID = 0xc04cfac2
    SUBCLASS_OF_ID = 0x8ec35283

    def to_dict(self):
        return {
            '_': 'GetWallPapersRequest'
        }

    def __bytes__(self):
        return b''.join((
            b'\xc2\xfaL\xc0',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class GetWebAuthorizationsRequest(TLRequest):
    CONSTRUCTOR_ID = 0x182e6d6f
    SUBCLASS_OF_ID = 0x9a365b32

    def to_dict(self):
        return {
            '_': 'GetWebAuthorizationsRequest'
        }

    def __bytes__(self):
        return b''.join((
            b'om.\x18',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class InitTakeoutSessionRequest(TLRequest):
    CONSTRUCTOR_ID = 0xf05b4804
    SUBCLASS_OF_ID = 0x843ebe85

    def __init__(self, contacts=None, message_users=None, message_chats=None, message_megagroups=None, message_channels=None, files=None, file_max_size=None):
        """
        :param Optional[bool] contacts:
        :param Optional[bool] message_users:
        :param Optional[bool] message_chats:
        :param Optional[bool] message_megagroups:
        :param Optional[bool] message_channels:
        :param Optional[bool] files:
        :param Optional[int] file_max_size:

        :returns account.Takeout: Instance of Takeout.
        """
        self.contacts = contacts  # type: Optional[bool]
        self.message_users = message_users  # type: Optional[bool]
        self.message_chats = message_chats  # type: Optional[bool]
        self.message_megagroups = message_megagroups  # type: Optional[bool]
        self.message_channels = message_channels  # type: Optional[bool]
        self.files = files  # type: Optional[bool]
        self.file_max_size = file_max_size  # type: Optional[int]

    def to_dict(self):
        return {
            '_': 'InitTakeoutSessionRequest',
            'contacts': self.contacts,
            'message_users': self.message_users,
            'message_chats': self.message_chats,
            'message_megagroups': self.message_megagroups,
            'message_channels': self.message_channels,
            'files': self.files,
            'file_max_size': self.file_max_size
        }

    def __bytes__(self):
        assert ((self.files or self.files is not None) and (self.file_max_size or self.file_max_size is not None)) or ((self.files is None or self.files is False) and (self.file_max_size is None or self.file_max_size is False)), 'files, file_max_size parameters must all be False-y (like None) or all me True-y'
        return b''.join((
            b'\x04H[\xf0',
            struct.pack('<I', (0 if self.contacts is None or self.contacts is False else 1) | (0 if self.message_users is None or self.message_users is False else 2) | (0 if self.message_chats is None or self.message_chats is False else 4) | (0 if self.message_megagroups is None or self.message_megagroups is False else 8) | (0 if self.message_channels is None or self.message_channels is False else 16) | (0 if self.files is None or self.files is False else 32) | (0 if self.file_max_size is None or self.file_max_size is False else 32)),
            b'' if self.file_max_size is None or self.file_max_size is False else (struct.pack('<i', self.file_max_size)),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _contacts = bool(flags & 1)
        _message_users = bool(flags & 2)
        _message_chats = bool(flags & 4)
        _message_megagroups = bool(flags & 8)
        _message_channels = bool(flags & 16)
        _files = bool(flags & 32)
        if flags & 32:
            _file_max_size = reader.read_int()
        else:
            _file_max_size = None
        return cls(contacts=_contacts, message_users=_message_users, message_chats=_message_chats, message_megagroups=_message_megagroups, message_channels=_message_channels, files=_files, file_max_size=_file_max_size)


class RegisterDeviceRequest(TLRequest):
    CONSTRUCTOR_ID = 0x5cbea590
    SUBCLASS_OF_ID = 0xf5b399ac

    def __init__(self, token_type, token, app_sandbox, secret, other_uids):
        """
        :param int token_type:
        :param str token:
        :param TypeBool app_sandbox:
        :param bytes secret:
        :param List[int] other_uids:

        :returns Bool: This type has no constructors.
        """
        self.token_type = token_type  # type: int
        self.token = token  # type: str
        self.app_sandbox = app_sandbox  # type: TypeBool
        self.secret = secret  # type: bytes
        self.other_uids = other_uids  # type: List[int]

    def to_dict(self):
        return {
            '_': 'RegisterDeviceRequest',
            'token_type': self.token_type,
            'token': self.token,
            'app_sandbox': self.app_sandbox,
            'secret': self.secret,
            'other_uids': [] if self.other_uids is None else self.other_uids[:]
        }

    def __bytes__(self):
        return b''.join((
            b'\x90\xa5\xbe\\',
            struct.pack('<i', self.token_type),
            self.serialize_bytes(self.token),
            b'\xb5ur\x99' if self.app_sandbox else b'7\x97y\xbc',
            self.serialize_bytes(self.secret),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.other_uids)),b''.join(struct.pack('<i', x) for x in self.other_uids),
        ))

    @classmethod
    def from_reader(cls, reader):
        _token_type = reader.read_int()
        _token = reader.tgread_string()
        _app_sandbox = reader.tgread_bool()
        _secret = reader.tgread_bytes()
        reader.read_int()
        _other_uids = []
        for _ in range(reader.read_int()):
            _x = reader.read_int()
            _other_uids.append(_x)

        return cls(token_type=_token_type, token=_token, app_sandbox=_app_sandbox, secret=_secret, other_uids=_other_uids)


class ReportPeerRequest(TLRequest):
    CONSTRUCTOR_ID = 0xae189d5f
    SUBCLASS_OF_ID = 0xf5b399ac

    def __init__(self, peer, reason):
        """
        :param TypeInputPeer peer:
        :param TypeReportReason reason:

        :returns Bool: This type has no constructors.
        """
        self.peer = peer  # type: TypeInputPeer
        self.reason = reason  # type: TypeReportReason

    async def resolve(self, client, utils):
        self.peer = utils.get_input_peer(await client.get_input_entity(self.peer))

    def to_dict(self):
        return {
            '_': 'ReportPeerRequest',
            'peer': None if self.peer is None else self.peer.to_dict(),
            'reason': None if self.reason is None else self.reason.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'_\x9d\x18\xae',
            bytes(self.peer),
            bytes(self.reason),
        ))

    @classmethod
    def from_reader(cls, reader):
        _peer = reader.tgread_object()
        _reason = reader.tgread_object()
        return cls(peer=_peer, reason=_reason)


class ResetAuthorizationRequest(TLRequest):
    CONSTRUCTOR_ID = 0xdf77f3bc
    SUBCLASS_OF_ID = 0xf5b399ac

    def __init__(self, hash):
        """
        :param int hash:

        :returns Bool: This type has no constructors.
        """
        self.hash = hash  # type: int

    def to_dict(self):
        return {
            '_': 'ResetAuthorizationRequest',
            'hash': self.hash
        }

    def __bytes__(self):
        return b''.join((
            b'\xbc\xf3w\xdf',
            struct.pack('<q', self.hash),
        ))

    @classmethod
    def from_reader(cls, reader):
        _hash = reader.read_long()
        return cls(hash=_hash)


class ResetNotifySettingsRequest(TLRequest):
    CONSTRUCTOR_ID = 0xdb7e1747
    SUBCLASS_OF_ID = 0xf5b399ac

    def to_dict(self):
        return {
            '_': 'ResetNotifySettingsRequest'
        }

    def __bytes__(self):
        return b''.join((
            b'G\x17~\xdb',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class ResetWebAuthorizationRequest(TLRequest):
    CONSTRUCTOR_ID = 0x2d01b9ef
    SUBCLASS_OF_ID = 0xf5b399ac

    def __init__(self, hash):
        """
        :param int hash:

        :returns Bool: This type has no constructors.
        """
        self.hash = hash  # type: int

    def to_dict(self):
        return {
            '_': 'ResetWebAuthorizationRequest',
            'hash': self.hash
        }

    def __bytes__(self):
        return b''.join((
            b'\xef\xb9\x01-',
            struct.pack('<q', self.hash),
        ))

    @classmethod
    def from_reader(cls, reader):
        _hash = reader.read_long()
        return cls(hash=_hash)


class ResetWebAuthorizationsRequest(TLRequest):
    CONSTRUCTOR_ID = 0x682d2594
    SUBCLASS_OF_ID = 0xf5b399ac

    def to_dict(self):
        return {
            '_': 'ResetWebAuthorizationsRequest'
        }

    def __bytes__(self):
        return b''.join((
            b'\x94%-h',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class SaveSecureValueRequest(TLRequest):
    CONSTRUCTOR_ID = 0x899fe31d
    SUBCLASS_OF_ID = 0x51138ae

    def __init__(self, value, secure_secret_id):
        """
        :param TypeInputSecureValue value:
        :param int secure_secret_id:

        :returns SecureValue: Instance of SecureValue.
        """
        self.value = value  # type: TypeInputSecureValue
        self.secure_secret_id = secure_secret_id  # type: int

    def to_dict(self):
        return {
            '_': 'SaveSecureValueRequest',
            'value': None if self.value is None else self.value.to_dict(),
            'secure_secret_id': self.secure_secret_id
        }

    def __bytes__(self):
        return b''.join((
            b'\x1d\xe3\x9f\x89',
            bytes(self.value),
            struct.pack('<q', self.secure_secret_id),
        ))

    @classmethod
    def from_reader(cls, reader):
        _value = reader.tgread_object()
        _secure_secret_id = reader.read_long()
        return cls(value=_value, secure_secret_id=_secure_secret_id)


class SendChangePhoneCodeRequest(TLRequest):
    CONSTRUCTOR_ID = 0x8e57deb
    SUBCLASS_OF_ID = 0x6ce87081

    def __init__(self, phone_number, allow_flashcall=None, current_number=None):
        """
        :param str phone_number:
        :param Optional[bool] allow_flashcall:
        :param Optional[TypeBool] current_number:

        :returns auth.SentCode: Instance of SentCode.
        """
        self.phone_number = phone_number  # type: str
        self.allow_flashcall = allow_flashcall  # type: Optional[bool]
        self.current_number = current_number  # type: Optional[TypeBool]

    def to_dict(self):
        return {
            '_': 'SendChangePhoneCodeRequest',
            'phone_number': self.phone_number,
            'allow_flashcall': self.allow_flashcall,
            'current_number': self.current_number
        }

    def __bytes__(self):
        assert ((self.allow_flashcall or self.allow_flashcall is not None) and (self.current_number or self.current_number is not None)) or ((self.allow_flashcall is None or self.allow_flashcall is False) and (self.current_number is None or self.current_number is False)), 'allow_flashcall, current_number parameters must all be False-y (like None) or all me True-y'
        return b''.join((
            b'\xeb}\xe5\x08',
            struct.pack('<I', (0 if self.allow_flashcall is None or self.allow_flashcall is False else 1) | (0 if self.current_number is None or self.current_number is False else 1)),
            self.serialize_bytes(self.phone_number),
            b'' if self.current_number is None or self.current_number is False else (b'\xb5ur\x99' if self.current_number else b'7\x97y\xbc'),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _allow_flashcall = bool(flags & 1)
        _phone_number = reader.tgread_string()
        if flags & 1:
            _current_number = reader.tgread_bool()
        else:
            _current_number = None
        return cls(phone_number=_phone_number, allow_flashcall=_allow_flashcall, current_number=_current_number)


class SendConfirmPhoneCodeRequest(TLRequest):
    CONSTRUCTOR_ID = 0x1516d7bd
    SUBCLASS_OF_ID = 0x6ce87081

    def __init__(self, hash, allow_flashcall=None, current_number=None):
        """
        :param str hash:
        :param Optional[bool] allow_flashcall:
        :param Optional[TypeBool] current_number:

        :returns auth.SentCode: Instance of SentCode.
        """
        self.hash = hash  # type: str
        self.allow_flashcall = allow_flashcall  # type: Optional[bool]
        self.current_number = current_number  # type: Optional[TypeBool]

    def to_dict(self):
        return {
            '_': 'SendConfirmPhoneCodeRequest',
            'hash': self.hash,
            'allow_flashcall': self.allow_flashcall,
            'current_number': self.current_number
        }

    def __bytes__(self):
        assert ((self.allow_flashcall or self.allow_flashcall is not None) and (self.current_number or self.current_number is not None)) or ((self.allow_flashcall is None or self.allow_flashcall is False) and (self.current_number is None or self.current_number is False)), 'allow_flashcall, current_number parameters must all be False-y (like None) or all me True-y'
        return b''.join((
            b'\xbd\xd7\x16\x15',
            struct.pack('<I', (0 if self.allow_flashcall is None or self.allow_flashcall is False else 1) | (0 if self.current_number is None or self.current_number is False else 1)),
            self.serialize_bytes(self.hash),
            b'' if self.current_number is None or self.current_number is False else (b'\xb5ur\x99' if self.current_number else b'7\x97y\xbc'),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _allow_flashcall = bool(flags & 1)
        _hash = reader.tgread_string()
        if flags & 1:
            _current_number = reader.tgread_bool()
        else:
            _current_number = None
        return cls(hash=_hash, allow_flashcall=_allow_flashcall, current_number=_current_number)


class SendVerifyEmailCodeRequest(TLRequest):
    CONSTRUCTOR_ID = 0x7011509f
    SUBCLASS_OF_ID = 0x69f3c06e

    def __init__(self, email):
        """
        :param str email:

        :returns account.SentEmailCode: Instance of SentEmailCode.
        """
        self.email = email  # type: str

    def to_dict(self):
        return {
            '_': 'SendVerifyEmailCodeRequest',
            'email': self.email
        }

    def __bytes__(self):
        return b''.join((
            b'\x9fP\x11p',
            self.serialize_bytes(self.email),
        ))

    @classmethod
    def from_reader(cls, reader):
        _email = reader.tgread_string()
        return cls(email=_email)


class SendVerifyPhoneCodeRequest(TLRequest):
    CONSTRUCTOR_ID = 0x823380b4
    SUBCLASS_OF_ID = 0x6ce87081

    def __init__(self, phone_number, allow_flashcall=None, current_number=None):
        """
        :param str phone_number:
        :param Optional[bool] allow_flashcall:
        :param Optional[TypeBool] current_number:

        :returns auth.SentCode: Instance of SentCode.
        """
        self.phone_number = phone_number  # type: str
        self.allow_flashcall = allow_flashcall  # type: Optional[bool]
        self.current_number = current_number  # type: Optional[TypeBool]

    def to_dict(self):
        return {
            '_': 'SendVerifyPhoneCodeRequest',
            'phone_number': self.phone_number,
            'allow_flashcall': self.allow_flashcall,
            'current_number': self.current_number
        }

    def __bytes__(self):
        assert ((self.allow_flashcall or self.allow_flashcall is not None) and (self.current_number or self.current_number is not None)) or ((self.allow_flashcall is None or self.allow_flashcall is False) and (self.current_number is None or self.current_number is False)), 'allow_flashcall, current_number parameters must all be False-y (like None) or all me True-y'
        return b''.join((
            b'\xb4\x803\x82',
            struct.pack('<I', (0 if self.allow_flashcall is None or self.allow_flashcall is False else 1) | (0 if self.current_number is None or self.current_number is False else 1)),
            self.serialize_bytes(self.phone_number),
            b'' if self.current_number is None or self.current_number is False else (b'\xb5ur\x99' if self.current_number else b'7\x97y\xbc'),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _allow_flashcall = bool(flags & 1)
        _phone_number = reader.tgread_string()
        if flags & 1:
            _current_number = reader.tgread_bool()
        else:
            _current_number = None
        return cls(phone_number=_phone_number, allow_flashcall=_allow_flashcall, current_number=_current_number)


class SetAccountTTLRequest(TLRequest):
    CONSTRUCTOR_ID = 0x2442485e
    SUBCLASS_OF_ID = 0xf5b399ac

    def __init__(self, ttl):
        """
        :param TypeAccountDaysTTL ttl:

        :returns Bool: This type has no constructors.
        """
        self.ttl = ttl  # type: TypeAccountDaysTTL

    def to_dict(self):
        return {
            '_': 'SetAccountTTLRequest',
            'ttl': None if self.ttl is None else self.ttl.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'^HB$',
            bytes(self.ttl),
        ))

    @classmethod
    def from_reader(cls, reader):
        _ttl = reader.tgread_object()
        return cls(ttl=_ttl)


class SetPrivacyRequest(TLRequest):
    CONSTRUCTOR_ID = 0xc9f81ce8
    SUBCLASS_OF_ID = 0xb55aba82

    def __init__(self, key, rules):
        """
        :param TypeInputPrivacyKey key:
        :param List[TypeInputPrivacyRule] rules:

        :returns account.PrivacyRules: Instance of PrivacyRules.
        """
        self.key = key  # type: TypeInputPrivacyKey
        self.rules = rules  # type: List[TypeInputPrivacyRule]

    def to_dict(self):
        return {
            '_': 'SetPrivacyRequest',
            'key': None if self.key is None else self.key.to_dict(),
            'rules': [] if self.rules is None else [None if x is None else x.to_dict() for x in self.rules]
        }

    def __bytes__(self):
        return b''.join((
            b'\xe8\x1c\xf8\xc9',
            bytes(self.key),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.rules)),b''.join(bytes(x) for x in self.rules),
        ))

    @classmethod
    def from_reader(cls, reader):
        _key = reader.tgread_object()
        reader.read_int()
        _rules = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _rules.append(_x)

        return cls(key=_key, rules=_rules)


class UnregisterDeviceRequest(TLRequest):
    CONSTRUCTOR_ID = 0x3076c4bf
    SUBCLASS_OF_ID = 0xf5b399ac

    def __init__(self, token_type, token, other_uids):
        """
        :param int token_type:
        :param str token:
        :param List[int] other_uids:

        :returns Bool: This type has no constructors.
        """
        self.token_type = token_type  # type: int
        self.token = token  # type: str
        self.other_uids = other_uids  # type: List[int]

    def to_dict(self):
        return {
            '_': 'UnregisterDeviceRequest',
            'token_type': self.token_type,
            'token': self.token,
            'other_uids': [] if self.other_uids is None else self.other_uids[:]
        }

    def __bytes__(self):
        return b''.join((
            b'\xbf\xc4v0',
            struct.pack('<i', self.token_type),
            self.serialize_bytes(self.token),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.other_uids)),b''.join(struct.pack('<i', x) for x in self.other_uids),
        ))

    @classmethod
    def from_reader(cls, reader):
        _token_type = reader.read_int()
        _token = reader.tgread_string()
        reader.read_int()
        _other_uids = []
        for _ in range(reader.read_int()):
            _x = reader.read_int()
            _other_uids.append(_x)

        return cls(token_type=_token_type, token=_token, other_uids=_other_uids)


class UpdateDeviceLockedRequest(TLRequest):
    CONSTRUCTOR_ID = 0x38df3532
    SUBCLASS_OF_ID = 0xf5b399ac

    def __init__(self, period):
        """
        :param int period:

        :returns Bool: This type has no constructors.
        """
        self.period = period  # type: int

    def to_dict(self):
        return {
            '_': 'UpdateDeviceLockedRequest',
            'period': self.period
        }

    def __bytes__(self):
        return b''.join((
            b'25\xdf8',
            struct.pack('<i', self.period),
        ))

    @classmethod
    def from_reader(cls, reader):
        _period = reader.read_int()
        return cls(period=_period)


class UpdateNotifySettingsRequest(TLRequest):
    CONSTRUCTOR_ID = 0x84be5b93
    SUBCLASS_OF_ID = 0xf5b399ac

    def __init__(self, peer, settings):
        """
        :param TypeInputNotifyPeer peer:
        :param TypeInputPeerNotifySettings settings:

        :returns Bool: This type has no constructors.
        """
        self.peer = peer  # type: TypeInputNotifyPeer
        self.settings = settings  # type: TypeInputPeerNotifySettings

    async def resolve(self, client, utils):
        self.peer = await client._get_input_notify(self.peer)

    def to_dict(self):
        return {
            '_': 'UpdateNotifySettingsRequest',
            'peer': None if self.peer is None else self.peer.to_dict(),
            'settings': None if self.settings is None else self.settings.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\x93[\xbe\x84',
            bytes(self.peer),
            bytes(self.settings),
        ))

    @classmethod
    def from_reader(cls, reader):
        _peer = reader.tgread_object()
        _settings = reader.tgread_object()
        return cls(peer=_peer, settings=_settings)


class UpdatePasswordSettingsRequest(TLRequest):
    CONSTRUCTOR_ID = 0xfa7c4b86
    SUBCLASS_OF_ID = 0xf5b399ac

    def __init__(self, current_password_hash, new_settings):
        """
        :param bytes current_password_hash:
        :param TypePasswordInputSettings new_settings:

        :returns Bool: This type has no constructors.
        """
        self.current_password_hash = current_password_hash  # type: bytes
        self.new_settings = new_settings  # type: TypePasswordInputSettings

    def to_dict(self):
        return {
            '_': 'UpdatePasswordSettingsRequest',
            'current_password_hash': self.current_password_hash,
            'new_settings': None if self.new_settings is None else self.new_settings.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\x86K|\xfa',
            self.serialize_bytes(self.current_password_hash),
            bytes(self.new_settings),
        ))

    @classmethod
    def from_reader(cls, reader):
        _current_password_hash = reader.tgread_bytes()
        _new_settings = reader.tgread_object()
        return cls(current_password_hash=_current_password_hash, new_settings=_new_settings)


class UpdateProfileRequest(TLRequest):
    CONSTRUCTOR_ID = 0x78515775
    SUBCLASS_OF_ID = 0x2da17977

    def __init__(self, first_name=None, last_name=None, about=None):
        """
        :param Optional[str] first_name:
        :param Optional[str] last_name:
        :param Optional[str] about:

        :returns User: Instance of either UserEmpty, User.
        """
        self.first_name = first_name  # type: Optional[str]
        self.last_name = last_name  # type: Optional[str]
        self.about = about  # type: Optional[str]

    def to_dict(self):
        return {
            '_': 'UpdateProfileRequest',
            'first_name': self.first_name,
            'last_name': self.last_name,
            'about': self.about
        }

    def __bytes__(self):
        return b''.join((
            b'uWQx',
            struct.pack('<I', (0 if self.first_name is None or self.first_name is False else 1) | (0 if self.last_name is None or self.last_name is False else 2) | (0 if self.about is None or self.about is False else 4)),
            b'' if self.first_name is None or self.first_name is False else (self.serialize_bytes(self.first_name)),
            b'' if self.last_name is None or self.last_name is False else (self.serialize_bytes(self.last_name)),
            b'' if self.about is None or self.about is False else (self.serialize_bytes(self.about)),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        if flags & 1:
            _first_name = reader.tgread_string()
        else:
            _first_name = None
        if flags & 2:
            _last_name = reader.tgread_string()
        else:
            _last_name = None
        if flags & 4:
            _about = reader.tgread_string()
        else:
            _about = None
        return cls(first_name=_first_name, last_name=_last_name, about=_about)


class UpdateStatusRequest(TLRequest):
    CONSTRUCTOR_ID = 0x6628562c
    SUBCLASS_OF_ID = 0xf5b399ac

    def __init__(self, offline):
        """
        :param TypeBool offline:

        :returns Bool: This type has no constructors.
        """
        self.offline = offline  # type: TypeBool

    def to_dict(self):
        return {
            '_': 'UpdateStatusRequest',
            'offline': self.offline
        }

    def __bytes__(self):
        return b''.join((
            b',V(f',
            b'\xb5ur\x99' if self.offline else b'7\x97y\xbc',
        ))

    @classmethod
    def from_reader(cls, reader):
        _offline = reader.tgread_bool()
        return cls(offline=_offline)


class UpdateUsernameRequest(TLRequest):
    CONSTRUCTOR_ID = 0x3e0bdd7c
    SUBCLASS_OF_ID = 0x2da17977

    def __init__(self, username):
        """
        :param str username:

        :returns User: Instance of either UserEmpty, User.
        """
        self.username = username  # type: str

    def to_dict(self):
        return {
            '_': 'UpdateUsernameRequest',
            'username': self.username
        }

    def __bytes__(self):
        return b''.join((
            b'|\xdd\x0b>',
            self.serialize_bytes(self.username),
        ))

    @classmethod
    def from_reader(cls, reader):
        _username = reader.tgread_string()
        return cls(username=_username)


class VerifyEmailRequest(TLRequest):
    CONSTRUCTOR_ID = 0xecba39db
    SUBCLASS_OF_ID = 0xf5b399ac

    def __init__(self, email, code):
        """
        :param str email:
        :param str code:

        :returns Bool: This type has no constructors.
        """
        self.email = email  # type: str
        self.code = code  # type: str

    def to_dict(self):
        return {
            '_': 'VerifyEmailRequest',
            'email': self.email,
            'code': self.code
        }

    def __bytes__(self):
        return b''.join((
            b'\xdb9\xba\xec',
            self.serialize_bytes(self.email),
            self.serialize_bytes(self.code),
        ))

    @classmethod
    def from_reader(cls, reader):
        _email = reader.tgread_string()
        _code = reader.tgread_string()
        return cls(email=_email, code=_code)


class VerifyPhoneRequest(TLRequest):
    CONSTRUCTOR_ID = 0x4dd3a7f6
    SUBCLASS_OF_ID = 0xf5b399ac

    def __init__(self, phone_number, phone_code_hash, phone_code):
        """
        :param str phone_number:
        :param str phone_code_hash:
        :param str phone_code:

        :returns Bool: This type has no constructors.
        """
        self.phone_number = phone_number  # type: str
        self.phone_code_hash = phone_code_hash  # type: str
        self.phone_code = phone_code  # type: str

    def to_dict(self):
        return {
            '_': 'VerifyPhoneRequest',
            'phone_number': self.phone_number,
            'phone_code_hash': self.phone_code_hash,
            'phone_code': self.phone_code
        }

    def __bytes__(self):
        return b''.join((
            b'\xf6\xa7\xd3M',
            self.serialize_bytes(self.phone_number),
            self.serialize_bytes(self.phone_code_hash),
            self.serialize_bytes(self.phone_code),
        ))

    @classmethod
    def from_reader(cls, reader):
        _phone_number = reader.tgread_string()
        _phone_code_hash = reader.tgread_string()
        _phone_code = reader.tgread_string()
        return cls(phone_number=_phone_number, phone_code_hash=_phone_code_hash, phone_code=_phone_code)

