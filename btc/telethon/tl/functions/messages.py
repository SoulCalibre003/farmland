"""File generated by TLObjects' generator. All changes will be ERASED"""
from ...tl.tlobject import TLRequest
from typing import Optional, List, Union, TYPE_CHECKING
import os
import struct
if TYPE_CHECKING:
    from ...tl.types import TypeInputEncryptedChat, TypeInlineBotSwitchPM, TypeInputStickeredMedia, TypeShippingOption, TypeInputPeer, TypeReportReason, TypeInputDialogPeer, TypeInputUser, TypeInputBotInlineMessageID, TypeSendMessageAction, TypeInputGeoPoint, TypeInputMedia, TypeInputDocument, TypeInputChatPhoto, TypeInputEncryptedFile, TypeInputSingleMedia, TypeBool, TypeInputStickerSet, TypeMessageEntity, TypeInputMessage, TypeMessagesFilter, TypeInputBotInlineResult, TypeReplyMarkup



class AcceptEncryptionRequest(TLRequest):
    CONSTRUCTOR_ID = 0x3dbc0415
    SUBCLASS_OF_ID = 0x6d28a37a

    def __init__(self, peer, g_b, key_fingerprint):
        """
        :param TypeInputEncryptedChat peer:
        :param bytes g_b:
        :param int key_fingerprint:

        :returns EncryptedChat: Instance of either EncryptedChatEmpty, EncryptedChatWaiting, EncryptedChatRequested, EncryptedChat, EncryptedChatDiscarded.
        """
        self.peer = peer  # type: TypeInputEncryptedChat
        self.g_b = g_b  # type: bytes
        self.key_fingerprint = key_fingerprint  # type: int

    def to_dict(self):
        return {
            '_': 'AcceptEncryptionRequest',
            'peer': None if self.peer is None else self.peer.to_dict(),
            'g_b': self.g_b,
            'key_fingerprint': self.key_fingerprint
        }

    def __bytes__(self):
        return b''.join((
            b'\x15\x04\xbc=',
            bytes(self.peer),
            self.serialize_bytes(self.g_b),
            struct.pack('<q', self.key_fingerprint),
        ))

    @classmethod
    def from_reader(cls, reader):
        _peer = reader.tgread_object()
        _g_b = reader.tgread_bytes()
        _key_fingerprint = reader.read_long()
        return cls(peer=_peer, g_b=_g_b, key_fingerprint=_key_fingerprint)


class AddChatUserRequest(TLRequest):
    CONSTRUCTOR_ID = 0xf9a0aa09
    SUBCLASS_OF_ID = 0x8af52aac

    def __init__(self, chat_id, user_id, fwd_limit):
        """
        :param int chat_id:
        :param TypeInputUser user_id:
        :param int fwd_limit:

        :returns Updates: Instance of either UpdatesTooLong, UpdateShortMessage, UpdateShortChatMessage, UpdateShort, UpdatesCombined, Updates, UpdateShortSentMessage.
        """
        self.chat_id = chat_id  # type: int
        self.user_id = user_id  # type: TypeInputUser
        self.fwd_limit = fwd_limit  # type: int

    async def resolve(self, client, utils):
        self.chat_id = await client.get_peer_id(self.chat_id, add_mark=False)
        self.user_id = utils.get_input_user(await client.get_input_entity(self.user_id))

    def to_dict(self):
        return {
            '_': 'AddChatUserRequest',
            'chat_id': self.chat_id,
            'user_id': None if self.user_id is None else self.user_id.to_dict(),
            'fwd_limit': self.fwd_limit
        }

    def __bytes__(self):
        return b''.join((
            b'\t\xaa\xa0\xf9',
            struct.pack('<i', self.chat_id),
            bytes(self.user_id),
            struct.pack('<i', self.fwd_limit),
        ))

    @classmethod
    def from_reader(cls, reader):
        _chat_id = reader.read_int()
        _user_id = reader.tgread_object()
        _fwd_limit = reader.read_int()
        return cls(chat_id=_chat_id, user_id=_user_id, fwd_limit=_fwd_limit)


class CheckChatInviteRequest(TLRequest):
    CONSTRUCTOR_ID = 0x3eadb1bb
    SUBCLASS_OF_ID = 0x4561736

    def __init__(self, hash):
        """
        :param str hash:

        :returns ChatInvite: Instance of either ChatInviteAlready, ChatInvite.
        """
        self.hash = hash  # type: str

    def to_dict(self):
        return {
            '_': 'CheckChatInviteRequest',
            'hash': self.hash
        }

    def __bytes__(self):
        return b''.join((
            b'\xbb\xb1\xad>',
            self.serialize_bytes(self.hash),
        ))

    @classmethod
    def from_reader(cls, reader):
        _hash = reader.tgread_string()
        return cls(hash=_hash)


class ClearRecentStickersRequest(TLRequest):
    CONSTRUCTOR_ID = 0x8999602d
    SUBCLASS_OF_ID = 0xf5b399ac

    def __init__(self, attached=None):
        """
        :param Optional[bool] attached:

        :returns Bool: This type has no constructors.
        """
        self.attached = attached  # type: Optional[bool]

    def to_dict(self):
        return {
            '_': 'ClearRecentStickersRequest',
            'attached': self.attached
        }

    def __bytes__(self):
        return b''.join((
            b'-`\x99\x89',
            struct.pack('<I', (0 if self.attached is None or self.attached is False else 1)),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _attached = bool(flags & 1)
        return cls(attached=_attached)


class CreateChatRequest(TLRequest):
    CONSTRUCTOR_ID = 0x9cb126e
    SUBCLASS_OF_ID = 0x8af52aac

    def __init__(self, users, title):
        """
        :param List[TypeInputUser] users:
        :param str title:

        :returns Updates: Instance of either UpdatesTooLong, UpdateShortMessage, UpdateShortChatMessage, UpdateShort, UpdatesCombined, Updates, UpdateShortSentMessage.
        """
        self.users = users  # type: List[TypeInputUser]
        self.title = title  # type: str

    async def resolve(self, client, utils):
        _tmp = []
        for _x in self.users:
            _tmp.append(utils.get_input_user(await client.get_input_entity(_x)))

        self.users = _tmp

    def to_dict(self):
        return {
            '_': 'CreateChatRequest',
            'users': [] if self.users is None else [None if x is None else x.to_dict() for x in self.users],
            'title': self.title
        }

    def __bytes__(self):
        return b''.join((
            b'n\x12\xcb\t',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.users)),b''.join(bytes(x) for x in self.users),
            self.serialize_bytes(self.title),
        ))

    @classmethod
    def from_reader(cls, reader):
        reader.read_int()
        _users = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _users.append(_x)

        _title = reader.tgread_string()
        return cls(users=_users, title=_title)


class DeleteChatUserRequest(TLRequest):
    CONSTRUCTOR_ID = 0xe0611f16
    SUBCLASS_OF_ID = 0x8af52aac

    def __init__(self, chat_id, user_id):
        """
        :param int chat_id:
        :param TypeInputUser user_id:

        :returns Updates: Instance of either UpdatesTooLong, UpdateShortMessage, UpdateShortChatMessage, UpdateShort, UpdatesCombined, Updates, UpdateShortSentMessage.
        """
        self.chat_id = chat_id  # type: int
        self.user_id = user_id  # type: TypeInputUser

    async def resolve(self, client, utils):
        self.chat_id = await client.get_peer_id(self.chat_id, add_mark=False)
        self.user_id = utils.get_input_user(await client.get_input_entity(self.user_id))

    def to_dict(self):
        return {
            '_': 'DeleteChatUserRequest',
            'chat_id': self.chat_id,
            'user_id': None if self.user_id is None else self.user_id.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\x16\x1fa\xe0',
            struct.pack('<i', self.chat_id),
            bytes(self.user_id),
        ))

    @classmethod
    def from_reader(cls, reader):
        _chat_id = reader.read_int()
        _user_id = reader.tgread_object()
        return cls(chat_id=_chat_id, user_id=_user_id)


class DeleteHistoryRequest(TLRequest):
    CONSTRUCTOR_ID = 0x1c015b09
    SUBCLASS_OF_ID = 0x2c49c116

    def __init__(self, peer, max_id, just_clear=None):
        """
        :param TypeInputPeer peer:
        :param int max_id:
        :param Optional[bool] just_clear:

        :returns messages.AffectedHistory: Instance of AffectedHistory.
        """
        self.peer = peer  # type: TypeInputPeer
        self.max_id = max_id  # type: int
        self.just_clear = just_clear  # type: Optional[bool]

    async def resolve(self, client, utils):
        self.peer = utils.get_input_peer(await client.get_input_entity(self.peer))

    def to_dict(self):
        return {
            '_': 'DeleteHistoryRequest',
            'peer': None if self.peer is None else self.peer.to_dict(),
            'max_id': self.max_id,
            'just_clear': self.just_clear
        }

    def __bytes__(self):
        return b''.join((
            b'\t[\x01\x1c',
            struct.pack('<I', (0 if self.just_clear is None or self.just_clear is False else 1)),
            bytes(self.peer),
            struct.pack('<i', self.max_id),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _just_clear = bool(flags & 1)
        _peer = reader.tgread_object()
        _max_id = reader.read_int()
        return cls(peer=_peer, max_id=_max_id, just_clear=_just_clear)


class DeleteMessagesRequest(TLRequest):
    CONSTRUCTOR_ID = 0xe58e95d2
    SUBCLASS_OF_ID = 0xced3c06e

    def __init__(self, id, revoke=None):
        """
        :param List[int] id:
        :param Optional[bool] revoke:

        :returns messages.AffectedMessages: Instance of AffectedMessages.
        """
        self.id = id  # type: List[int]
        self.revoke = revoke  # type: Optional[bool]

    def to_dict(self):
        return {
            '_': 'DeleteMessagesRequest',
            'id': [] if self.id is None else self.id[:],
            'revoke': self.revoke
        }

    def __bytes__(self):
        return b''.join((
            b'\xd2\x95\x8e\xe5',
            struct.pack('<I', (0 if self.revoke is None or self.revoke is False else 1)),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.id)),b''.join(struct.pack('<i', x) for x in self.id),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _revoke = bool(flags & 1)
        reader.read_int()
        _id = []
        for _ in range(reader.read_int()):
            _x = reader.read_int()
            _id.append(_x)

        return cls(id=_id, revoke=_revoke)


class DiscardEncryptionRequest(TLRequest):
    CONSTRUCTOR_ID = 0xedd923c5
    SUBCLASS_OF_ID = 0xf5b399ac

    def __init__(self, chat_id):
        """
        :param int chat_id:

        :returns Bool: This type has no constructors.
        """
        self.chat_id = chat_id  # type: int

    async def resolve(self, client, utils):
        self.chat_id = await client.get_peer_id(self.chat_id, add_mark=False)

    def to_dict(self):
        return {
            '_': 'DiscardEncryptionRequest',
            'chat_id': self.chat_id
        }

    def __bytes__(self):
        return b''.join((
            b'\xc5#\xd9\xed',
            struct.pack('<i', self.chat_id),
        ))

    @classmethod
    def from_reader(cls, reader):
        _chat_id = reader.read_int()
        return cls(chat_id=_chat_id)


class EditChatAdminRequest(TLRequest):
    CONSTRUCTOR_ID = 0xa9e69f2e
    SUBCLASS_OF_ID = 0xf5b399ac

    def __init__(self, chat_id, user_id, is_admin):
        """
        :param int chat_id:
        :param TypeInputUser user_id:
        :param TypeBool is_admin:

        :returns Bool: This type has no constructors.
        """
        self.chat_id = chat_id  # type: int
        self.user_id = user_id  # type: TypeInputUser
        self.is_admin = is_admin  # type: TypeBool

    async def resolve(self, client, utils):
        self.chat_id = await client.get_peer_id(self.chat_id, add_mark=False)
        self.user_id = utils.get_input_user(await client.get_input_entity(self.user_id))

    def to_dict(self):
        return {
            '_': 'EditChatAdminRequest',
            'chat_id': self.chat_id,
            'user_id': None if self.user_id is None else self.user_id.to_dict(),
            'is_admin': self.is_admin
        }

    def __bytes__(self):
        return b''.join((
            b'.\x9f\xe6\xa9',
            struct.pack('<i', self.chat_id),
            bytes(self.user_id),
            b'\xb5ur\x99' if self.is_admin else b'7\x97y\xbc',
        ))

    @classmethod
    def from_reader(cls, reader):
        _chat_id = reader.read_int()
        _user_id = reader.tgread_object()
        _is_admin = reader.tgread_bool()
        return cls(chat_id=_chat_id, user_id=_user_id, is_admin=_is_admin)


class EditChatPhotoRequest(TLRequest):
    CONSTRUCTOR_ID = 0xca4c79d8
    SUBCLASS_OF_ID = 0x8af52aac

    def __init__(self, chat_id, photo):
        """
        :param int chat_id:
        :param TypeInputChatPhoto photo:

        :returns Updates: Instance of either UpdatesTooLong, UpdateShortMessage, UpdateShortChatMessage, UpdateShort, UpdatesCombined, Updates, UpdateShortSentMessage.
        """
        self.chat_id = chat_id  # type: int
        self.photo = photo  # type: TypeInputChatPhoto

    async def resolve(self, client, utils):
        self.chat_id = await client.get_peer_id(self.chat_id, add_mark=False)

    def to_dict(self):
        return {
            '_': 'EditChatPhotoRequest',
            'chat_id': self.chat_id,
            'photo': None if self.photo is None else self.photo.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\xd8yL\xca',
            struct.pack('<i', self.chat_id),
            bytes(self.photo),
        ))

    @classmethod
    def from_reader(cls, reader):
        _chat_id = reader.read_int()
        _photo = reader.tgread_object()
        return cls(chat_id=_chat_id, photo=_photo)


class EditChatTitleRequest(TLRequest):
    CONSTRUCTOR_ID = 0xdc452855
    SUBCLASS_OF_ID = 0x8af52aac

    def __init__(self, chat_id, title):
        """
        :param int chat_id:
        :param str title:

        :returns Updates: Instance of either UpdatesTooLong, UpdateShortMessage, UpdateShortChatMessage, UpdateShort, UpdatesCombined, Updates, UpdateShortSentMessage.
        """
        self.chat_id = chat_id  # type: int
        self.title = title  # type: str

    async def resolve(self, client, utils):
        self.chat_id = await client.get_peer_id(self.chat_id, add_mark=False)

    def to_dict(self):
        return {
            '_': 'EditChatTitleRequest',
            'chat_id': self.chat_id,
            'title': self.title
        }

    def __bytes__(self):
        return b''.join((
            b'U(E\xdc',
            struct.pack('<i', self.chat_id),
            self.serialize_bytes(self.title),
        ))

    @classmethod
    def from_reader(cls, reader):
        _chat_id = reader.read_int()
        _title = reader.tgread_string()
        return cls(chat_id=_chat_id, title=_title)


class EditInlineBotMessageRequest(TLRequest):
    CONSTRUCTOR_ID = 0xadc3e828
    SUBCLASS_OF_ID = 0xf5b399ac

    def __init__(self, id, no_webpage=None, stop_geo_live=None, message=None, media=None, reply_markup=None, entities=None, geo_point=None):
        """
        :param TypeInputBotInlineMessageID id:
        :param Optional[bool] no_webpage:
        :param Optional[bool] stop_geo_live:
        :param Optional[str] message:
        :param Optional[TypeInputMedia] media:
        :param Optional[TypeReplyMarkup] reply_markup:
        :param Optional[List[TypeMessageEntity]] entities:
        :param Optional[TypeInputGeoPoint] geo_point:

        :returns Bool: This type has no constructors.
        """
        self.id = id  # type: TypeInputBotInlineMessageID
        self.no_webpage = no_webpage  # type: Optional[bool]
        self.stop_geo_live = stop_geo_live  # type: Optional[bool]
        self.message = message  # type: Optional[str]
        self.media = media  # type: Optional[TypeInputMedia]
        self.reply_markup = reply_markup  # type: Optional[TypeReplyMarkup]
        self.entities = entities  # type: Optional[List[TypeMessageEntity]]
        self.geo_point = geo_point  # type: Optional[TypeInputGeoPoint]

    async def resolve(self, client, utils):
        if self.media:
            self.media = utils.get_input_media(self.media)

    def to_dict(self):
        return {
            '_': 'EditInlineBotMessageRequest',
            'id': None if self.id is None else self.id.to_dict(),
            'no_webpage': self.no_webpage,
            'stop_geo_live': self.stop_geo_live,
            'message': self.message,
            'media': None if self.media is None else self.media.to_dict(),
            'reply_markup': None if self.reply_markup is None else self.reply_markup.to_dict(),
            'entities': [] if self.entities is None else [None if x is None else x.to_dict() for x in self.entities],
            'geo_point': None if self.geo_point is None else self.geo_point.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'(\xe8\xc3\xad',
            struct.pack('<I', (0 if self.no_webpage is None or self.no_webpage is False else 2) | (0 if self.stop_geo_live is None or self.stop_geo_live is False else 4096) | (0 if self.message is None or self.message is False else 2048) | (0 if self.media is None or self.media is False else 16384) | (0 if self.reply_markup is None or self.reply_markup is False else 4) | (0 if self.entities is None or self.entities is False else 8) | (0 if self.geo_point is None or self.geo_point is False else 8192)),
            bytes(self.id),
            b'' if self.message is None or self.message is False else (self.serialize_bytes(self.message)),
            b'' if self.media is None or self.media is False else (bytes(self.media)),
            b'' if self.reply_markup is None or self.reply_markup is False else (bytes(self.reply_markup)),
            b'' if self.entities is None or self.entities is False else b''.join((b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.entities)),b''.join(bytes(x) for x in self.entities))),
            b'' if self.geo_point is None or self.geo_point is False else (bytes(self.geo_point)),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _no_webpage = bool(flags & 2)
        _stop_geo_live = bool(flags & 4096)
        _id = reader.tgread_object()
        if flags & 2048:
            _message = reader.tgread_string()
        else:
            _message = None
        if flags & 16384:
            _media = reader.tgread_object()
        else:
            _media = None
        if flags & 4:
            _reply_markup = reader.tgread_object()
        else:
            _reply_markup = None
        if flags & 8:
            reader.read_int()
            _entities = []
            for _ in range(reader.read_int()):
                _x = reader.tgread_object()
                _entities.append(_x)

        else:
            _entities = None
        if flags & 8192:
            _geo_point = reader.tgread_object()
        else:
            _geo_point = None
        return cls(id=_id, no_webpage=_no_webpage, stop_geo_live=_stop_geo_live, message=_message, media=_media, reply_markup=_reply_markup, entities=_entities, geo_point=_geo_point)


class EditMessageRequest(TLRequest):
    CONSTRUCTOR_ID = 0xc000e4c8
    SUBCLASS_OF_ID = 0x8af52aac

    def __init__(self, peer, id, no_webpage=None, stop_geo_live=None, message=None, media=None, reply_markup=None, entities=None, geo_point=None):
        """
        :param TypeInputPeer peer:
        :param int id:
        :param Optional[bool] no_webpage:
        :param Optional[bool] stop_geo_live:
        :param Optional[str] message:
        :param Optional[TypeInputMedia] media:
        :param Optional[TypeReplyMarkup] reply_markup:
        :param Optional[List[TypeMessageEntity]] entities:
        :param Optional[TypeInputGeoPoint] geo_point:

        :returns Updates: Instance of either UpdatesTooLong, UpdateShortMessage, UpdateShortChatMessage, UpdateShort, UpdatesCombined, Updates, UpdateShortSentMessage.
        """
        self.peer = peer  # type: TypeInputPeer
        self.id = id  # type: int
        self.no_webpage = no_webpage  # type: Optional[bool]
        self.stop_geo_live = stop_geo_live  # type: Optional[bool]
        self.message = message  # type: Optional[str]
        self.media = media  # type: Optional[TypeInputMedia]
        self.reply_markup = reply_markup  # type: Optional[TypeReplyMarkup]
        self.entities = entities  # type: Optional[List[TypeMessageEntity]]
        self.geo_point = geo_point  # type: Optional[TypeInputGeoPoint]

    async def resolve(self, client, utils):
        self.peer = utils.get_input_peer(await client.get_input_entity(self.peer))
        if self.media:
            self.media = utils.get_input_media(self.media)

    def to_dict(self):
        return {
            '_': 'EditMessageRequest',
            'peer': None if self.peer is None else self.peer.to_dict(),
            'id': self.id,
            'no_webpage': self.no_webpage,
            'stop_geo_live': self.stop_geo_live,
            'message': self.message,
            'media': None if self.media is None else self.media.to_dict(),
            'reply_markup': None if self.reply_markup is None else self.reply_markup.to_dict(),
            'entities': [] if self.entities is None else [None if x is None else x.to_dict() for x in self.entities],
            'geo_point': None if self.geo_point is None else self.geo_point.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\xc8\xe4\x00\xc0',
            struct.pack('<I', (0 if self.no_webpage is None or self.no_webpage is False else 2) | (0 if self.stop_geo_live is None or self.stop_geo_live is False else 4096) | (0 if self.message is None or self.message is False else 2048) | (0 if self.media is None or self.media is False else 16384) | (0 if self.reply_markup is None or self.reply_markup is False else 4) | (0 if self.entities is None or self.entities is False else 8) | (0 if self.geo_point is None or self.geo_point is False else 8192)),
            bytes(self.peer),
            struct.pack('<i', self.id),
            b'' if self.message is None or self.message is False else (self.serialize_bytes(self.message)),
            b'' if self.media is None or self.media is False else (bytes(self.media)),
            b'' if self.reply_markup is None or self.reply_markup is False else (bytes(self.reply_markup)),
            b'' if self.entities is None or self.entities is False else b''.join((b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.entities)),b''.join(bytes(x) for x in self.entities))),
            b'' if self.geo_point is None or self.geo_point is False else (bytes(self.geo_point)),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _no_webpage = bool(flags & 2)
        _stop_geo_live = bool(flags & 4096)
        _peer = reader.tgread_object()
        _id = reader.read_int()
        if flags & 2048:
            _message = reader.tgread_string()
        else:
            _message = None
        if flags & 16384:
            _media = reader.tgread_object()
        else:
            _media = None
        if flags & 4:
            _reply_markup = reader.tgread_object()
        else:
            _reply_markup = None
        if flags & 8:
            reader.read_int()
            _entities = []
            for _ in range(reader.read_int()):
                _x = reader.tgread_object()
                _entities.append(_x)

        else:
            _entities = None
        if flags & 8192:
            _geo_point = reader.tgread_object()
        else:
            _geo_point = None
        return cls(peer=_peer, id=_id, no_webpage=_no_webpage, stop_geo_live=_stop_geo_live, message=_message, media=_media, reply_markup=_reply_markup, entities=_entities, geo_point=_geo_point)


class ExportChatInviteRequest(TLRequest):
    CONSTRUCTOR_ID = 0x7d885289
    SUBCLASS_OF_ID = 0xb4748a58

    def __init__(self, chat_id):
        """
        :param int chat_id:

        :returns ExportedChatInvite: Instance of either ChatInviteEmpty, ChatInviteExported.
        """
        self.chat_id = chat_id  # type: int

    async def resolve(self, client, utils):
        self.chat_id = await client.get_peer_id(self.chat_id, add_mark=False)

    def to_dict(self):
        return {
            '_': 'ExportChatInviteRequest',
            'chat_id': self.chat_id
        }

    def __bytes__(self):
        return b''.join((
            b'\x89R\x88}',
            struct.pack('<i', self.chat_id),
        ))

    @classmethod
    def from_reader(cls, reader):
        _chat_id = reader.read_int()
        return cls(chat_id=_chat_id)


class FaveStickerRequest(TLRequest):
    CONSTRUCTOR_ID = 0xb9ffc55b
    SUBCLASS_OF_ID = 0xf5b399ac

    def __init__(self, id, unfave):
        """
        :param TypeInputDocument id:
        :param TypeBool unfave:

        :returns Bool: This type has no constructors.
        """
        self.id = id  # type: TypeInputDocument
        self.unfave = unfave  # type: TypeBool

    def to_dict(self):
        return {
            '_': 'FaveStickerRequest',
            'id': None if self.id is None else self.id.to_dict(),
            'unfave': self.unfave
        }

    def __bytes__(self):
        return b''.join((
            b'[\xc5\xff\xb9',
            bytes(self.id),
            b'\xb5ur\x99' if self.unfave else b'7\x97y\xbc',
        ))

    @classmethod
    def from_reader(cls, reader):
        _id = reader.tgread_object()
        _unfave = reader.tgread_bool()
        return cls(id=_id, unfave=_unfave)


class ForwardMessagesRequest(TLRequest):
    CONSTRUCTOR_ID = 0x708e0195
    SUBCLASS_OF_ID = 0x8af52aac

    def __init__(self, from_peer, id, to_peer, silent=None, background=None, with_my_score=None, grouped=None, random_id=None):
        """
        :param TypeInputPeer from_peer:
        :param List[int] id:
        :param TypeInputPeer to_peer:
        :param Optional[bool] silent:
        :param Optional[bool] background:
        :param Optional[bool] with_my_score:
        :param Optional[bool] grouped:
        :param List[int] random_id:

        :returns Updates: Instance of either UpdatesTooLong, UpdateShortMessage, UpdateShortChatMessage, UpdateShort, UpdatesCombined, Updates, UpdateShortSentMessage.
        """
        self.from_peer = from_peer  # type: TypeInputPeer
        self.id = id  # type: List[int]
        self.to_peer = to_peer  # type: TypeInputPeer
        self.silent = silent  # type: Optional[bool]
        self.background = background  # type: Optional[bool]
        self.with_my_score = with_my_score  # type: Optional[bool]
        self.grouped = grouped  # type: Optional[bool]
        self.random_id = random_id if random_id is not None else [int.from_bytes(os.urandom(8), 'big', signed=True) for _ in range(len(id))]

    async def resolve(self, client, utils):
        self.from_peer = utils.get_input_peer(await client.get_input_entity(self.from_peer))
        self.to_peer = utils.get_input_peer(await client.get_input_entity(self.to_peer))

    def to_dict(self):
        return {
            '_': 'ForwardMessagesRequest',
            'from_peer': None if self.from_peer is None else self.from_peer.to_dict(),
            'id': [] if self.id is None else self.id[:],
            'to_peer': None if self.to_peer is None else self.to_peer.to_dict(),
            'silent': self.silent,
            'background': self.background,
            'with_my_score': self.with_my_score,
            'grouped': self.grouped,
            'random_id': [] if self.random_id is None else self.random_id[:]
        }

    def __bytes__(self):
        return b''.join((
            b'\x95\x01\x8ep',
            struct.pack('<I', (0 if self.silent is None or self.silent is False else 32) | (0 if self.background is None or self.background is False else 64) | (0 if self.with_my_score is None or self.with_my_score is False else 256) | (0 if self.grouped is None or self.grouped is False else 512)),
            bytes(self.from_peer),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.id)),b''.join(struct.pack('<i', x) for x in self.id),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.random_id)),b''.join(struct.pack('<q', x) for x in self.random_id),
            bytes(self.to_peer),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _silent = bool(flags & 32)
        _background = bool(flags & 64)
        _with_my_score = bool(flags & 256)
        _grouped = bool(flags & 512)
        _from_peer = reader.tgread_object()
        reader.read_int()
        _id = []
        for _ in range(reader.read_int()):
            _x = reader.read_int()
            _id.append(_x)

        reader.read_int()
        _random_id = []
        for _ in range(reader.read_int()):
            _x = reader.read_long()
            _random_id.append(_x)

        _to_peer = reader.tgread_object()
        return cls(from_peer=_from_peer, id=_id, to_peer=_to_peer, silent=_silent, background=_background, with_my_score=_with_my_score, grouped=_grouped, random_id=_random_id)


class GetAllChatsRequest(TLRequest):
    CONSTRUCTOR_ID = 0xeba80ff0
    SUBCLASS_OF_ID = 0x99d5cb14

    def __init__(self, except_ids):
        """
        :param List[int] except_ids:

        :returns messages.Chats: Instance of either Chats, ChatsSlice.
        """
        self.except_ids = except_ids  # type: List[int]

    def to_dict(self):
        return {
            '_': 'GetAllChatsRequest',
            'except_ids': [] if self.except_ids is None else self.except_ids[:]
        }

    def __bytes__(self):
        return b''.join((
            b'\xf0\x0f\xa8\xeb',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.except_ids)),b''.join(struct.pack('<i', x) for x in self.except_ids),
        ))

    @classmethod
    def from_reader(cls, reader):
        reader.read_int()
        _except_ids = []
        for _ in range(reader.read_int()):
            _x = reader.read_int()
            _except_ids.append(_x)

        return cls(except_ids=_except_ids)


class GetAllDraftsRequest(TLRequest):
    CONSTRUCTOR_ID = 0x6a3f8d65
    SUBCLASS_OF_ID = 0x8af52aac

    def to_dict(self):
        return {
            '_': 'GetAllDraftsRequest'
        }

    def __bytes__(self):
        return b''.join((
            b'e\x8d?j',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class GetAllStickersRequest(TLRequest):
    CONSTRUCTOR_ID = 0x1c9618b1
    SUBCLASS_OF_ID = 0x45834829

    def __init__(self, hash):
        """
        :param int hash:

        :returns messages.AllStickers: Instance of either AllStickersNotModified, AllStickers.
        """
        self.hash = hash  # type: int

    def to_dict(self):
        return {
            '_': 'GetAllStickersRequest',
            'hash': self.hash
        }

    def __bytes__(self):
        return b''.join((
            b'\xb1\x18\x96\x1c',
            struct.pack('<i', self.hash),
        ))

    @classmethod
    def from_reader(cls, reader):
        _hash = reader.read_int()
        return cls(hash=_hash)


class GetArchivedStickersRequest(TLRequest):
    CONSTRUCTOR_ID = 0x57f17692
    SUBCLASS_OF_ID = 0x7296d771

    def __init__(self, offset_id, limit, masks=None):
        """
        :param int offset_id:
        :param int limit:
        :param Optional[bool] masks:

        :returns messages.ArchivedStickers: Instance of ArchivedStickers.
        """
        self.offset_id = offset_id  # type: int
        self.limit = limit  # type: int
        self.masks = masks  # type: Optional[bool]

    def to_dict(self):
        return {
            '_': 'GetArchivedStickersRequest',
            'offset_id': self.offset_id,
            'limit': self.limit,
            'masks': self.masks
        }

    def __bytes__(self):
        return b''.join((
            b'\x92v\xf1W',
            struct.pack('<I', (0 if self.masks is None or self.masks is False else 1)),
            struct.pack('<q', self.offset_id),
            struct.pack('<i', self.limit),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _masks = bool(flags & 1)
        _offset_id = reader.read_long()
        _limit = reader.read_int()
        return cls(offset_id=_offset_id, limit=_limit, masks=_masks)


class GetAttachedStickersRequest(TLRequest):
    CONSTRUCTOR_ID = 0xcc5b67cc
    SUBCLASS_OF_ID = 0xcc125f6b

    def __init__(self, media):
        """
        :param TypeInputStickeredMedia media:

        :returns Vector<StickerSetCovered>: This type has no constructors.
        """
        self.media = media  # type: TypeInputStickeredMedia

    def to_dict(self):
        return {
            '_': 'GetAttachedStickersRequest',
            'media': None if self.media is None else self.media.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\xccg[\xcc',
            bytes(self.media),
        ))

    @classmethod
    def from_reader(cls, reader):
        _media = reader.tgread_object()
        return cls(media=_media)


class GetBotCallbackAnswerRequest(TLRequest):
    CONSTRUCTOR_ID = 0x810a9fec
    SUBCLASS_OF_ID = 0x6c4dd18c

    def __init__(self, peer, msg_id, game=None, data=None):
        """
        :param TypeInputPeer peer:
        :param int msg_id:
        :param Optional[bool] game:
        :param Optional[bytes] data:

        :returns messages.BotCallbackAnswer: Instance of BotCallbackAnswer.
        """
        self.peer = peer  # type: TypeInputPeer
        self.msg_id = msg_id  # type: int
        self.game = game  # type: Optional[bool]
        self.data = data  # type: Optional[bytes]

    async def resolve(self, client, utils):
        self.peer = utils.get_input_peer(await client.get_input_entity(self.peer))

    def to_dict(self):
        return {
            '_': 'GetBotCallbackAnswerRequest',
            'peer': None if self.peer is None else self.peer.to_dict(),
            'msg_id': self.msg_id,
            'game': self.game,
            'data': self.data
        }

    def __bytes__(self):
        return b''.join((
            b'\xec\x9f\n\x81',
            struct.pack('<I', (0 if self.game is None or self.game is False else 2) | (0 if self.data is None or self.data is False else 1)),
            bytes(self.peer),
            struct.pack('<i', self.msg_id),
            b'' if self.data is None or self.data is False else (self.serialize_bytes(self.data)),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _game = bool(flags & 2)
        _peer = reader.tgread_object()
        _msg_id = reader.read_int()
        if flags & 1:
            _data = reader.tgread_bytes()
        else:
            _data = None
        return cls(peer=_peer, msg_id=_msg_id, game=_game, data=_data)


class GetChatsRequest(TLRequest):
    CONSTRUCTOR_ID = 0x3c6aa187
    SUBCLASS_OF_ID = 0x99d5cb14

    def __init__(self, id):
        """
        :param List[int] id:

        :returns messages.Chats: Instance of either Chats, ChatsSlice.
        """
        self.id = id  # type: List[int]

    def to_dict(self):
        return {
            '_': 'GetChatsRequest',
            'id': [] if self.id is None else self.id[:]
        }

    def __bytes__(self):
        return b''.join((
            b'\x87\xa1j<',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.id)),b''.join(struct.pack('<i', x) for x in self.id),
        ))

    @classmethod
    def from_reader(cls, reader):
        reader.read_int()
        _id = []
        for _ in range(reader.read_int()):
            _x = reader.read_int()
            _id.append(_x)

        return cls(id=_id)


class GetCommonChatsRequest(TLRequest):
    CONSTRUCTOR_ID = 0xd0a48c4
    SUBCLASS_OF_ID = 0x99d5cb14

    def __init__(self, user_id, max_id, limit):
        """
        :param TypeInputUser user_id:
        :param int max_id:
        :param int limit:

        :returns messages.Chats: Instance of either Chats, ChatsSlice.
        """
        self.user_id = user_id  # type: TypeInputUser
        self.max_id = max_id  # type: int
        self.limit = limit  # type: int

    async def resolve(self, client, utils):
        self.user_id = utils.get_input_user(await client.get_input_entity(self.user_id))

    def to_dict(self):
        return {
            '_': 'GetCommonChatsRequest',
            'user_id': None if self.user_id is None else self.user_id.to_dict(),
            'max_id': self.max_id,
            'limit': self.limit
        }

    def __bytes__(self):
        return b''.join((
            b'\xc4H\n\r',
            bytes(self.user_id),
            struct.pack('<i', self.max_id),
            struct.pack('<i', self.limit),
        ))

    @classmethod
    def from_reader(cls, reader):
        _user_id = reader.tgread_object()
        _max_id = reader.read_int()
        _limit = reader.read_int()
        return cls(user_id=_user_id, max_id=_max_id, limit=_limit)


class GetDhConfigRequest(TLRequest):
    CONSTRUCTOR_ID = 0x26cf8950
    SUBCLASS_OF_ID = 0xe488ed8b

    def __init__(self, version, random_length):
        """
        :param int version:
        :param int random_length:

        :returns messages.DhConfig: Instance of either DhConfigNotModified, DhConfig.
        """
        self.version = version  # type: int
        self.random_length = random_length  # type: int

    def to_dict(self):
        return {
            '_': 'GetDhConfigRequest',
            'version': self.version,
            'random_length': self.random_length
        }

    def __bytes__(self):
        return b''.join((
            b'P\x89\xcf&',
            struct.pack('<i', self.version),
            struct.pack('<i', self.random_length),
        ))

    @classmethod
    def from_reader(cls, reader):
        _version = reader.read_int()
        _random_length = reader.read_int()
        return cls(version=_version, random_length=_random_length)


class GetDialogUnreadMarksRequest(TLRequest):
    CONSTRUCTOR_ID = 0x22e24e22
    SUBCLASS_OF_ID = 0xbec64ad9

    def to_dict(self):
        return {
            '_': 'GetDialogUnreadMarksRequest'
        }

    def __bytes__(self):
        return b''.join((
            b'"N\xe2"',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class GetDialogsRequest(TLRequest):
    CONSTRUCTOR_ID = 0xb098aee6
    SUBCLASS_OF_ID = 0xe1b52ee

    def __init__(self, offset_date, offset_id, offset_peer, limit, hash, exclude_pinned=None):
        """
        :param Optional[datetime] offset_date:
        :param int offset_id:
        :param TypeInputPeer offset_peer:
        :param int limit:
        :param int hash:
        :param Optional[bool] exclude_pinned:

        :returns messages.Dialogs: Instance of either Dialogs, DialogsSlice, DialogsNotModified.
        """
        self.offset_date = offset_date  # type: Optional[datetime]
        self.offset_id = offset_id  # type: int
        self.offset_peer = offset_peer  # type: TypeInputPeer
        self.limit = limit  # type: int
        self.hash = hash  # type: int
        self.exclude_pinned = exclude_pinned  # type: Optional[bool]

    async def resolve(self, client, utils):
        self.offset_peer = utils.get_input_peer(await client.get_input_entity(self.offset_peer))

    def to_dict(self):
        return {
            '_': 'GetDialogsRequest',
            'offset_date': self.offset_date,
            'offset_id': self.offset_id,
            'offset_peer': None if self.offset_peer is None else self.offset_peer.to_dict(),
            'limit': self.limit,
            'hash': self.hash,
            'exclude_pinned': self.exclude_pinned
        }

    def __bytes__(self):
        return b''.join((
            b'\xe6\xae\x98\xb0',
            struct.pack('<I', (0 if self.exclude_pinned is None or self.exclude_pinned is False else 1)),
            self.serialize_datetime(self.offset_date),
            struct.pack('<i', self.offset_id),
            bytes(self.offset_peer),
            struct.pack('<i', self.limit),
            struct.pack('<i', self.hash),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _exclude_pinned = bool(flags & 1)
        _offset_date = reader.tgread_date()
        _offset_id = reader.read_int()
        _offset_peer = reader.tgread_object()
        _limit = reader.read_int()
        _hash = reader.read_int()
        return cls(offset_date=_offset_date, offset_id=_offset_id, offset_peer=_offset_peer, limit=_limit, hash=_hash, exclude_pinned=_exclude_pinned)


class GetDocumentByHashRequest(TLRequest):
    CONSTRUCTOR_ID = 0x338e2464
    SUBCLASS_OF_ID = 0x211fe820

    def __init__(self, sha256, size, mime_type):
        """
        :param bytes sha256:
        :param int size:
        :param str mime_type:

        :returns Document: Instance of either DocumentEmpty, Document.
        """
        self.sha256 = sha256  # type: bytes
        self.size = size  # type: int
        self.mime_type = mime_type  # type: str

    def to_dict(self):
        return {
            '_': 'GetDocumentByHashRequest',
            'sha256': self.sha256,
            'size': self.size,
            'mime_type': self.mime_type
        }

    def __bytes__(self):
        return b''.join((
            b'd$\x8e3',
            self.serialize_bytes(self.sha256),
            struct.pack('<i', self.size),
            self.serialize_bytes(self.mime_type),
        ))

    @classmethod
    def from_reader(cls, reader):
        _sha256 = reader.tgread_bytes()
        _size = reader.read_int()
        _mime_type = reader.tgread_string()
        return cls(sha256=_sha256, size=_size, mime_type=_mime_type)


class GetFavedStickersRequest(TLRequest):
    CONSTRUCTOR_ID = 0x21ce0b0e
    SUBCLASS_OF_ID = 0x8e736fb9

    def __init__(self, hash):
        """
        :param int hash:

        :returns messages.FavedStickers: Instance of either FavedStickersNotModified, FavedStickers.
        """
        self.hash = hash  # type: int

    def to_dict(self):
        return {
            '_': 'GetFavedStickersRequest',
            'hash': self.hash
        }

    def __bytes__(self):
        return b''.join((
            b'\x0e\x0b\xce!',
            struct.pack('<i', self.hash),
        ))

    @classmethod
    def from_reader(cls, reader):
        _hash = reader.read_int()
        return cls(hash=_hash)


class GetFeaturedStickersRequest(TLRequest):
    CONSTRUCTOR_ID = 0x2dacca4f
    SUBCLASS_OF_ID = 0x2614b722

    def __init__(self, hash):
        """
        :param int hash:

        :returns messages.FeaturedStickers: Instance of either FeaturedStickersNotModified, FeaturedStickers.
        """
        self.hash = hash  # type: int

    def to_dict(self):
        return {
            '_': 'GetFeaturedStickersRequest',
            'hash': self.hash
        }

    def __bytes__(self):
        return b''.join((
            b'O\xca\xac-',
            struct.pack('<i', self.hash),
        ))

    @classmethod
    def from_reader(cls, reader):
        _hash = reader.read_int()
        return cls(hash=_hash)


class GetFullChatRequest(TLRequest):
    CONSTRUCTOR_ID = 0x3b831c66
    SUBCLASS_OF_ID = 0x225a5109

    def __init__(self, chat_id):
        """
        :param int chat_id:

        :returns messages.ChatFull: Instance of ChatFull.
        """
        self.chat_id = chat_id  # type: int

    async def resolve(self, client, utils):
        self.chat_id = await client.get_peer_id(self.chat_id, add_mark=False)

    def to_dict(self):
        return {
            '_': 'GetFullChatRequest',
            'chat_id': self.chat_id
        }

    def __bytes__(self):
        return b''.join((
            b'f\x1c\x83;',
            struct.pack('<i', self.chat_id),
        ))

    @classmethod
    def from_reader(cls, reader):
        _chat_id = reader.read_int()
        return cls(chat_id=_chat_id)


class GetGameHighScoresRequest(TLRequest):
    CONSTRUCTOR_ID = 0xe822649d
    SUBCLASS_OF_ID = 0x6ccd95fd

    def __init__(self, peer, id, user_id):
        """
        :param TypeInputPeer peer:
        :param int id:
        :param TypeInputUser user_id:

        :returns messages.HighScores: Instance of HighScores.
        """
        self.peer = peer  # type: TypeInputPeer
        self.id = id  # type: int
        self.user_id = user_id  # type: TypeInputUser

    async def resolve(self, client, utils):
        self.peer = utils.get_input_peer(await client.get_input_entity(self.peer))
        self.user_id = utils.get_input_user(await client.get_input_entity(self.user_id))

    def to_dict(self):
        return {
            '_': 'GetGameHighScoresRequest',
            'peer': None if self.peer is None else self.peer.to_dict(),
            'id': self.id,
            'user_id': None if self.user_id is None else self.user_id.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\x9dd"\xe8',
            bytes(self.peer),
            struct.pack('<i', self.id),
            bytes(self.user_id),
        ))

    @classmethod
    def from_reader(cls, reader):
        _peer = reader.tgread_object()
        _id = reader.read_int()
        _user_id = reader.tgread_object()
        return cls(peer=_peer, id=_id, user_id=_user_id)


class GetHistoryRequest(TLRequest):
    CONSTRUCTOR_ID = 0xdcbb8260
    SUBCLASS_OF_ID = 0xd4b40b5e

    def __init__(self, peer, offset_id, offset_date, add_offset, limit, max_id, min_id, hash):
        """
        :param TypeInputPeer peer:
        :param int offset_id:
        :param Optional[datetime] offset_date:
        :param int add_offset:
        :param int limit:
        :param int max_id:
        :param int min_id:
        :param int hash:

        :returns messages.Messages: Instance of either Messages, MessagesSlice, ChannelMessages, MessagesNotModified.
        """
        self.peer = peer  # type: TypeInputPeer
        self.offset_id = offset_id  # type: int
        self.offset_date = offset_date  # type: Optional[datetime]
        self.add_offset = add_offset  # type: int
        self.limit = limit  # type: int
        self.max_id = max_id  # type: int
        self.min_id = min_id  # type: int
        self.hash = hash  # type: int

    async def resolve(self, client, utils):
        self.peer = utils.get_input_peer(await client.get_input_entity(self.peer))

    def to_dict(self):
        return {
            '_': 'GetHistoryRequest',
            'peer': None if self.peer is None else self.peer.to_dict(),
            'offset_id': self.offset_id,
            'offset_date': self.offset_date,
            'add_offset': self.add_offset,
            'limit': self.limit,
            'max_id': self.max_id,
            'min_id': self.min_id,
            'hash': self.hash
        }

    def __bytes__(self):
        return b''.join((
            b'`\x82\xbb\xdc',
            bytes(self.peer),
            struct.pack('<i', self.offset_id),
            self.serialize_datetime(self.offset_date),
            struct.pack('<i', self.add_offset),
            struct.pack('<i', self.limit),
            struct.pack('<i', self.max_id),
            struct.pack('<i', self.min_id),
            struct.pack('<i', self.hash),
        ))

    @classmethod
    def from_reader(cls, reader):
        _peer = reader.tgread_object()
        _offset_id = reader.read_int()
        _offset_date = reader.tgread_date()
        _add_offset = reader.read_int()
        _limit = reader.read_int()
        _max_id = reader.read_int()
        _min_id = reader.read_int()
        _hash = reader.read_int()
        return cls(peer=_peer, offset_id=_offset_id, offset_date=_offset_date, add_offset=_add_offset, limit=_limit, max_id=_max_id, min_id=_min_id, hash=_hash)


class GetInlineBotResultsRequest(TLRequest):
    CONSTRUCTOR_ID = 0x514e999d
    SUBCLASS_OF_ID = 0x3ed4d9c9

    def __init__(self, bot, peer, query, offset, geo_point=None):
        """
        :param TypeInputUser bot:
        :param TypeInputPeer peer:
        :param str query:
        :param str offset:
        :param Optional[TypeInputGeoPoint] geo_point:

        :returns messages.BotResults: Instance of BotResults.
        """
        self.bot = bot  # type: TypeInputUser
        self.peer = peer  # type: TypeInputPeer
        self.query = query  # type: str
        self.offset = offset  # type: str
        self.geo_point = geo_point  # type: Optional[TypeInputGeoPoint]

    async def resolve(self, client, utils):
        self.bot = utils.get_input_user(await client.get_input_entity(self.bot))
        self.peer = utils.get_input_peer(await client.get_input_entity(self.peer))

    def to_dict(self):
        return {
            '_': 'GetInlineBotResultsRequest',
            'bot': None if self.bot is None else self.bot.to_dict(),
            'peer': None if self.peer is None else self.peer.to_dict(),
            'query': self.query,
            'offset': self.offset,
            'geo_point': None if self.geo_point is None else self.geo_point.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\x9d\x99NQ',
            struct.pack('<I', (0 if self.geo_point is None or self.geo_point is False else 1)),
            bytes(self.bot),
            bytes(self.peer),
            b'' if self.geo_point is None or self.geo_point is False else (bytes(self.geo_point)),
            self.serialize_bytes(self.query),
            self.serialize_bytes(self.offset),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _bot = reader.tgread_object()
        _peer = reader.tgread_object()
        if flags & 1:
            _geo_point = reader.tgread_object()
        else:
            _geo_point = None
        _query = reader.tgread_string()
        _offset = reader.tgread_string()
        return cls(bot=_bot, peer=_peer, query=_query, offset=_offset, geo_point=_geo_point)


class GetInlineGameHighScoresRequest(TLRequest):
    CONSTRUCTOR_ID = 0xf635e1b
    SUBCLASS_OF_ID = 0x6ccd95fd

    def __init__(self, id, user_id):
        """
        :param TypeInputBotInlineMessageID id:
        :param TypeInputUser user_id:

        :returns messages.HighScores: Instance of HighScores.
        """
        self.id = id  # type: TypeInputBotInlineMessageID
        self.user_id = user_id  # type: TypeInputUser

    async def resolve(self, client, utils):
        self.user_id = utils.get_input_user(await client.get_input_entity(self.user_id))

    def to_dict(self):
        return {
            '_': 'GetInlineGameHighScoresRequest',
            'id': None if self.id is None else self.id.to_dict(),
            'user_id': None if self.user_id is None else self.user_id.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\x1b^c\x0f',
            bytes(self.id),
            bytes(self.user_id),
        ))

    @classmethod
    def from_reader(cls, reader):
        _id = reader.tgread_object()
        _user_id = reader.tgread_object()
        return cls(id=_id, user_id=_user_id)


class GetMaskStickersRequest(TLRequest):
    CONSTRUCTOR_ID = 0x65b8c79f
    SUBCLASS_OF_ID = 0x45834829

    def __init__(self, hash):
        """
        :param int hash:

        :returns messages.AllStickers: Instance of either AllStickersNotModified, AllStickers.
        """
        self.hash = hash  # type: int

    def to_dict(self):
        return {
            '_': 'GetMaskStickersRequest',
            'hash': self.hash
        }

    def __bytes__(self):
        return b''.join((
            b'\x9f\xc7\xb8e',
            struct.pack('<i', self.hash),
        ))

    @classmethod
    def from_reader(cls, reader):
        _hash = reader.read_int()
        return cls(hash=_hash)


class GetMessageEditDataRequest(TLRequest):
    CONSTRUCTOR_ID = 0xfda68d36
    SUBCLASS_OF_ID = 0xfb47949d

    def __init__(self, peer, id):
        """
        :param TypeInputPeer peer:
        :param int id:

        :returns messages.MessageEditData: Instance of MessageEditData.
        """
        self.peer = peer  # type: TypeInputPeer
        self.id = id  # type: int

    async def resolve(self, client, utils):
        self.peer = utils.get_input_peer(await client.get_input_entity(self.peer))

    def to_dict(self):
        return {
            '_': 'GetMessageEditDataRequest',
            'peer': None if self.peer is None else self.peer.to_dict(),
            'id': self.id
        }

    def __bytes__(self):
        return b''.join((
            b'6\x8d\xa6\xfd',
            bytes(self.peer),
            struct.pack('<i', self.id),
        ))

    @classmethod
    def from_reader(cls, reader):
        _peer = reader.tgread_object()
        _id = reader.read_int()
        return cls(peer=_peer, id=_id)


class GetMessagesRequest(TLRequest):
    CONSTRUCTOR_ID = 0x63c66506
    SUBCLASS_OF_ID = 0xd4b40b5e

    def __init__(self, id):
        """
        :param List[TypeInputMessage] id:

        :returns messages.Messages: Instance of either Messages, MessagesSlice, ChannelMessages, MessagesNotModified.
        """
        self.id = id  # type: List[TypeInputMessage]

    async def resolve(self, client, utils):
        _tmp = []
        for _x in self.id:
            _tmp.append(utils.get_input_message(_x))

        self.id = _tmp

    def to_dict(self):
        return {
            '_': 'GetMessagesRequest',
            'id': [] if self.id is None else [None if x is None else x.to_dict() for x in self.id]
        }

    def __bytes__(self):
        return b''.join((
            b'\x06e\xc6c',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.id)),b''.join(bytes(x) for x in self.id),
        ))

    @classmethod
    def from_reader(cls, reader):
        reader.read_int()
        _id = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _id.append(_x)

        return cls(id=_id)


class GetMessagesViewsRequest(TLRequest):
    CONSTRUCTOR_ID = 0xc4c8a55d
    SUBCLASS_OF_ID = 0x5026710f

    def __init__(self, peer, id, increment):
        """
        :param TypeInputPeer peer:
        :param List[int] id:
        :param TypeBool increment:

        :returns Vector<int>: This type has no constructors.
        """
        self.peer = peer  # type: TypeInputPeer
        self.id = id  # type: List[int]
        self.increment = increment  # type: TypeBool

    async def resolve(self, client, utils):
        self.peer = utils.get_input_peer(await client.get_input_entity(self.peer))

    def to_dict(self):
        return {
            '_': 'GetMessagesViewsRequest',
            'peer': None if self.peer is None else self.peer.to_dict(),
            'id': [] if self.id is None else self.id[:],
            'increment': self.increment
        }

    def __bytes__(self):
        return b''.join((
            b']\xa5\xc8\xc4',
            bytes(self.peer),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.id)),b''.join(struct.pack('<i', x) for x in self.id),
            b'\xb5ur\x99' if self.increment else b'7\x97y\xbc',
        ))

    @classmethod
    def from_reader(cls, reader):
        _peer = reader.tgread_object()
        reader.read_int()
        _id = []
        for _ in range(reader.read_int()):
            _x = reader.read_int()
            _id.append(_x)

        _increment = reader.tgread_bool()
        return cls(peer=_peer, id=_id, increment=_increment)

    @staticmethod
    def read_result(reader):
        reader.read_int()  # Vector ID
        return [reader.read_int() for _ in range(reader.read_int())]


class GetPeerDialogsRequest(TLRequest):
    CONSTRUCTOR_ID = 0xe470bcfd
    SUBCLASS_OF_ID = 0x3ac70132

    def __init__(self, peers):
        """
        :param List[TypeInputDialogPeer] peers:

        :returns messages.PeerDialogs: Instance of PeerDialogs.
        """
        self.peers = peers  # type: List[TypeInputDialogPeer]

    async def resolve(self, client, utils):
        _tmp = []
        for _x in self.peers:
            _tmp.append(utils.get_input_dialog(await client.get_input_entity(_x)))

        self.peers = _tmp

    def to_dict(self):
        return {
            '_': 'GetPeerDialogsRequest',
            'peers': [] if self.peers is None else [None if x is None else x.to_dict() for x in self.peers]
        }

    def __bytes__(self):
        return b''.join((
            b'\xfd\xbcp\xe4',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.peers)),b''.join(bytes(x) for x in self.peers),
        ))

    @classmethod
    def from_reader(cls, reader):
        reader.read_int()
        _peers = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _peers.append(_x)

        return cls(peers=_peers)


class GetPeerSettingsRequest(TLRequest):
    CONSTRUCTOR_ID = 0x3672e09c
    SUBCLASS_OF_ID = 0xf6a79f84

    def __init__(self, peer):
        """
        :param TypeInputPeer peer:

        :returns PeerSettings: Instance of PeerSettings.
        """
        self.peer = peer  # type: TypeInputPeer

    async def resolve(self, client, utils):
        self.peer = utils.get_input_peer(await client.get_input_entity(self.peer))

    def to_dict(self):
        return {
            '_': 'GetPeerSettingsRequest',
            'peer': None if self.peer is None else self.peer.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\x9c\xe0r6',
            bytes(self.peer),
        ))

    @classmethod
    def from_reader(cls, reader):
        _peer = reader.tgread_object()
        return cls(peer=_peer)


class GetPinnedDialogsRequest(TLRequest):
    CONSTRUCTOR_ID = 0xe254d64e
    SUBCLASS_OF_ID = 0x3ac70132

    def to_dict(self):
        return {
            '_': 'GetPinnedDialogsRequest'
        }

    def __bytes__(self):
        return b''.join((
            b'N\xd6T\xe2',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class GetRecentLocationsRequest(TLRequest):
    CONSTRUCTOR_ID = 0xbbc45b09
    SUBCLASS_OF_ID = 0xd4b40b5e

    def __init__(self, peer, limit, hash):
        """
        :param TypeInputPeer peer:
        :param int limit:
        :param int hash:

        :returns messages.Messages: Instance of either Messages, MessagesSlice, ChannelMessages, MessagesNotModified.
        """
        self.peer = peer  # type: TypeInputPeer
        self.limit = limit  # type: int
        self.hash = hash  # type: int

    async def resolve(self, client, utils):
        self.peer = utils.get_input_peer(await client.get_input_entity(self.peer))

    def to_dict(self):
        return {
            '_': 'GetRecentLocationsRequest',
            'peer': None if self.peer is None else self.peer.to_dict(),
            'limit': self.limit,
            'hash': self.hash
        }

    def __bytes__(self):
        return b''.join((
            b'\t[\xc4\xbb',
            bytes(self.peer),
            struct.pack('<i', self.limit),
            struct.pack('<i', self.hash),
        ))

    @classmethod
    def from_reader(cls, reader):
        _peer = reader.tgread_object()
        _limit = reader.read_int()
        _hash = reader.read_int()
        return cls(peer=_peer, limit=_limit, hash=_hash)


class GetRecentStickersRequest(TLRequest):
    CONSTRUCTOR_ID = 0x5ea192c9
    SUBCLASS_OF_ID = 0xf76f8683

    def __init__(self, hash, attached=None):
        """
        :param int hash:
        :param Optional[bool] attached:

        :returns messages.RecentStickers: Instance of either RecentStickersNotModified, RecentStickers.
        """
        self.hash = hash  # type: int
        self.attached = attached  # type: Optional[bool]

    def to_dict(self):
        return {
            '_': 'GetRecentStickersRequest',
            'hash': self.hash,
            'attached': self.attached
        }

    def __bytes__(self):
        return b''.join((
            b'\xc9\x92\xa1^',
            struct.pack('<I', (0 if self.attached is None or self.attached is False else 1)),
            struct.pack('<i', self.hash),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _attached = bool(flags & 1)
        _hash = reader.read_int()
        return cls(hash=_hash, attached=_attached)


class GetSavedGifsRequest(TLRequest):
    CONSTRUCTOR_ID = 0x83bf3d52
    SUBCLASS_OF_ID = 0xa68b61f5

    def __init__(self, hash):
        """
        :param int hash:

        :returns messages.SavedGifs: Instance of either SavedGifsNotModified, SavedGifs.
        """
        self.hash = hash  # type: int

    def to_dict(self):
        return {
            '_': 'GetSavedGifsRequest',
            'hash': self.hash
        }

    def __bytes__(self):
        return b''.join((
            b'R=\xbf\x83',
            struct.pack('<i', self.hash),
        ))

    @classmethod
    def from_reader(cls, reader):
        _hash = reader.read_int()
        return cls(hash=_hash)


class GetSplitRangesRequest(TLRequest):
    CONSTRUCTOR_ID = 0x1cff7e08
    SUBCLASS_OF_ID = 0x5ba52504

    def to_dict(self):
        return {
            '_': 'GetSplitRangesRequest'
        }

    def __bytes__(self):
        return b''.join((
            b'\x08~\xff\x1c',
        ))

    @classmethod
    def from_reader(cls, reader):
        return cls()


class GetStickerSetRequest(TLRequest):
    CONSTRUCTOR_ID = 0x2619a90e
    SUBCLASS_OF_ID = 0x9b704a5a

    def __init__(self, stickerset):
        """
        :param TypeInputStickerSet stickerset:

        :returns messages.StickerSet: Instance of StickerSet.
        """
        self.stickerset = stickerset  # type: TypeInputStickerSet

    def to_dict(self):
        return {
            '_': 'GetStickerSetRequest',
            'stickerset': None if self.stickerset is None else self.stickerset.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\x0e\xa9\x19&',
            bytes(self.stickerset),
        ))

    @classmethod
    def from_reader(cls, reader):
        _stickerset = reader.tgread_object()
        return cls(stickerset=_stickerset)


class GetStickersRequest(TLRequest):
    CONSTRUCTOR_ID = 0x43d4f2c
    SUBCLASS_OF_ID = 0xd73bb9de

    def __init__(self, emoticon, hash):
        """
        :param str emoticon:
        :param int hash:

        :returns messages.Stickers: Instance of either StickersNotModified, Stickers.
        """
        self.emoticon = emoticon  # type: str
        self.hash = hash  # type: int

    def to_dict(self):
        return {
            '_': 'GetStickersRequest',
            'emoticon': self.emoticon,
            'hash': self.hash
        }

    def __bytes__(self):
        return b''.join((
            b',O=\x04',
            self.serialize_bytes(self.emoticon),
            struct.pack('<i', self.hash),
        ))

    @classmethod
    def from_reader(cls, reader):
        _emoticon = reader.tgread_string()
        _hash = reader.read_int()
        return cls(emoticon=_emoticon, hash=_hash)


class GetUnreadMentionsRequest(TLRequest):
    CONSTRUCTOR_ID = 0x46578472
    SUBCLASS_OF_ID = 0xd4b40b5e

    def __init__(self, peer, offset_id, add_offset, limit, max_id, min_id):
        """
        :param TypeInputPeer peer:
        :param int offset_id:
        :param int add_offset:
        :param int limit:
        :param int max_id:
        :param int min_id:

        :returns messages.Messages: Instance of either Messages, MessagesSlice, ChannelMessages, MessagesNotModified.
        """
        self.peer = peer  # type: TypeInputPeer
        self.offset_id = offset_id  # type: int
        self.add_offset = add_offset  # type: int
        self.limit = limit  # type: int
        self.max_id = max_id  # type: int
        self.min_id = min_id  # type: int

    async def resolve(self, client, utils):
        self.peer = utils.get_input_peer(await client.get_input_entity(self.peer))

    def to_dict(self):
        return {
            '_': 'GetUnreadMentionsRequest',
            'peer': None if self.peer is None else self.peer.to_dict(),
            'offset_id': self.offset_id,
            'add_offset': self.add_offset,
            'limit': self.limit,
            'max_id': self.max_id,
            'min_id': self.min_id
        }

    def __bytes__(self):
        return b''.join((
            b'r\x84WF',
            bytes(self.peer),
            struct.pack('<i', self.offset_id),
            struct.pack('<i', self.add_offset),
            struct.pack('<i', self.limit),
            struct.pack('<i', self.max_id),
            struct.pack('<i', self.min_id),
        ))

    @classmethod
    def from_reader(cls, reader):
        _peer = reader.tgread_object()
        _offset_id = reader.read_int()
        _add_offset = reader.read_int()
        _limit = reader.read_int()
        _max_id = reader.read_int()
        _min_id = reader.read_int()
        return cls(peer=_peer, offset_id=_offset_id, add_offset=_add_offset, limit=_limit, max_id=_max_id, min_id=_min_id)


class GetWebPageRequest(TLRequest):
    CONSTRUCTOR_ID = 0x32ca8f91
    SUBCLASS_OF_ID = 0x55a97481

    def __init__(self, url, hash):
        """
        :param str url:
        :param int hash:

        :returns WebPage: Instance of either WebPageEmpty, WebPagePending, WebPage, WebPageNotModified.
        """
        self.url = url  # type: str
        self.hash = hash  # type: int

    def to_dict(self):
        return {
            '_': 'GetWebPageRequest',
            'url': self.url,
            'hash': self.hash
        }

    def __bytes__(self):
        return b''.join((
            b'\x91\x8f\xca2',
            self.serialize_bytes(self.url),
            struct.pack('<i', self.hash),
        ))

    @classmethod
    def from_reader(cls, reader):
        _url = reader.tgread_string()
        _hash = reader.read_int()
        return cls(url=_url, hash=_hash)


class GetWebPagePreviewRequest(TLRequest):
    CONSTRUCTOR_ID = 0x8b68b0cc
    SUBCLASS_OF_ID = 0x476cbe32

    def __init__(self, message, entities=None):
        """
        :param str message:
        :param Optional[List[TypeMessageEntity]] entities:

        :returns MessageMedia: Instance of either MessageMediaEmpty, MessageMediaPhoto, MessageMediaGeo, MessageMediaContact, MessageMediaUnsupported, MessageMediaDocument, MessageMediaWebPage, MessageMediaVenue, MessageMediaGame, MessageMediaInvoice, MessageMediaGeoLive.
        """
        self.message = message  # type: str
        self.entities = entities  # type: Optional[List[TypeMessageEntity]]

    def to_dict(self):
        return {
            '_': 'GetWebPagePreviewRequest',
            'message': self.message,
            'entities': [] if self.entities is None else [None if x is None else x.to_dict() for x in self.entities]
        }

    def __bytes__(self):
        return b''.join((
            b'\xcc\xb0h\x8b',
            struct.pack('<I', (0 if self.entities is None or self.entities is False else 8)),
            self.serialize_bytes(self.message),
            b'' if self.entities is None or self.entities is False else b''.join((b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.entities)),b''.join(bytes(x) for x in self.entities))),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _message = reader.tgread_string()
        if flags & 8:
            reader.read_int()
            _entities = []
            for _ in range(reader.read_int()):
                _x = reader.tgread_object()
                _entities.append(_x)

        else:
            _entities = None
        return cls(message=_message, entities=_entities)


class HideReportSpamRequest(TLRequest):
    CONSTRUCTOR_ID = 0xa8f1709b
    SUBCLASS_OF_ID = 0xf5b399ac

    def __init__(self, peer):
        """
        :param TypeInputPeer peer:

        :returns Bool: This type has no constructors.
        """
        self.peer = peer  # type: TypeInputPeer

    async def resolve(self, client, utils):
        self.peer = utils.get_input_peer(await client.get_input_entity(self.peer))

    def to_dict(self):
        return {
            '_': 'HideReportSpamRequest',
            'peer': None if self.peer is None else self.peer.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\x9bp\xf1\xa8',
            bytes(self.peer),
        ))

    @classmethod
    def from_reader(cls, reader):
        _peer = reader.tgread_object()
        return cls(peer=_peer)


class ImportChatInviteRequest(TLRequest):
    CONSTRUCTOR_ID = 0x6c50051c
    SUBCLASS_OF_ID = 0x8af52aac

    def __init__(self, hash):
        """
        :param str hash:

        :returns Updates: Instance of either UpdatesTooLong, UpdateShortMessage, UpdateShortChatMessage, UpdateShort, UpdatesCombined, Updates, UpdateShortSentMessage.
        """
        self.hash = hash  # type: str

    def to_dict(self):
        return {
            '_': 'ImportChatInviteRequest',
            'hash': self.hash
        }

    def __bytes__(self):
        return b''.join((
            b'\x1c\x05Pl',
            self.serialize_bytes(self.hash),
        ))

    @classmethod
    def from_reader(cls, reader):
        _hash = reader.tgread_string()
        return cls(hash=_hash)


class InstallStickerSetRequest(TLRequest):
    CONSTRUCTOR_ID = 0xc78fe460
    SUBCLASS_OF_ID = 0x67cb3fe8

    def __init__(self, stickerset, archived):
        """
        :param TypeInputStickerSet stickerset:
        :param TypeBool archived:

        :returns messages.StickerSetInstallResult: Instance of either StickerSetInstallResultSuccess, StickerSetInstallResultArchive.
        """
        self.stickerset = stickerset  # type: TypeInputStickerSet
        self.archived = archived  # type: TypeBool

    def to_dict(self):
        return {
            '_': 'InstallStickerSetRequest',
            'stickerset': None if self.stickerset is None else self.stickerset.to_dict(),
            'archived': self.archived
        }

    def __bytes__(self):
        return b''.join((
            b'`\xe4\x8f\xc7',
            bytes(self.stickerset),
            b'\xb5ur\x99' if self.archived else b'7\x97y\xbc',
        ))

    @classmethod
    def from_reader(cls, reader):
        _stickerset = reader.tgread_object()
        _archived = reader.tgread_bool()
        return cls(stickerset=_stickerset, archived=_archived)


class MarkDialogUnreadRequest(TLRequest):
    CONSTRUCTOR_ID = 0xc286d98f
    SUBCLASS_OF_ID = 0xf5b399ac

    def __init__(self, peer, unread=None):
        """
        :param TypeInputDialogPeer peer:
        :param Optional[bool] unread:

        :returns Bool: This type has no constructors.
        """
        self.peer = peer  # type: TypeInputDialogPeer
        self.unread = unread  # type: Optional[bool]

    async def resolve(self, client, utils):
        self.peer = utils.get_input_dialog(await client.get_input_entity(self.peer))

    def to_dict(self):
        return {
            '_': 'MarkDialogUnreadRequest',
            'peer': None if self.peer is None else self.peer.to_dict(),
            'unread': self.unread
        }

    def __bytes__(self):
        return b''.join((
            b'\x8f\xd9\x86\xc2',
            struct.pack('<I', (0 if self.unread is None or self.unread is False else 1)),
            bytes(self.peer),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _unread = bool(flags & 1)
        _peer = reader.tgread_object()
        return cls(peer=_peer, unread=_unread)


class MigrateChatRequest(TLRequest):
    CONSTRUCTOR_ID = 0x15a3b8e3
    SUBCLASS_OF_ID = 0x8af52aac

    def __init__(self, chat_id):
        """
        :param int chat_id:

        :returns Updates: Instance of either UpdatesTooLong, UpdateShortMessage, UpdateShortChatMessage, UpdateShort, UpdatesCombined, Updates, UpdateShortSentMessage.
        """
        self.chat_id = chat_id  # type: int

    async def resolve(self, client, utils):
        self.chat_id = await client.get_peer_id(self.chat_id, add_mark=False)

    def to_dict(self):
        return {
            '_': 'MigrateChatRequest',
            'chat_id': self.chat_id
        }

    def __bytes__(self):
        return b''.join((
            b'\xe3\xb8\xa3\x15',
            struct.pack('<i', self.chat_id),
        ))

    @classmethod
    def from_reader(cls, reader):
        _chat_id = reader.read_int()
        return cls(chat_id=_chat_id)


class ReadEncryptedHistoryRequest(TLRequest):
    CONSTRUCTOR_ID = 0x7f4b690a
    SUBCLASS_OF_ID = 0xf5b399ac

    def __init__(self, peer, max_date):
        """
        :param TypeInputEncryptedChat peer:
        :param Optional[datetime] max_date:

        :returns Bool: This type has no constructors.
        """
        self.peer = peer  # type: TypeInputEncryptedChat
        self.max_date = max_date  # type: Optional[datetime]

    def to_dict(self):
        return {
            '_': 'ReadEncryptedHistoryRequest',
            'peer': None if self.peer is None else self.peer.to_dict(),
            'max_date': self.max_date
        }

    def __bytes__(self):
        return b''.join((
            b'\niK\x7f',
            bytes(self.peer),
            self.serialize_datetime(self.max_date),
        ))

    @classmethod
    def from_reader(cls, reader):
        _peer = reader.tgread_object()
        _max_date = reader.tgread_date()
        return cls(peer=_peer, max_date=_max_date)


class ReadFeaturedStickersRequest(TLRequest):
    CONSTRUCTOR_ID = 0x5b118126
    SUBCLASS_OF_ID = 0xf5b399ac

    def __init__(self, id):
        """
        :param List[int] id:

        :returns Bool: This type has no constructors.
        """
        self.id = id  # type: List[int]

    def to_dict(self):
        return {
            '_': 'ReadFeaturedStickersRequest',
            'id': [] if self.id is None else self.id[:]
        }

    def __bytes__(self):
        return b''.join((
            b'&\x81\x11[',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.id)),b''.join(struct.pack('<q', x) for x in self.id),
        ))

    @classmethod
    def from_reader(cls, reader):
        reader.read_int()
        _id = []
        for _ in range(reader.read_int()):
            _x = reader.read_long()
            _id.append(_x)

        return cls(id=_id)


class ReadHistoryRequest(TLRequest):
    CONSTRUCTOR_ID = 0xe306d3a
    SUBCLASS_OF_ID = 0xced3c06e

    def __init__(self, peer, max_id):
        """
        :param TypeInputPeer peer:
        :param int max_id:

        :returns messages.AffectedMessages: Instance of AffectedMessages.
        """
        self.peer = peer  # type: TypeInputPeer
        self.max_id = max_id  # type: int

    async def resolve(self, client, utils):
        self.peer = utils.get_input_peer(await client.get_input_entity(self.peer))

    def to_dict(self):
        return {
            '_': 'ReadHistoryRequest',
            'peer': None if self.peer is None else self.peer.to_dict(),
            'max_id': self.max_id
        }

    def __bytes__(self):
        return b''.join((
            b':m0\x0e',
            bytes(self.peer),
            struct.pack('<i', self.max_id),
        ))

    @classmethod
    def from_reader(cls, reader):
        _peer = reader.tgread_object()
        _max_id = reader.read_int()
        return cls(peer=_peer, max_id=_max_id)


class ReadMentionsRequest(TLRequest):
    CONSTRUCTOR_ID = 0xf0189d3
    SUBCLASS_OF_ID = 0x2c49c116

    def __init__(self, peer):
        """
        :param TypeInputPeer peer:

        :returns messages.AffectedHistory: Instance of AffectedHistory.
        """
        self.peer = peer  # type: TypeInputPeer

    async def resolve(self, client, utils):
        self.peer = utils.get_input_peer(await client.get_input_entity(self.peer))

    def to_dict(self):
        return {
            '_': 'ReadMentionsRequest',
            'peer': None if self.peer is None else self.peer.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\xd3\x89\x01\x0f',
            bytes(self.peer),
        ))

    @classmethod
    def from_reader(cls, reader):
        _peer = reader.tgread_object()
        return cls(peer=_peer)


class ReadMessageContentsRequest(TLRequest):
    CONSTRUCTOR_ID = 0x36a73f77
    SUBCLASS_OF_ID = 0xced3c06e

    def __init__(self, id):
        """
        :param List[int] id:

        :returns messages.AffectedMessages: Instance of AffectedMessages.
        """
        self.id = id  # type: List[int]

    def to_dict(self):
        return {
            '_': 'ReadMessageContentsRequest',
            'id': [] if self.id is None else self.id[:]
        }

    def __bytes__(self):
        return b''.join((
            b'w?\xa76',
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.id)),b''.join(struct.pack('<i', x) for x in self.id),
        ))

    @classmethod
    def from_reader(cls, reader):
        reader.read_int()
        _id = []
        for _ in range(reader.read_int()):
            _x = reader.read_int()
            _id.append(_x)

        return cls(id=_id)


class ReceivedMessagesRequest(TLRequest):
    CONSTRUCTOR_ID = 0x5a954c0
    SUBCLASS_OF_ID = 0x8565f897

    def __init__(self, max_id):
        """
        :param int max_id:

        :returns Vector<ReceivedNotifyMessage>: This type has no constructors.
        """
        self.max_id = max_id  # type: int

    def to_dict(self):
        return {
            '_': 'ReceivedMessagesRequest',
            'max_id': self.max_id
        }

    def __bytes__(self):
        return b''.join((
            b'\xc0T\xa9\x05',
            struct.pack('<i', self.max_id),
        ))

    @classmethod
    def from_reader(cls, reader):
        _max_id = reader.read_int()
        return cls(max_id=_max_id)


class ReceivedQueueRequest(TLRequest):
    CONSTRUCTOR_ID = 0x55a5bb66
    SUBCLASS_OF_ID = 0x8918e168

    def __init__(self, max_qts):
        """
        :param int max_qts:

        :returns Vector<long>: This type has no constructors.
        """
        self.max_qts = max_qts  # type: int

    def to_dict(self):
        return {
            '_': 'ReceivedQueueRequest',
            'max_qts': self.max_qts
        }

    def __bytes__(self):
        return b''.join((
            b'f\xbb\xa5U',
            struct.pack('<i', self.max_qts),
        ))

    @classmethod
    def from_reader(cls, reader):
        _max_qts = reader.read_int()
        return cls(max_qts=_max_qts)

    @staticmethod
    def read_result(reader):
        reader.read_int()  # Vector ID
        return [reader.read_long() for _ in range(reader.read_int())]


class ReorderPinnedDialogsRequest(TLRequest):
    CONSTRUCTOR_ID = 0x5b51d63f
    SUBCLASS_OF_ID = 0xf5b399ac

    def __init__(self, order, force=None):
        """
        :param List[TypeInputDialogPeer] order:
        :param Optional[bool] force:

        :returns Bool: This type has no constructors.
        """
        self.order = order  # type: List[TypeInputDialogPeer]
        self.force = force  # type: Optional[bool]

    async def resolve(self, client, utils):
        _tmp = []
        for _x in self.order:
            _tmp.append(utils.get_input_dialog(await client.get_input_entity(_x)))

        self.order = _tmp

    def to_dict(self):
        return {
            '_': 'ReorderPinnedDialogsRequest',
            'order': [] if self.order is None else [None if x is None else x.to_dict() for x in self.order],
            'force': self.force
        }

    def __bytes__(self):
        return b''.join((
            b'?\xd6Q[',
            struct.pack('<I', (0 if self.force is None or self.force is False else 1)),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.order)),b''.join(bytes(x) for x in self.order),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _force = bool(flags & 1)
        reader.read_int()
        _order = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _order.append(_x)

        return cls(order=_order, force=_force)


class ReorderStickerSetsRequest(TLRequest):
    CONSTRUCTOR_ID = 0x78337739
    SUBCLASS_OF_ID = 0xf5b399ac

    def __init__(self, order, masks=None):
        """
        :param List[int] order:
        :param Optional[bool] masks:

        :returns Bool: This type has no constructors.
        """
        self.order = order  # type: List[int]
        self.masks = masks  # type: Optional[bool]

    def to_dict(self):
        return {
            '_': 'ReorderStickerSetsRequest',
            'order': [] if self.order is None else self.order[:],
            'masks': self.masks
        }

    def __bytes__(self):
        return b''.join((
            b'9w3x',
            struct.pack('<I', (0 if self.masks is None or self.masks is False else 1)),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.order)),b''.join(struct.pack('<q', x) for x in self.order),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _masks = bool(flags & 1)
        reader.read_int()
        _order = []
        for _ in range(reader.read_int()):
            _x = reader.read_long()
            _order.append(_x)

        return cls(order=_order, masks=_masks)


class ReportRequest(TLRequest):
    CONSTRUCTOR_ID = 0xbd82b658
    SUBCLASS_OF_ID = 0xf5b399ac

    def __init__(self, peer, id, reason):
        """
        :param TypeInputPeer peer:
        :param List[int] id:
        :param TypeReportReason reason:

        :returns Bool: This type has no constructors.
        """
        self.peer = peer  # type: TypeInputPeer
        self.id = id  # type: List[int]
        self.reason = reason  # type: TypeReportReason

    async def resolve(self, client, utils):
        self.peer = utils.get_input_peer(await client.get_input_entity(self.peer))

    def to_dict(self):
        return {
            '_': 'ReportRequest',
            'peer': None if self.peer is None else self.peer.to_dict(),
            'id': [] if self.id is None else self.id[:],
            'reason': None if self.reason is None else self.reason.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'X\xb6\x82\xbd',
            bytes(self.peer),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.id)),b''.join(struct.pack('<i', x) for x in self.id),
            bytes(self.reason),
        ))

    @classmethod
    def from_reader(cls, reader):
        _peer = reader.tgread_object()
        reader.read_int()
        _id = []
        for _ in range(reader.read_int()):
            _x = reader.read_int()
            _id.append(_x)

        _reason = reader.tgread_object()
        return cls(peer=_peer, id=_id, reason=_reason)


class ReportEncryptedSpamRequest(TLRequest):
    CONSTRUCTOR_ID = 0x4b0c8c0f
    SUBCLASS_OF_ID = 0xf5b399ac

    def __init__(self, peer):
        """
        :param TypeInputEncryptedChat peer:

        :returns Bool: This type has no constructors.
        """
        self.peer = peer  # type: TypeInputEncryptedChat

    def to_dict(self):
        return {
            '_': 'ReportEncryptedSpamRequest',
            'peer': None if self.peer is None else self.peer.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\x0f\x8c\x0cK',
            bytes(self.peer),
        ))

    @classmethod
    def from_reader(cls, reader):
        _peer = reader.tgread_object()
        return cls(peer=_peer)


class ReportSpamRequest(TLRequest):
    CONSTRUCTOR_ID = 0xcf1592db
    SUBCLASS_OF_ID = 0xf5b399ac

    def __init__(self, peer):
        """
        :param TypeInputPeer peer:

        :returns Bool: This type has no constructors.
        """
        self.peer = peer  # type: TypeInputPeer

    async def resolve(self, client, utils):
        self.peer = utils.get_input_peer(await client.get_input_entity(self.peer))

    def to_dict(self):
        return {
            '_': 'ReportSpamRequest',
            'peer': None if self.peer is None else self.peer.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\xdb\x92\x15\xcf',
            bytes(self.peer),
        ))

    @classmethod
    def from_reader(cls, reader):
        _peer = reader.tgread_object()
        return cls(peer=_peer)


class RequestEncryptionRequest(TLRequest):
    CONSTRUCTOR_ID = 0xf64daf43
    SUBCLASS_OF_ID = 0x6d28a37a

    def __init__(self, user_id, g_a, random_id=None):
        """
        :param TypeInputUser user_id:
        :param bytes g_a:
        :param int random_id:

        :returns EncryptedChat: Instance of either EncryptedChatEmpty, EncryptedChatWaiting, EncryptedChatRequested, EncryptedChat, EncryptedChatDiscarded.
        """
        self.user_id = user_id  # type: TypeInputUser
        self.g_a = g_a  # type: bytes
        self.random_id = random_id if random_id is not None else int.from_bytes(os.urandom(4), 'big', signed=True)

    async def resolve(self, client, utils):
        self.user_id = utils.get_input_user(await client.get_input_entity(self.user_id))

    def to_dict(self):
        return {
            '_': 'RequestEncryptionRequest',
            'user_id': None if self.user_id is None else self.user_id.to_dict(),
            'g_a': self.g_a,
            'random_id': self.random_id
        }

    def __bytes__(self):
        return b''.join((
            b'C\xafM\xf6',
            bytes(self.user_id),
            struct.pack('<i', self.random_id),
            self.serialize_bytes(self.g_a),
        ))

    @classmethod
    def from_reader(cls, reader):
        _user_id = reader.tgread_object()
        _random_id = reader.read_int()
        _g_a = reader.tgread_bytes()
        return cls(user_id=_user_id, g_a=_g_a, random_id=_random_id)


class SaveDraftRequest(TLRequest):
    CONSTRUCTOR_ID = 0xbc39e14b
    SUBCLASS_OF_ID = 0xf5b399ac

    def __init__(self, peer, message, no_webpage=None, reply_to_msg_id=None, entities=None):
        """
        :param TypeInputPeer peer:
        :param str message:
        :param Optional[bool] no_webpage:
        :param Optional[int] reply_to_msg_id:
        :param Optional[List[TypeMessageEntity]] entities:

        :returns Bool: This type has no constructors.
        """
        self.peer = peer  # type: TypeInputPeer
        self.message = message  # type: str
        self.no_webpage = no_webpage  # type: Optional[bool]
        self.reply_to_msg_id = reply_to_msg_id  # type: Optional[int]
        self.entities = entities  # type: Optional[List[TypeMessageEntity]]

    async def resolve(self, client, utils):
        self.peer = utils.get_input_peer(await client.get_input_entity(self.peer))

    def to_dict(self):
        return {
            '_': 'SaveDraftRequest',
            'peer': None if self.peer is None else self.peer.to_dict(),
            'message': self.message,
            'no_webpage': self.no_webpage,
            'reply_to_msg_id': self.reply_to_msg_id,
            'entities': [] if self.entities is None else [None if x is None else x.to_dict() for x in self.entities]
        }

    def __bytes__(self):
        return b''.join((
            b'K\xe19\xbc',
            struct.pack('<I', (0 if self.no_webpage is None or self.no_webpage is False else 2) | (0 if self.reply_to_msg_id is None or self.reply_to_msg_id is False else 1) | (0 if self.entities is None or self.entities is False else 8)),
            b'' if self.reply_to_msg_id is None or self.reply_to_msg_id is False else (struct.pack('<i', self.reply_to_msg_id)),
            bytes(self.peer),
            self.serialize_bytes(self.message),
            b'' if self.entities is None or self.entities is False else b''.join((b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.entities)),b''.join(bytes(x) for x in self.entities))),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _no_webpage = bool(flags & 2)
        if flags & 1:
            _reply_to_msg_id = reader.read_int()
        else:
            _reply_to_msg_id = None
        _peer = reader.tgread_object()
        _message = reader.tgread_string()
        if flags & 8:
            reader.read_int()
            _entities = []
            for _ in range(reader.read_int()):
                _x = reader.tgread_object()
                _entities.append(_x)

        else:
            _entities = None
        return cls(peer=_peer, message=_message, no_webpage=_no_webpage, reply_to_msg_id=_reply_to_msg_id, entities=_entities)


class SaveGifRequest(TLRequest):
    CONSTRUCTOR_ID = 0x327a30cb
    SUBCLASS_OF_ID = 0xf5b399ac

    def __init__(self, id, unsave):
        """
        :param TypeInputDocument id:
        :param TypeBool unsave:

        :returns Bool: This type has no constructors.
        """
        self.id = id  # type: TypeInputDocument
        self.unsave = unsave  # type: TypeBool

    def to_dict(self):
        return {
            '_': 'SaveGifRequest',
            'id': None if self.id is None else self.id.to_dict(),
            'unsave': self.unsave
        }

    def __bytes__(self):
        return b''.join((
            b'\xcb0z2',
            bytes(self.id),
            b'\xb5ur\x99' if self.unsave else b'7\x97y\xbc',
        ))

    @classmethod
    def from_reader(cls, reader):
        _id = reader.tgread_object()
        _unsave = reader.tgread_bool()
        return cls(id=_id, unsave=_unsave)


class SaveRecentStickerRequest(TLRequest):
    CONSTRUCTOR_ID = 0x392718f8
    SUBCLASS_OF_ID = 0xf5b399ac

    def __init__(self, id, unsave, attached=None):
        """
        :param TypeInputDocument id:
        :param TypeBool unsave:
        :param Optional[bool] attached:

        :returns Bool: This type has no constructors.
        """
        self.id = id  # type: TypeInputDocument
        self.unsave = unsave  # type: TypeBool
        self.attached = attached  # type: Optional[bool]

    def to_dict(self):
        return {
            '_': 'SaveRecentStickerRequest',
            'id': None if self.id is None else self.id.to_dict(),
            'unsave': self.unsave,
            'attached': self.attached
        }

    def __bytes__(self):
        return b''.join((
            b"\xf8\x18'9",
            struct.pack('<I', (0 if self.attached is None or self.attached is False else 1)),
            bytes(self.id),
            b'\xb5ur\x99' if self.unsave else b'7\x97y\xbc',
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _attached = bool(flags & 1)
        _id = reader.tgread_object()
        _unsave = reader.tgread_bool()
        return cls(id=_id, unsave=_unsave, attached=_attached)


class SearchRequest(TLRequest):
    CONSTRUCTOR_ID = 0x8614ef68
    SUBCLASS_OF_ID = 0xd4b40b5e

    def __init__(self, peer, q, filter, min_date, max_date, offset_id, add_offset, limit, max_id, min_id, hash, from_id=None):
        """
        :param TypeInputPeer peer:
        :param str q:
        :param TypeMessagesFilter filter:
        :param Optional[datetime] min_date:
        :param Optional[datetime] max_date:
        :param int offset_id:
        :param int add_offset:
        :param int limit:
        :param int max_id:
        :param int min_id:
        :param int hash:
        :param Optional[TypeInputUser] from_id:

        :returns messages.Messages: Instance of either Messages, MessagesSlice, ChannelMessages, MessagesNotModified.
        """
        self.peer = peer  # type: TypeInputPeer
        self.q = q  # type: str
        self.filter = filter  # type: TypeMessagesFilter
        self.min_date = min_date  # type: Optional[datetime]
        self.max_date = max_date  # type: Optional[datetime]
        self.offset_id = offset_id  # type: int
        self.add_offset = add_offset  # type: int
        self.limit = limit  # type: int
        self.max_id = max_id  # type: int
        self.min_id = min_id  # type: int
        self.hash = hash  # type: int
        self.from_id = from_id  # type: Optional[TypeInputUser]

    async def resolve(self, client, utils):
        self.peer = utils.get_input_peer(await client.get_input_entity(self.peer))
        if self.from_id:
            self.from_id = utils.get_input_user(await client.get_input_entity(self.from_id))

    def to_dict(self):
        return {
            '_': 'SearchRequest',
            'peer': None if self.peer is None else self.peer.to_dict(),
            'q': self.q,
            'filter': None if self.filter is None else self.filter.to_dict(),
            'min_date': self.min_date,
            'max_date': self.max_date,
            'offset_id': self.offset_id,
            'add_offset': self.add_offset,
            'limit': self.limit,
            'max_id': self.max_id,
            'min_id': self.min_id,
            'hash': self.hash,
            'from_id': None if self.from_id is None else self.from_id.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'h\xef\x14\x86',
            struct.pack('<I', (0 if self.from_id is None or self.from_id is False else 1)),
            bytes(self.peer),
            self.serialize_bytes(self.q),
            b'' if self.from_id is None or self.from_id is False else (bytes(self.from_id)),
            bytes(self.filter),
            self.serialize_datetime(self.min_date),
            self.serialize_datetime(self.max_date),
            struct.pack('<i', self.offset_id),
            struct.pack('<i', self.add_offset),
            struct.pack('<i', self.limit),
            struct.pack('<i', self.max_id),
            struct.pack('<i', self.min_id),
            struct.pack('<i', self.hash),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _peer = reader.tgread_object()
        _q = reader.tgread_string()
        if flags & 1:
            _from_id = reader.tgread_object()
        else:
            _from_id = None
        _filter = reader.tgread_object()
        _min_date = reader.tgread_date()
        _max_date = reader.tgread_date()
        _offset_id = reader.read_int()
        _add_offset = reader.read_int()
        _limit = reader.read_int()
        _max_id = reader.read_int()
        _min_id = reader.read_int()
        _hash = reader.read_int()
        return cls(peer=_peer, q=_q, filter=_filter, min_date=_min_date, max_date=_max_date, offset_id=_offset_id, add_offset=_add_offset, limit=_limit, max_id=_max_id, min_id=_min_id, hash=_hash, from_id=_from_id)


class SearchGifsRequest(TLRequest):
    CONSTRUCTOR_ID = 0xbf9a776b
    SUBCLASS_OF_ID = 0xe799ea7

    def __init__(self, q, offset):
        """
        :param str q:
        :param int offset:

        :returns messages.FoundGifs: Instance of FoundGifs.
        """
        self.q = q  # type: str
        self.offset = offset  # type: int

    def to_dict(self):
        return {
            '_': 'SearchGifsRequest',
            'q': self.q,
            'offset': self.offset
        }

    def __bytes__(self):
        return b''.join((
            b'kw\x9a\xbf',
            self.serialize_bytes(self.q),
            struct.pack('<i', self.offset),
        ))

    @classmethod
    def from_reader(cls, reader):
        _q = reader.tgread_string()
        _offset = reader.read_int()
        return cls(q=_q, offset=_offset)


class SearchGlobalRequest(TLRequest):
    CONSTRUCTOR_ID = 0x9e3cacb0
    SUBCLASS_OF_ID = 0xd4b40b5e

    def __init__(self, q, offset_date, offset_peer, offset_id, limit):
        """
        :param str q:
        :param Optional[datetime] offset_date:
        :param TypeInputPeer offset_peer:
        :param int offset_id:
        :param int limit:

        :returns messages.Messages: Instance of either Messages, MessagesSlice, ChannelMessages, MessagesNotModified.
        """
        self.q = q  # type: str
        self.offset_date = offset_date  # type: Optional[datetime]
        self.offset_peer = offset_peer  # type: TypeInputPeer
        self.offset_id = offset_id  # type: int
        self.limit = limit  # type: int

    async def resolve(self, client, utils):
        self.offset_peer = utils.get_input_peer(await client.get_input_entity(self.offset_peer))

    def to_dict(self):
        return {
            '_': 'SearchGlobalRequest',
            'q': self.q,
            'offset_date': self.offset_date,
            'offset_peer': None if self.offset_peer is None else self.offset_peer.to_dict(),
            'offset_id': self.offset_id,
            'limit': self.limit
        }

    def __bytes__(self):
        return b''.join((
            b'\xb0\xac<\x9e',
            self.serialize_bytes(self.q),
            self.serialize_datetime(self.offset_date),
            bytes(self.offset_peer),
            struct.pack('<i', self.offset_id),
            struct.pack('<i', self.limit),
        ))

    @classmethod
    def from_reader(cls, reader):
        _q = reader.tgread_string()
        _offset_date = reader.tgread_date()
        _offset_peer = reader.tgread_object()
        _offset_id = reader.read_int()
        _limit = reader.read_int()
        return cls(q=_q, offset_date=_offset_date, offset_peer=_offset_peer, offset_id=_offset_id, limit=_limit)


class SearchStickerSetsRequest(TLRequest):
    CONSTRUCTOR_ID = 0xc2b7d08b
    SUBCLASS_OF_ID = 0x40df361

    def __init__(self, q, hash, exclude_featured=None):
        """
        :param str q:
        :param int hash:
        :param Optional[bool] exclude_featured:

        :returns messages.FoundStickerSets: Instance of either FoundStickerSetsNotModified, FoundStickerSets.
        """
        self.q = q  # type: str
        self.hash = hash  # type: int
        self.exclude_featured = exclude_featured  # type: Optional[bool]

    def to_dict(self):
        return {
            '_': 'SearchStickerSetsRequest',
            'q': self.q,
            'hash': self.hash,
            'exclude_featured': self.exclude_featured
        }

    def __bytes__(self):
        return b''.join((
            b'\x8b\xd0\xb7\xc2',
            struct.pack('<I', (0 if self.exclude_featured is None or self.exclude_featured is False else 1)),
            self.serialize_bytes(self.q),
            struct.pack('<i', self.hash),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _exclude_featured = bool(flags & 1)
        _q = reader.tgread_string()
        _hash = reader.read_int()
        return cls(q=_q, hash=_hash, exclude_featured=_exclude_featured)


class SendEncryptedRequest(TLRequest):
    CONSTRUCTOR_ID = 0xa9776773
    SUBCLASS_OF_ID = 0xc99e3e50

    def __init__(self, peer, data, random_id=None):
        """
        :param TypeInputEncryptedChat peer:
        :param bytes data:
        :param int random_id:

        :returns messages.SentEncryptedMessage: Instance of either SentEncryptedMessage, SentEncryptedFile.
        """
        self.peer = peer  # type: TypeInputEncryptedChat
        self.data = data  # type: bytes
        self.random_id = random_id if random_id is not None else int.from_bytes(os.urandom(8), 'big', signed=True)

    def to_dict(self):
        return {
            '_': 'SendEncryptedRequest',
            'peer': None if self.peer is None else self.peer.to_dict(),
            'data': self.data,
            'random_id': self.random_id
        }

    def __bytes__(self):
        return b''.join((
            b'sgw\xa9',
            bytes(self.peer),
            struct.pack('<q', self.random_id),
            self.serialize_bytes(self.data),
        ))

    @classmethod
    def from_reader(cls, reader):
        _peer = reader.tgread_object()
        _random_id = reader.read_long()
        _data = reader.tgread_bytes()
        return cls(peer=_peer, data=_data, random_id=_random_id)


class SendEncryptedFileRequest(TLRequest):
    CONSTRUCTOR_ID = 0x9a901b66
    SUBCLASS_OF_ID = 0xc99e3e50

    def __init__(self, peer, data, file, random_id=None):
        """
        :param TypeInputEncryptedChat peer:
        :param bytes data:
        :param TypeInputEncryptedFile file:
        :param int random_id:

        :returns messages.SentEncryptedMessage: Instance of either SentEncryptedMessage, SentEncryptedFile.
        """
        self.peer = peer  # type: TypeInputEncryptedChat
        self.data = data  # type: bytes
        self.file = file  # type: TypeInputEncryptedFile
        self.random_id = random_id if random_id is not None else int.from_bytes(os.urandom(8), 'big', signed=True)

    def to_dict(self):
        return {
            '_': 'SendEncryptedFileRequest',
            'peer': None if self.peer is None else self.peer.to_dict(),
            'data': self.data,
            'file': None if self.file is None else self.file.to_dict(),
            'random_id': self.random_id
        }

    def __bytes__(self):
        return b''.join((
            b'f\x1b\x90\x9a',
            bytes(self.peer),
            struct.pack('<q', self.random_id),
            self.serialize_bytes(self.data),
            bytes(self.file),
        ))

    @classmethod
    def from_reader(cls, reader):
        _peer = reader.tgread_object()
        _random_id = reader.read_long()
        _data = reader.tgread_bytes()
        _file = reader.tgread_object()
        return cls(peer=_peer, data=_data, file=_file, random_id=_random_id)


class SendEncryptedServiceRequest(TLRequest):
    CONSTRUCTOR_ID = 0x32d439a4
    SUBCLASS_OF_ID = 0xc99e3e50

    def __init__(self, peer, data, random_id=None):
        """
        :param TypeInputEncryptedChat peer:
        :param bytes data:
        :param int random_id:

        :returns messages.SentEncryptedMessage: Instance of either SentEncryptedMessage, SentEncryptedFile.
        """
        self.peer = peer  # type: TypeInputEncryptedChat
        self.data = data  # type: bytes
        self.random_id = random_id if random_id is not None else int.from_bytes(os.urandom(8), 'big', signed=True)

    def to_dict(self):
        return {
            '_': 'SendEncryptedServiceRequest',
            'peer': None if self.peer is None else self.peer.to_dict(),
            'data': self.data,
            'random_id': self.random_id
        }

    def __bytes__(self):
        return b''.join((
            b'\xa49\xd42',
            bytes(self.peer),
            struct.pack('<q', self.random_id),
            self.serialize_bytes(self.data),
        ))

    @classmethod
    def from_reader(cls, reader):
        _peer = reader.tgread_object()
        _random_id = reader.read_long()
        _data = reader.tgread_bytes()
        return cls(peer=_peer, data=_data, random_id=_random_id)


class SendInlineBotResultRequest(TLRequest):
    CONSTRUCTOR_ID = 0xb16e06fe
    SUBCLASS_OF_ID = 0x8af52aac

    def __init__(self, peer, query_id, id, silent=None, background=None, clear_draft=None, reply_to_msg_id=None, random_id=None):
        """
        :param TypeInputPeer peer:
        :param int query_id:
        :param str id:
        :param Optional[bool] silent:
        :param Optional[bool] background:
        :param Optional[bool] clear_draft:
        :param Optional[int] reply_to_msg_id:
        :param int random_id:

        :returns Updates: Instance of either UpdatesTooLong, UpdateShortMessage, UpdateShortChatMessage, UpdateShort, UpdatesCombined, Updates, UpdateShortSentMessage.
        """
        self.peer = peer  # type: TypeInputPeer
        self.query_id = query_id  # type: int
        self.id = id  # type: str
        self.silent = silent  # type: Optional[bool]
        self.background = background  # type: Optional[bool]
        self.clear_draft = clear_draft  # type: Optional[bool]
        self.reply_to_msg_id = reply_to_msg_id  # type: Optional[int]
        self.random_id = random_id if random_id is not None else int.from_bytes(os.urandom(8), 'big', signed=True)

    async def resolve(self, client, utils):
        self.peer = utils.get_input_peer(await client.get_input_entity(self.peer))

    def to_dict(self):
        return {
            '_': 'SendInlineBotResultRequest',
            'peer': None if self.peer is None else self.peer.to_dict(),
            'query_id': self.query_id,
            'id': self.id,
            'silent': self.silent,
            'background': self.background,
            'clear_draft': self.clear_draft,
            'reply_to_msg_id': self.reply_to_msg_id,
            'random_id': self.random_id
        }

    def __bytes__(self):
        return b''.join((
            b'\xfe\x06n\xb1',
            struct.pack('<I', (0 if self.silent is None or self.silent is False else 32) | (0 if self.background is None or self.background is False else 64) | (0 if self.clear_draft is None or self.clear_draft is False else 128) | (0 if self.reply_to_msg_id is None or self.reply_to_msg_id is False else 1)),
            bytes(self.peer),
            b'' if self.reply_to_msg_id is None or self.reply_to_msg_id is False else (struct.pack('<i', self.reply_to_msg_id)),
            struct.pack('<q', self.random_id),
            struct.pack('<q', self.query_id),
            self.serialize_bytes(self.id),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _silent = bool(flags & 32)
        _background = bool(flags & 64)
        _clear_draft = bool(flags & 128)
        _peer = reader.tgread_object()
        if flags & 1:
            _reply_to_msg_id = reader.read_int()
        else:
            _reply_to_msg_id = None
        _random_id = reader.read_long()
        _query_id = reader.read_long()
        _id = reader.tgread_string()
        return cls(peer=_peer, query_id=_query_id, id=_id, silent=_silent, background=_background, clear_draft=_clear_draft, reply_to_msg_id=_reply_to_msg_id, random_id=_random_id)


class SendMediaRequest(TLRequest):
    CONSTRUCTOR_ID = 0xb8d1262b
    SUBCLASS_OF_ID = 0x8af52aac

    def __init__(self, peer, media, message, silent=None, background=None, clear_draft=None, reply_to_msg_id=None, random_id=None, reply_markup=None, entities=None):
        """
        :param TypeInputPeer peer:
        :param TypeInputMedia media:
        :param str message:
        :param Optional[bool] silent:
        :param Optional[bool] background:
        :param Optional[bool] clear_draft:
        :param Optional[int] reply_to_msg_id:
        :param int random_id:
        :param Optional[TypeReplyMarkup] reply_markup:
        :param Optional[List[TypeMessageEntity]] entities:

        :returns Updates: Instance of either UpdatesTooLong, UpdateShortMessage, UpdateShortChatMessage, UpdateShort, UpdatesCombined, Updates, UpdateShortSentMessage.
        """
        self.peer = peer  # type: TypeInputPeer
        self.media = media  # type: TypeInputMedia
        self.message = message  # type: str
        self.silent = silent  # type: Optional[bool]
        self.background = background  # type: Optional[bool]
        self.clear_draft = clear_draft  # type: Optional[bool]
        self.reply_to_msg_id = reply_to_msg_id  # type: Optional[int]
        self.random_id = random_id if random_id is not None else int.from_bytes(os.urandom(8), 'big', signed=True)
        self.reply_markup = reply_markup  # type: Optional[TypeReplyMarkup]
        self.entities = entities  # type: Optional[List[TypeMessageEntity]]

    async def resolve(self, client, utils):
        self.peer = utils.get_input_peer(await client.get_input_entity(self.peer))
        self.media = utils.get_input_media(self.media)

    def to_dict(self):
        return {
            '_': 'SendMediaRequest',
            'peer': None if self.peer is None else self.peer.to_dict(),
            'media': None if self.media is None else self.media.to_dict(),
            'message': self.message,
            'silent': self.silent,
            'background': self.background,
            'clear_draft': self.clear_draft,
            'reply_to_msg_id': self.reply_to_msg_id,
            'random_id': self.random_id,
            'reply_markup': None if self.reply_markup is None else self.reply_markup.to_dict(),
            'entities': [] if self.entities is None else [None if x is None else x.to_dict() for x in self.entities]
        }

    def __bytes__(self):
        return b''.join((
            b'+&\xd1\xb8',
            struct.pack('<I', (0 if self.silent is None or self.silent is False else 32) | (0 if self.background is None or self.background is False else 64) | (0 if self.clear_draft is None or self.clear_draft is False else 128) | (0 if self.reply_to_msg_id is None or self.reply_to_msg_id is False else 1) | (0 if self.reply_markup is None or self.reply_markup is False else 4) | (0 if self.entities is None or self.entities is False else 8)),
            bytes(self.peer),
            b'' if self.reply_to_msg_id is None or self.reply_to_msg_id is False else (struct.pack('<i', self.reply_to_msg_id)),
            bytes(self.media),
            self.serialize_bytes(self.message),
            struct.pack('<q', self.random_id),
            b'' if self.reply_markup is None or self.reply_markup is False else (bytes(self.reply_markup)),
            b'' if self.entities is None or self.entities is False else b''.join((b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.entities)),b''.join(bytes(x) for x in self.entities))),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _silent = bool(flags & 32)
        _background = bool(flags & 64)
        _clear_draft = bool(flags & 128)
        _peer = reader.tgread_object()
        if flags & 1:
            _reply_to_msg_id = reader.read_int()
        else:
            _reply_to_msg_id = None
        _media = reader.tgread_object()
        _message = reader.tgread_string()
        _random_id = reader.read_long()
        if flags & 4:
            _reply_markup = reader.tgread_object()
        else:
            _reply_markup = None
        if flags & 8:
            reader.read_int()
            _entities = []
            for _ in range(reader.read_int()):
                _x = reader.tgread_object()
                _entities.append(_x)

        else:
            _entities = None
        return cls(peer=_peer, media=_media, message=_message, silent=_silent, background=_background, clear_draft=_clear_draft, reply_to_msg_id=_reply_to_msg_id, random_id=_random_id, reply_markup=_reply_markup, entities=_entities)


class SendMessageRequest(TLRequest):
    CONSTRUCTOR_ID = 0xfa88427a
    SUBCLASS_OF_ID = 0x8af52aac

    def __init__(self, peer, message, no_webpage=None, silent=None, background=None, clear_draft=None, reply_to_msg_id=None, random_id=None, reply_markup=None, entities=None):
        """
        :param TypeInputPeer peer:
        :param str message:
        :param Optional[bool] no_webpage:
        :param Optional[bool] silent:
        :param Optional[bool] background:
        :param Optional[bool] clear_draft:
        :param Optional[int] reply_to_msg_id:
        :param int random_id:
        :param Optional[TypeReplyMarkup] reply_markup:
        :param Optional[List[TypeMessageEntity]] entities:

        :returns Updates: Instance of either UpdatesTooLong, UpdateShortMessage, UpdateShortChatMessage, UpdateShort, UpdatesCombined, Updates, UpdateShortSentMessage.
        """
        self.peer = peer  # type: TypeInputPeer
        self.message = message  # type: str
        self.no_webpage = no_webpage  # type: Optional[bool]
        self.silent = silent  # type: Optional[bool]
        self.background = background  # type: Optional[bool]
        self.clear_draft = clear_draft  # type: Optional[bool]
        self.reply_to_msg_id = reply_to_msg_id  # type: Optional[int]
        self.random_id = random_id if random_id is not None else int.from_bytes(os.urandom(8), 'big', signed=True)
        self.reply_markup = reply_markup  # type: Optional[TypeReplyMarkup]
        self.entities = entities  # type: Optional[List[TypeMessageEntity]]

    async def resolve(self, client, utils):
        self.peer = utils.get_input_peer(await client.get_input_entity(self.peer))

    def to_dict(self):
        return {
            '_': 'SendMessageRequest',
            'peer': None if self.peer is None else self.peer.to_dict(),
            'message': self.message,
            'no_webpage': self.no_webpage,
            'silent': self.silent,
            'background': self.background,
            'clear_draft': self.clear_draft,
            'reply_to_msg_id': self.reply_to_msg_id,
            'random_id': self.random_id,
            'reply_markup': None if self.reply_markup is None else self.reply_markup.to_dict(),
            'entities': [] if self.entities is None else [None if x is None else x.to_dict() for x in self.entities]
        }

    def __bytes__(self):
        return b''.join((
            b'zB\x88\xfa',
            struct.pack('<I', (0 if self.no_webpage is None or self.no_webpage is False else 2) | (0 if self.silent is None or self.silent is False else 32) | (0 if self.background is None or self.background is False else 64) | (0 if self.clear_draft is None or self.clear_draft is False else 128) | (0 if self.reply_to_msg_id is None or self.reply_to_msg_id is False else 1) | (0 if self.reply_markup is None or self.reply_markup is False else 4) | (0 if self.entities is None or self.entities is False else 8)),
            bytes(self.peer),
            b'' if self.reply_to_msg_id is None or self.reply_to_msg_id is False else (struct.pack('<i', self.reply_to_msg_id)),
            self.serialize_bytes(self.message),
            struct.pack('<q', self.random_id),
            b'' if self.reply_markup is None or self.reply_markup is False else (bytes(self.reply_markup)),
            b'' if self.entities is None or self.entities is False else b''.join((b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.entities)),b''.join(bytes(x) for x in self.entities))),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _no_webpage = bool(flags & 2)
        _silent = bool(flags & 32)
        _background = bool(flags & 64)
        _clear_draft = bool(flags & 128)
        _peer = reader.tgread_object()
        if flags & 1:
            _reply_to_msg_id = reader.read_int()
        else:
            _reply_to_msg_id = None
        _message = reader.tgread_string()
        _random_id = reader.read_long()
        if flags & 4:
            _reply_markup = reader.tgread_object()
        else:
            _reply_markup = None
        if flags & 8:
            reader.read_int()
            _entities = []
            for _ in range(reader.read_int()):
                _x = reader.tgread_object()
                _entities.append(_x)

        else:
            _entities = None
        return cls(peer=_peer, message=_message, no_webpage=_no_webpage, silent=_silent, background=_background, clear_draft=_clear_draft, reply_to_msg_id=_reply_to_msg_id, random_id=_random_id, reply_markup=_reply_markup, entities=_entities)


class SendMultiMediaRequest(TLRequest):
    CONSTRUCTOR_ID = 0x2095512f
    SUBCLASS_OF_ID = 0x8af52aac

    def __init__(self, peer, multi_media, silent=None, background=None, clear_draft=None, reply_to_msg_id=None):
        """
        :param TypeInputPeer peer:
        :param List[TypeInputSingleMedia] multi_media:
        :param Optional[bool] silent:
        :param Optional[bool] background:
        :param Optional[bool] clear_draft:
        :param Optional[int] reply_to_msg_id:

        :returns Updates: Instance of either UpdatesTooLong, UpdateShortMessage, UpdateShortChatMessage, UpdateShort, UpdatesCombined, Updates, UpdateShortSentMessage.
        """
        self.peer = peer  # type: TypeInputPeer
        self.multi_media = multi_media  # type: List[TypeInputSingleMedia]
        self.silent = silent  # type: Optional[bool]
        self.background = background  # type: Optional[bool]
        self.clear_draft = clear_draft  # type: Optional[bool]
        self.reply_to_msg_id = reply_to_msg_id  # type: Optional[int]

    async def resolve(self, client, utils):
        self.peer = utils.get_input_peer(await client.get_input_entity(self.peer))

    def to_dict(self):
        return {
            '_': 'SendMultiMediaRequest',
            'peer': None if self.peer is None else self.peer.to_dict(),
            'multi_media': [] if self.multi_media is None else [None if x is None else x.to_dict() for x in self.multi_media],
            'silent': self.silent,
            'background': self.background,
            'clear_draft': self.clear_draft,
            'reply_to_msg_id': self.reply_to_msg_id
        }

    def __bytes__(self):
        return b''.join((
            b'/Q\x95 ',
            struct.pack('<I', (0 if self.silent is None or self.silent is False else 32) | (0 if self.background is None or self.background is False else 64) | (0 if self.clear_draft is None or self.clear_draft is False else 128) | (0 if self.reply_to_msg_id is None or self.reply_to_msg_id is False else 1)),
            bytes(self.peer),
            b'' if self.reply_to_msg_id is None or self.reply_to_msg_id is False else (struct.pack('<i', self.reply_to_msg_id)),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.multi_media)),b''.join(bytes(x) for x in self.multi_media),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _silent = bool(flags & 32)
        _background = bool(flags & 64)
        _clear_draft = bool(flags & 128)
        _peer = reader.tgread_object()
        if flags & 1:
            _reply_to_msg_id = reader.read_int()
        else:
            _reply_to_msg_id = None
        reader.read_int()
        _multi_media = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _multi_media.append(_x)

        return cls(peer=_peer, multi_media=_multi_media, silent=_silent, background=_background, clear_draft=_clear_draft, reply_to_msg_id=_reply_to_msg_id)


class SendScreenshotNotificationRequest(TLRequest):
    CONSTRUCTOR_ID = 0xc97df020
    SUBCLASS_OF_ID = 0x8af52aac

    def __init__(self, peer, reply_to_msg_id, random_id=None):
        """
        :param TypeInputPeer peer:
        :param int reply_to_msg_id:
        :param int random_id:

        :returns Updates: Instance of either UpdatesTooLong, UpdateShortMessage, UpdateShortChatMessage, UpdateShort, UpdatesCombined, Updates, UpdateShortSentMessage.
        """
        self.peer = peer  # type: TypeInputPeer
        self.reply_to_msg_id = reply_to_msg_id  # type: int
        self.random_id = random_id if random_id is not None else int.from_bytes(os.urandom(8), 'big', signed=True)

    async def resolve(self, client, utils):
        self.peer = utils.get_input_peer(await client.get_input_entity(self.peer))

    def to_dict(self):
        return {
            '_': 'SendScreenshotNotificationRequest',
            'peer': None if self.peer is None else self.peer.to_dict(),
            'reply_to_msg_id': self.reply_to_msg_id,
            'random_id': self.random_id
        }

    def __bytes__(self):
        return b''.join((
            b' \xf0}\xc9',
            bytes(self.peer),
            struct.pack('<i', self.reply_to_msg_id),
            struct.pack('<q', self.random_id),
        ))

    @classmethod
    def from_reader(cls, reader):
        _peer = reader.tgread_object()
        _reply_to_msg_id = reader.read_int()
        _random_id = reader.read_long()
        return cls(peer=_peer, reply_to_msg_id=_reply_to_msg_id, random_id=_random_id)


class SetBotCallbackAnswerRequest(TLRequest):
    CONSTRUCTOR_ID = 0xd58f130a
    SUBCLASS_OF_ID = 0xf5b399ac

    def __init__(self, query_id, cache_time, alert=None, message=None, url=None):
        """
        :param int query_id:
        :param int cache_time:
        :param Optional[bool] alert:
        :param Optional[str] message:
        :param Optional[str] url:

        :returns Bool: This type has no constructors.
        """
        self.query_id = query_id  # type: int
        self.cache_time = cache_time  # type: int
        self.alert = alert  # type: Optional[bool]
        self.message = message  # type: Optional[str]
        self.url = url  # type: Optional[str]

    def to_dict(self):
        return {
            '_': 'SetBotCallbackAnswerRequest',
            'query_id': self.query_id,
            'cache_time': self.cache_time,
            'alert': self.alert,
            'message': self.message,
            'url': self.url
        }

    def __bytes__(self):
        return b''.join((
            b'\n\x13\x8f\xd5',
            struct.pack('<I', (0 if self.alert is None or self.alert is False else 2) | (0 if self.message is None or self.message is False else 1) | (0 if self.url is None or self.url is False else 4)),
            struct.pack('<q', self.query_id),
            b'' if self.message is None or self.message is False else (self.serialize_bytes(self.message)),
            b'' if self.url is None or self.url is False else (self.serialize_bytes(self.url)),
            struct.pack('<i', self.cache_time),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _alert = bool(flags & 2)
        _query_id = reader.read_long()
        if flags & 1:
            _message = reader.tgread_string()
        else:
            _message = None
        if flags & 4:
            _url = reader.tgread_string()
        else:
            _url = None
        _cache_time = reader.read_int()
        return cls(query_id=_query_id, cache_time=_cache_time, alert=_alert, message=_message, url=_url)


class SetBotPrecheckoutResultsRequest(TLRequest):
    CONSTRUCTOR_ID = 0x9c2dd95
    SUBCLASS_OF_ID = 0xf5b399ac

    def __init__(self, query_id, success=None, error=None):
        """
        :param int query_id:
        :param Optional[bool] success:
        :param Optional[str] error:

        :returns Bool: This type has no constructors.
        """
        self.query_id = query_id  # type: int
        self.success = success  # type: Optional[bool]
        self.error = error  # type: Optional[str]

    def to_dict(self):
        return {
            '_': 'SetBotPrecheckoutResultsRequest',
            'query_id': self.query_id,
            'success': self.success,
            'error': self.error
        }

    def __bytes__(self):
        return b''.join((
            b'\x95\xdd\xc2\t',
            struct.pack('<I', (0 if self.success is None or self.success is False else 2) | (0 if self.error is None or self.error is False else 1)),
            struct.pack('<q', self.query_id),
            b'' if self.error is None or self.error is False else (self.serialize_bytes(self.error)),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _success = bool(flags & 2)
        _query_id = reader.read_long()
        if flags & 1:
            _error = reader.tgread_string()
        else:
            _error = None
        return cls(query_id=_query_id, success=_success, error=_error)


class SetBotShippingResultsRequest(TLRequest):
    CONSTRUCTOR_ID = 0xe5f672fa
    SUBCLASS_OF_ID = 0xf5b399ac

    def __init__(self, query_id, error=None, shipping_options=None):
        """
        :param int query_id:
        :param Optional[str] error:
        :param Optional[List[TypeShippingOption]] shipping_options:

        :returns Bool: This type has no constructors.
        """
        self.query_id = query_id  # type: int
        self.error = error  # type: Optional[str]
        self.shipping_options = shipping_options  # type: Optional[List[TypeShippingOption]]

    def to_dict(self):
        return {
            '_': 'SetBotShippingResultsRequest',
            'query_id': self.query_id,
            'error': self.error,
            'shipping_options': [] if self.shipping_options is None else [None if x is None else x.to_dict() for x in self.shipping_options]
        }

    def __bytes__(self):
        return b''.join((
            b'\xfar\xf6\xe5',
            struct.pack('<I', (0 if self.error is None or self.error is False else 1) | (0 if self.shipping_options is None or self.shipping_options is False else 2)),
            struct.pack('<q', self.query_id),
            b'' if self.error is None or self.error is False else (self.serialize_bytes(self.error)),
            b'' if self.shipping_options is None or self.shipping_options is False else b''.join((b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.shipping_options)),b''.join(bytes(x) for x in self.shipping_options))),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _query_id = reader.read_long()
        if flags & 1:
            _error = reader.tgread_string()
        else:
            _error = None
        if flags & 2:
            reader.read_int()
            _shipping_options = []
            for _ in range(reader.read_int()):
                _x = reader.tgread_object()
                _shipping_options.append(_x)

        else:
            _shipping_options = None
        return cls(query_id=_query_id, error=_error, shipping_options=_shipping_options)


class SetEncryptedTypingRequest(TLRequest):
    CONSTRUCTOR_ID = 0x791451ed
    SUBCLASS_OF_ID = 0xf5b399ac

    def __init__(self, peer, typing):
        """
        :param TypeInputEncryptedChat peer:
        :param TypeBool typing:

        :returns Bool: This type has no constructors.
        """
        self.peer = peer  # type: TypeInputEncryptedChat
        self.typing = typing  # type: TypeBool

    def to_dict(self):
        return {
            '_': 'SetEncryptedTypingRequest',
            'peer': None if self.peer is None else self.peer.to_dict(),
            'typing': self.typing
        }

    def __bytes__(self):
        return b''.join((
            b'\xedQ\x14y',
            bytes(self.peer),
            b'\xb5ur\x99' if self.typing else b'7\x97y\xbc',
        ))

    @classmethod
    def from_reader(cls, reader):
        _peer = reader.tgread_object()
        _typing = reader.tgread_bool()
        return cls(peer=_peer, typing=_typing)


class SetGameScoreRequest(TLRequest):
    CONSTRUCTOR_ID = 0x8ef8ecc0
    SUBCLASS_OF_ID = 0x8af52aac

    def __init__(self, peer, id, user_id, score, edit_message=None, force=None):
        """
        :param TypeInputPeer peer:
        :param int id:
        :param TypeInputUser user_id:
        :param int score:
        :param Optional[bool] edit_message:
        :param Optional[bool] force:

        :returns Updates: Instance of either UpdatesTooLong, UpdateShortMessage, UpdateShortChatMessage, UpdateShort, UpdatesCombined, Updates, UpdateShortSentMessage.
        """
        self.peer = peer  # type: TypeInputPeer
        self.id = id  # type: int
        self.user_id = user_id  # type: TypeInputUser
        self.score = score  # type: int
        self.edit_message = edit_message  # type: Optional[bool]
        self.force = force  # type: Optional[bool]

    async def resolve(self, client, utils):
        self.peer = utils.get_input_peer(await client.get_input_entity(self.peer))
        self.user_id = utils.get_input_user(await client.get_input_entity(self.user_id))

    def to_dict(self):
        return {
            '_': 'SetGameScoreRequest',
            'peer': None if self.peer is None else self.peer.to_dict(),
            'id': self.id,
            'user_id': None if self.user_id is None else self.user_id.to_dict(),
            'score': self.score,
            'edit_message': self.edit_message,
            'force': self.force
        }

    def __bytes__(self):
        return b''.join((
            b'\xc0\xec\xf8\x8e',
            struct.pack('<I', (0 if self.edit_message is None or self.edit_message is False else 1) | (0 if self.force is None or self.force is False else 2)),
            bytes(self.peer),
            struct.pack('<i', self.id),
            bytes(self.user_id),
            struct.pack('<i', self.score),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _edit_message = bool(flags & 1)
        _force = bool(flags & 2)
        _peer = reader.tgread_object()
        _id = reader.read_int()
        _user_id = reader.tgread_object()
        _score = reader.read_int()
        return cls(peer=_peer, id=_id, user_id=_user_id, score=_score, edit_message=_edit_message, force=_force)


class SetInlineBotResultsRequest(TLRequest):
    CONSTRUCTOR_ID = 0xeb5ea206
    SUBCLASS_OF_ID = 0xf5b399ac

    def __init__(self, query_id, results, cache_time, gallery=None, private=None, next_offset=None, switch_pm=None):
        """
        :param int query_id:
        :param List[TypeInputBotInlineResult] results:
        :param int cache_time:
        :param Optional[bool] gallery:
        :param Optional[bool] private:
        :param Optional[str] next_offset:
        :param Optional[TypeInlineBotSwitchPM] switch_pm:

        :returns Bool: This type has no constructors.
        """
        self.query_id = query_id  # type: int
        self.results = results  # type: List[TypeInputBotInlineResult]
        self.cache_time = cache_time  # type: int
        self.gallery = gallery  # type: Optional[bool]
        self.private = private  # type: Optional[bool]
        self.next_offset = next_offset  # type: Optional[str]
        self.switch_pm = switch_pm  # type: Optional[TypeInlineBotSwitchPM]

    def to_dict(self):
        return {
            '_': 'SetInlineBotResultsRequest',
            'query_id': self.query_id,
            'results': [] if self.results is None else [None if x is None else x.to_dict() for x in self.results],
            'cache_time': self.cache_time,
            'gallery': self.gallery,
            'private': self.private,
            'next_offset': self.next_offset,
            'switch_pm': None if self.switch_pm is None else self.switch_pm.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\x06\xa2^\xeb',
            struct.pack('<I', (0 if self.gallery is None or self.gallery is False else 1) | (0 if self.private is None or self.private is False else 2) | (0 if self.next_offset is None or self.next_offset is False else 4) | (0 if self.switch_pm is None or self.switch_pm is False else 8)),
            struct.pack('<q', self.query_id),
            b'\x15\xc4\xb5\x1c',struct.pack('<i', len(self.results)),b''.join(bytes(x) for x in self.results),
            struct.pack('<i', self.cache_time),
            b'' if self.next_offset is None or self.next_offset is False else (self.serialize_bytes(self.next_offset)),
            b'' if self.switch_pm is None or self.switch_pm is False else (bytes(self.switch_pm)),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _gallery = bool(flags & 1)
        _private = bool(flags & 2)
        _query_id = reader.read_long()
        reader.read_int()
        _results = []
        for _ in range(reader.read_int()):
            _x = reader.tgread_object()
            _results.append(_x)

        _cache_time = reader.read_int()
        if flags & 4:
            _next_offset = reader.tgread_string()
        else:
            _next_offset = None
        if flags & 8:
            _switch_pm = reader.tgread_object()
        else:
            _switch_pm = None
        return cls(query_id=_query_id, results=_results, cache_time=_cache_time, gallery=_gallery, private=_private, next_offset=_next_offset, switch_pm=_switch_pm)


class SetInlineGameScoreRequest(TLRequest):
    CONSTRUCTOR_ID = 0x15ad9f64
    SUBCLASS_OF_ID = 0xf5b399ac

    def __init__(self, id, user_id, score, edit_message=None, force=None):
        """
        :param TypeInputBotInlineMessageID id:
        :param TypeInputUser user_id:
        :param int score:
        :param Optional[bool] edit_message:
        :param Optional[bool] force:

        :returns Bool: This type has no constructors.
        """
        self.id = id  # type: TypeInputBotInlineMessageID
        self.user_id = user_id  # type: TypeInputUser
        self.score = score  # type: int
        self.edit_message = edit_message  # type: Optional[bool]
        self.force = force  # type: Optional[bool]

    async def resolve(self, client, utils):
        self.user_id = utils.get_input_user(await client.get_input_entity(self.user_id))

    def to_dict(self):
        return {
            '_': 'SetInlineGameScoreRequest',
            'id': None if self.id is None else self.id.to_dict(),
            'user_id': None if self.user_id is None else self.user_id.to_dict(),
            'score': self.score,
            'edit_message': self.edit_message,
            'force': self.force
        }

    def __bytes__(self):
        return b''.join((
            b'd\x9f\xad\x15',
            struct.pack('<I', (0 if self.edit_message is None or self.edit_message is False else 1) | (0 if self.force is None or self.force is False else 2)),
            bytes(self.id),
            bytes(self.user_id),
            struct.pack('<i', self.score),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _edit_message = bool(flags & 1)
        _force = bool(flags & 2)
        _id = reader.tgread_object()
        _user_id = reader.tgread_object()
        _score = reader.read_int()
        return cls(id=_id, user_id=_user_id, score=_score, edit_message=_edit_message, force=_force)


class SetTypingRequest(TLRequest):
    CONSTRUCTOR_ID = 0xa3825e50
    SUBCLASS_OF_ID = 0xf5b399ac

    def __init__(self, peer, action):
        """
        :param TypeInputPeer peer:
        :param TypeSendMessageAction action:

        :returns Bool: This type has no constructors.
        """
        self.peer = peer  # type: TypeInputPeer
        self.action = action  # type: TypeSendMessageAction

    async def resolve(self, client, utils):
        self.peer = utils.get_input_peer(await client.get_input_entity(self.peer))

    def to_dict(self):
        return {
            '_': 'SetTypingRequest',
            'peer': None if self.peer is None else self.peer.to_dict(),
            'action': None if self.action is None else self.action.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'P^\x82\xa3',
            bytes(self.peer),
            bytes(self.action),
        ))

    @classmethod
    def from_reader(cls, reader):
        _peer = reader.tgread_object()
        _action = reader.tgread_object()
        return cls(peer=_peer, action=_action)


class StartBotRequest(TLRequest):
    CONSTRUCTOR_ID = 0xe6df7378
    SUBCLASS_OF_ID = 0x8af52aac

    def __init__(self, bot, peer, start_param, random_id=None):
        """
        :param TypeInputUser bot:
        :param TypeInputPeer peer:
        :param str start_param:
        :param int random_id:

        :returns Updates: Instance of either UpdatesTooLong, UpdateShortMessage, UpdateShortChatMessage, UpdateShort, UpdatesCombined, Updates, UpdateShortSentMessage.
        """
        self.bot = bot  # type: TypeInputUser
        self.peer = peer  # type: TypeInputPeer
        self.start_param = start_param  # type: str
        self.random_id = random_id if random_id is not None else int.from_bytes(os.urandom(8), 'big', signed=True)

    async def resolve(self, client, utils):
        self.bot = utils.get_input_user(await client.get_input_entity(self.bot))
        self.peer = utils.get_input_peer(await client.get_input_entity(self.peer))

    def to_dict(self):
        return {
            '_': 'StartBotRequest',
            'bot': None if self.bot is None else self.bot.to_dict(),
            'peer': None if self.peer is None else self.peer.to_dict(),
            'start_param': self.start_param,
            'random_id': self.random_id
        }

    def __bytes__(self):
        return b''.join((
            b'xs\xdf\xe6',
            bytes(self.bot),
            bytes(self.peer),
            struct.pack('<q', self.random_id),
            self.serialize_bytes(self.start_param),
        ))

    @classmethod
    def from_reader(cls, reader):
        _bot = reader.tgread_object()
        _peer = reader.tgread_object()
        _random_id = reader.read_long()
        _start_param = reader.tgread_string()
        return cls(bot=_bot, peer=_peer, start_param=_start_param, random_id=_random_id)


class ToggleChatAdminsRequest(TLRequest):
    CONSTRUCTOR_ID = 0xec8bd9e1
    SUBCLASS_OF_ID = 0x8af52aac

    def __init__(self, chat_id, enabled):
        """
        :param int chat_id:
        :param TypeBool enabled:

        :returns Updates: Instance of either UpdatesTooLong, UpdateShortMessage, UpdateShortChatMessage, UpdateShort, UpdatesCombined, Updates, UpdateShortSentMessage.
        """
        self.chat_id = chat_id  # type: int
        self.enabled = enabled  # type: TypeBool

    async def resolve(self, client, utils):
        self.chat_id = await client.get_peer_id(self.chat_id, add_mark=False)

    def to_dict(self):
        return {
            '_': 'ToggleChatAdminsRequest',
            'chat_id': self.chat_id,
            'enabled': self.enabled
        }

    def __bytes__(self):
        return b''.join((
            b'\xe1\xd9\x8b\xec',
            struct.pack('<i', self.chat_id),
            b'\xb5ur\x99' if self.enabled else b'7\x97y\xbc',
        ))

    @classmethod
    def from_reader(cls, reader):
        _chat_id = reader.read_int()
        _enabled = reader.tgread_bool()
        return cls(chat_id=_chat_id, enabled=_enabled)


class ToggleDialogPinRequest(TLRequest):
    CONSTRUCTOR_ID = 0xa731e257
    SUBCLASS_OF_ID = 0xf5b399ac

    def __init__(self, peer, pinned=None):
        """
        :param TypeInputDialogPeer peer:
        :param Optional[bool] pinned:

        :returns Bool: This type has no constructors.
        """
        self.peer = peer  # type: TypeInputDialogPeer
        self.pinned = pinned  # type: Optional[bool]

    async def resolve(self, client, utils):
        self.peer = utils.get_input_dialog(await client.get_input_entity(self.peer))

    def to_dict(self):
        return {
            '_': 'ToggleDialogPinRequest',
            'peer': None if self.peer is None else self.peer.to_dict(),
            'pinned': self.pinned
        }

    def __bytes__(self):
        return b''.join((
            b'W\xe21\xa7',
            struct.pack('<I', (0 if self.pinned is None or self.pinned is False else 1)),
            bytes(self.peer),
        ))

    @classmethod
    def from_reader(cls, reader):
        flags = reader.read_int()

        _pinned = bool(flags & 1)
        _peer = reader.tgread_object()
        return cls(peer=_peer, pinned=_pinned)


class UninstallStickerSetRequest(TLRequest):
    CONSTRUCTOR_ID = 0xf96e55de
    SUBCLASS_OF_ID = 0xf5b399ac

    def __init__(self, stickerset):
        """
        :param TypeInputStickerSet stickerset:

        :returns Bool: This type has no constructors.
        """
        self.stickerset = stickerset  # type: TypeInputStickerSet

    def to_dict(self):
        return {
            '_': 'UninstallStickerSetRequest',
            'stickerset': None if self.stickerset is None else self.stickerset.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\xdeUn\xf9',
            bytes(self.stickerset),
        ))

    @classmethod
    def from_reader(cls, reader):
        _stickerset = reader.tgread_object()
        return cls(stickerset=_stickerset)


class UploadEncryptedFileRequest(TLRequest):
    CONSTRUCTOR_ID = 0x5057c497
    SUBCLASS_OF_ID = 0x842a67c0

    def __init__(self, peer, file):
        """
        :param TypeInputEncryptedChat peer:
        :param TypeInputEncryptedFile file:

        :returns EncryptedFile: Instance of either EncryptedFileEmpty, EncryptedFile.
        """
        self.peer = peer  # type: TypeInputEncryptedChat
        self.file = file  # type: TypeInputEncryptedFile

    def to_dict(self):
        return {
            '_': 'UploadEncryptedFileRequest',
            'peer': None if self.peer is None else self.peer.to_dict(),
            'file': None if self.file is None else self.file.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\x97\xc4WP',
            bytes(self.peer),
            bytes(self.file),
        ))

    @classmethod
    def from_reader(cls, reader):
        _peer = reader.tgread_object()
        _file = reader.tgread_object()
        return cls(peer=_peer, file=_file)


class UploadMediaRequest(TLRequest):
    CONSTRUCTOR_ID = 0x519bc2b1
    SUBCLASS_OF_ID = 0x476cbe32

    def __init__(self, peer, media):
        """
        :param TypeInputPeer peer:
        :param TypeInputMedia media:

        :returns MessageMedia: Instance of either MessageMediaEmpty, MessageMediaPhoto, MessageMediaGeo, MessageMediaContact, MessageMediaUnsupported, MessageMediaDocument, MessageMediaWebPage, MessageMediaVenue, MessageMediaGame, MessageMediaInvoice, MessageMediaGeoLive.
        """
        self.peer = peer  # type: TypeInputPeer
        self.media = media  # type: TypeInputMedia

    async def resolve(self, client, utils):
        self.peer = utils.get_input_peer(await client.get_input_entity(self.peer))
        self.media = utils.get_input_media(self.media)

    def to_dict(self):
        return {
            '_': 'UploadMediaRequest',
            'peer': None if self.peer is None else self.peer.to_dict(),
            'media': None if self.media is None else self.media.to_dict()
        }

    def __bytes__(self):
        return b''.join((
            b'\xb1\xc2\x9bQ',
            bytes(self.peer),
            bytes(self.media),
        ))

    @classmethod
    def from_reader(cls, reader):
        _peer = reader.tgread_object()
        _media = reader.tgread_object()
        return cls(peer=_peer, media=_media)

